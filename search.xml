<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Ubuntu20.04搭建谷粒学院环境</title>
    <url>/hexo-blog/2021/11/20/Ubuntu20.04%E6%90%AD%E5%BB%BA%E8%B0%B7%E7%B2%92%E5%AD%A6%E9%99%A2%E7%8E%AF%E5%A2%83/</url>
    <content><![CDATA[<h1 id="Ubuntu20-04搭建谷粒学院环境"><a href="#Ubuntu20-04搭建谷粒学院环境" class="headerlink" title="Ubuntu20.04搭建谷粒学院环境"></a>Ubuntu20.04搭建谷粒学院环境</h1><h2 id="一、安装MySQL"><a href="#一、安装MySQL" class="headerlink" title="一、安装MySQL"></a>一、安装MySQL</h2><p>1、下载地址：<a href="https://dev.mysql.com/downloads/repo/apt/">https://dev.mysql.com/downloads/repo/apt/</a></p>
<p><img src="https://rulerofterabithia-blog.oss-cn-hangzhou.aliyuncs.com/img/20220801143154.jpeg"></p>
<p>2、在文件夹中找到刚才下载的文件，打开终端</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo dpkg -i mysql-apt-config_0.8.20-1_all.deb</span><br></pre></td></tr></table></figure>

<p><img src="https://rulerofterabithia-blog.oss-cn-hangzhou.aliyuncs.com/img/20220801143249.jpeg"></p>
<p>3、</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt update</span><br></pre></td></tr></table></figure>

<p><img src="https://rulerofterabithia-blog.oss-cn-hangzhou.aliyuncs.com/img/20220801143333.jpeg"></p>
<p>4、</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt upgrade</span><br></pre></td></tr></table></figure>

<p><img src="https://rulerofterabithia-blog.oss-cn-hangzhou.aliyuncs.com/img/20220801143444.jpeg"></p>
<p>5、</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt install mysql-community-server</span><br></pre></td></tr></table></figure>

<p><img src="https://rulerofterabithia-blog.oss-cn-hangzhou.aliyuncs.com/img/20220801143538.jpeg"></p>
<p>6、测试</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mysql -uroot -p</span><br><span class="line">show databases;</span><br><span class="line">quit;</span><br></pre></td></tr></table></figure>

<p><img src="https://rulerofterabithia-blog.oss-cn-hangzhou.aliyuncs.com/img/20220801143618.jpeg"></p>
<h2 id="二、安装gcc编译器"><a href="#二、安装gcc编译器" class="headerlink" title="二、安装gcc编译器"></a>二、安装gcc编译器</h2><p>1、安装gcc编译器</p>
<p>更新Ubuntu安装包信息：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt update</span><br></pre></td></tr></table></figure>

<p>2、安装编译功能包</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt install build-essential</span><br></pre></td></tr></table></figure>

<p>3、安装开发文档</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get install manpages-dev</span><br></pre></td></tr></table></figure>

<p>4、检查gcc版本</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc --version</span><br></pre></td></tr></table></figure>

<p><img src="https://rulerofterabithia-blog.oss-cn-hangzhou.aliyuncs.com/img/20220801143702.jpeg"></p>
<h2 id="三、安装Redis"><a href="#三、安装Redis" class="headerlink" title="三、安装Redis"></a>三、安装Redis</h2><h3 id="（一）安装"><a href="#（一）安装" class="headerlink" title="（一）安装"></a>（一）安装</h3><p>1、下载地址：<a href="https://redis.io/">https://redis.io/</a></p>
<p><img src="https://rulerofterabithia-blog.oss-cn-hangzhou.aliyuncs.com/img/20220801143748.jpeg"></p>
<p>2、在根目录下新建opt文件夹，将刚才下载的Redis安装包解压到opt目录下</p>
<p><img src="https://rulerofterabithia-blog.oss-cn-hangzhou.aliyuncs.com/img/20220801143835.jpeg"></p>
<p>3、进入到redis-6.2.1文件夹下，在终端中打开，执行make命令（只是编译好）</p>
<p><img src="https://rulerofterabithia-blog.oss-cn-hangzhou.aliyuncs.com/img/20220801143912.jpeg"></p>
<p>4、执行make install命令，进行安装</p>
<p><img src="https://rulerofterabithia-blog.oss-cn-hangzhou.aliyuncs.com/img/20220801143946.jpeg"></p>
<p>5、默认安装位置在 /usr/local/bin</p>
<p><img src="https://rulerofterabithia-blog.oss-cn-hangzhou.aliyuncs.com/img/20220801144025.jpeg"></p>
<h3 id="（二）启动Redis"><a href="#（二）启动Redis" class="headerlink" title="（二）启动Redis"></a>（二）启动Redis</h3><p>1、前台启动（不推荐，因为关掉窗口redis也会关闭）</p>
<p><img src="https://rulerofterabithia-blog.oss-cn-hangzhou.aliyuncs.com/img/20220801144205.jpeg"></p>
<p>2、后台启动（<font color=red><strong>推荐</strong></font>）</p>
<p>（1）为了启动方便，先将redis-6.2.1目录下的redis.conf文件复制到etc目录下</p>
<p><img src="https://rulerofterabithia-blog.oss-cn-hangzhou.aliyuncs.com/img/20220801144246.jpeg"></p>
<p>（2）复制</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cp redis.conf /etc/redis.conf</span><br></pre></td></tr></table></figure>

<p>（3）来到etc目录下查看</p>
<p><img src="https://rulerofterabithia-blog.oss-cn-hangzhou.aliyuncs.com/img/20220801144322.jpeg"></p>
<p>（4）找到etc目录下的redis.conf文件，设置后台启动daemonize no改成yes，:wq!保存并退出</p>
<p><img src="https://rulerofterabithia-blog.oss-cn-hangzhou.aliyuncs.com/img/20220801144426.jpeg"></p>
<p>（5）启动redis</p>
<p><img src="https://rulerofterabithia-blog.oss-cn-hangzhou.aliyuncs.com/img/20220801144512.jpeg"></p>
<h3 id="（三）网络相关配置"><a href="#（三）网络相关配置" class="headerlink" title="（三）网络相关配置"></a>（三）网络相关配置</h3><p>1、默认情况bind=127.0.0.1只能接受本机的访问请求，不写的情况下，无限制接受任何ip地址的访问，生产环境           肯定要写你应用服务器的地址；服务器是需要远程访问的，所以需要将其注释掉</p>
<p>​      在etc/redis.conf文件中，设置</p>
<p><img src="https://rulerofterabithia-blog.oss-cn-hangzhou.aliyuncs.com/img/20220801144555.jpeg"></p>
<p>2、将本机访问保护模式设置no：protected-mode no</p>
<p><img src="https://rulerofterabithia-blog.oss-cn-hangzhou.aliyuncs.com/img/20220801144627.jpeg"></p>
<h2 id="四、安装JDK8"><a href="#四、安装JDK8" class="headerlink" title="四、安装JDK8"></a>四、安装JDK8</h2><p>1、执行以下命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt update</span><br><span class="line">sudo apt install openjdk-8-jdk</span><br></pre></td></tr></table></figure>

<p>2、检查版本</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">java -version</span><br></pre></td></tr></table></figure>

<p><img src="https://rulerofterabithia-blog.oss-cn-hangzhou.aliyuncs.com/img/20220801144725.jpeg"></p>
<h2 id="五、安装Maven"><a href="#五、安装Maven" class="headerlink" title="五、安装Maven"></a>五、安装Maven</h2><p>1、执行</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt install maven</span><br></pre></td></tr></table></figure>

<p><img src="https://rulerofterabithia-blog.oss-cn-hangzhou.aliyuncs.com/img/20220801144755.jpeg"></p>
<p>2、检查版本</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mvn -version</span><br></pre></td></tr></table></figure>

<p><img src="https://rulerofterabithia-blog.oss-cn-hangzhou.aliyuncs.com/img/20220801144825.jpeg"></p>
<h2 id="六、安装Git"><a href="#六、安装Git" class="headerlink" title="六、安装Git"></a>六、安装Git</h2><p>1、执行以下命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get install git</span><br></pre></td></tr></table></figure>

<p><img src="https://rulerofterabithia-blog.oss-cn-hangzhou.aliyuncs.com/img/20220801144922.jpg"></p>
<p>2、检查版本</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git version</span><br></pre></td></tr></table></figure>

<p><img src="https://rulerofterabithia-blog.oss-cn-hangzhou.aliyuncs.com/img/20220801145012.jpeg"></p>
<h2 id="七、安装Docker"><a href="#七、安装Docker" class="headerlink" title="七、安装Docker"></a>七、安装Docker</h2><p>1、执行以下命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt install docker.io</span><br></pre></td></tr></table></figure>

<p><img src="https://rulerofterabithia-blog.oss-cn-hangzhou.aliyuncs.com/img/20220801145049.jpeg"></p>
<p>2、检查版本</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker --version</span><br></pre></td></tr></table></figure>

<p><img src="https://rulerofterabithia-blog.oss-cn-hangzhou.aliyuncs.com/img/20220801145126.jpeg"></p>
]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringMVC</title>
    <url>/hexo-blog/2022/04/11/SpringMVC%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="一、SpringMVC简介"><a href="#一、SpringMVC简介" class="headerlink" title="一、SpringMVC简介"></a>一、SpringMVC简介</h1><h3 id="1、什么是MVC"><a href="#1、什么是MVC" class="headerlink" title="1、什么是MVC"></a>1、什么是MVC</h3><p>MVC是一种软件架构的思想，将软件按照模型、视图、控制器来划分</p>
<p>M：Model，模型层，指工程中的JavaBean，作用是处理数据</p>
<p>JavaBean分为两类：</p>
<ul>
<li>一类称为实体类Bean：专门存储业务数据的，如 Student、User 等</li>
<li>一类称为业务处理 Bean：指 Service 或 Dao 对象，专门用于处理业务逻辑和数据访问。</li>
</ul>
<p>V：View，视图层，指工程中的html或jsp等页面，作用是与用户进行交互，展示数据</p>
<p>C：Controller，控制层，指工程中的servlet，作用是接收请求和响应浏览器</p>
<p>MVC的工作流程：<br>用户通过视图层发送请求到服务器，在服务器中请求被Controller接收，Controller调用相应的Model层处理请求，处理完毕将结果返回到Controller，Controller再根据请求处理的结果找到相应的View视图，渲染数据后最终响应给浏览器</p>
<h3 id="2、什么是SpringMVC"><a href="#2、什么是SpringMVC" class="headerlink" title="2、什么是SpringMVC"></a>2、什么是SpringMVC</h3><p>SpringMVC是Spring的一个后续产品，是Spring的一个子项目</p>
<p>SpringMVC 是 Spring 为表述层开发提供的一整套完备的解决方案。在表述层框架历经 Strust、WebWork、Strust2 等诸多产品的历代更迭之后，目前业界普遍选择了 SpringMVC 作为 Java EE 项目表述层开发的<strong>首选方案</strong>。</p>
<blockquote>
<p>注：三层架构分为表述层（或表示层）、业务逻辑层、数据访问层，表述层表示前台页面和后台servlet</p>
</blockquote>
<h3 id="3、SpringMVC的特点"><a href="#3、SpringMVC的特点" class="headerlink" title="3、SpringMVC的特点"></a>3、SpringMVC的特点</h3><ul>
<li><strong>Spring 家族原生产品</strong>，与 IOC 容器等基础设施无缝对接</li>
<li><strong>基于原生的Servlet</strong>，通过了功能强大的<strong>前端控制器DispatcherServlet</strong>，对请求和响应进行统一处理</li>
<li>表述层各细分领域需要解决的问题<strong>全方位覆盖</strong>，提供<strong>全面解决方案</strong></li>
<li><strong>代码清新简洁</strong>，大幅度提升开发效率</li>
<li>内部组件化程度高，可插拔式组件<strong>即插即用</strong>，想要什么功能配置相应组件即可</li>
<li><strong>性能卓著</strong>，尤其适合现代大型、超大型互联网项目要求</li>
</ul>
<h1 id="二、HelloWorld"><a href="#二、HelloWorld" class="headerlink" title="二、HelloWorld"></a>二、HelloWorld</h1><h3 id="1、开发环境"><a href="#1、开发环境" class="headerlink" title="1、开发环境"></a>1、开发环境</h3><p>IDE：idea 2019.2</p>
<p>构建工具：maven3.5.4</p>
<p>服务器：tomcat7</p>
<p>Spring版本：5.3.1</p>
<h3 id="2、创建maven工程"><a href="#2、创建maven工程" class="headerlink" title="2、创建maven工程"></a>2、创建maven工程</h3><h5 id="a-gt-添加web模块"><a href="#a-gt-添加web模块" class="headerlink" title="a&gt;添加web模块"></a>a&gt;添加web模块</h5><h5 id="b-gt-打包方式：war"><a href="#b-gt-打包方式：war" class="headerlink" title="b&gt;打包方式：war"></a>b&gt;打包方式：war</h5><h5 id="c-gt-引入依赖"><a href="#c-gt-引入依赖" class="headerlink" title="c&gt;引入依赖"></a>c&gt;引入依赖</h5><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- SpringMVC --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-webmvc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.3.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 日志 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>ch.qos.logback<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>logback-classic<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- ServletAPI --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>javax.servlet-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- Spring5和Thymeleaf整合包 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.thymeleaf<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>thymeleaf-spring5<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.12.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>注：由于 Maven 的传递性，我们不必将所有需要的包全部配置依赖，而是配置最顶端的依赖，其他靠传递性导入。</p>
<p><img src="https://rulerofterabithia-blog.oss-cn-hangzhou.aliyuncs.com/img/20221016220327.png"></p>
<h3 id="3、配置web-xml"><a href="#3、配置web-xml" class="headerlink" title="3、配置web.xml"></a>3、配置web.xml</h3><p>注册SpringMVC的前端控制器DispatcherServlet</p>
<h5 id="a-gt-默认配置方式"><a href="#a-gt-默认配置方式" class="headerlink" title="a&gt;默认配置方式"></a>a&gt;默认配置方式</h5><p>此配置作用下，SpringMVC的配置文件默认位于WEB-INF下，默认名称为&lt;servlet-name&gt;-servlet.xml，例如，以下配置所对应SpringMVC的配置文件位于WEB-INF下，文件名为springMVC-servlet.xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置SpringMVC的前端控制器，对浏览器发送的请求统一进行处理 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>springMVC<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>springMVC<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">        设置springMVC的核心控制器所能处理的请求的请求路径</span></span><br><span class="line"><span class="comment">        /所匹配的请求可以是/login或.html或.js或.css方式的请求路径</span></span><br><span class="line"><span class="comment">        但是/不能匹配.jsp请求路径的请求</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h5 id="b-gt-扩展配置方式"><a href="#b-gt-扩展配置方式" class="headerlink" title="b&gt;扩展配置方式"></a>b&gt;扩展配置方式</h5><p>可通过init-param标签设置SpringMVC配置文件的位置和名称，通过load-on-startup标签设置SpringMVC前端控制器DispatcherServlet的初始化时间</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置SpringMVC的前端控制器，对浏览器发送的请求统一进行处理 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>springMVC<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 通过初始化参数指定SpringMVC配置文件的位置和名称 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- contextConfigLocation为固定值 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 使用classpath:表示从类路径查找配置文件，例如maven工程中的src/main/resources --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:springMVC.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- </span></span><br><span class="line"><span class="comment"> 		作为框架的核心组件，在启动过程中有大量的初始化操作要做</span></span><br><span class="line"><span class="comment">		而这些操作放在第一次请求时才执行会严重影响访问速度</span></span><br><span class="line"><span class="comment">		因此需要通过此标签将启动控制DispatcherServlet的初始化时间提前到服务器启动时</span></span><br><span class="line"><span class="comment">	--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>springMVC<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">        设置springMVC的核心控制器所能处理的请求的请求路径</span></span><br><span class="line"><span class="comment">        /所匹配的请求可以是/login或.html或.js或.css方式的请求路径</span></span><br><span class="line"><span class="comment">        但是/不能匹配.jsp请求路径的请求</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>注：</p>
<p>&lt;url-pattern&gt;标签中使用/和/*的区别：</p>
<p>/所匹配的请求可以是/login或.html或.js或.css方式的请求路径，但是/不能匹配.jsp请求路径的请求</p>
<p>因此就可以避免在访问jsp页面时，该请求被DispatcherServlet处理，从而找不到相应的页面</p>
<p>/*则能够匹配所有请求，例如在使用过滤器时，若需要对所有请求进行过滤，就需要使用/*的写法</p>
</blockquote>
<h3 id="4、创建请求控制器"><a href="#4、创建请求控制器" class="headerlink" title="4、创建请求控制器"></a>4、创建请求控制器</h3><p>由于前端控制器对浏览器发送的请求进行了统一的处理，但是具体的请求有不同的处理过程，因此需要创建处理具体请求的类，即请求控制器</p>
<p>请求控制器中每一个处理请求的方法成为控制器方法</p>
<p>因为SpringMVC的控制器由一个POJO（普通的Java类）担任，因此需要通过@Controller注解将其标识为一个控制层组件，交给Spring的IoC容器管理，此时SpringMVC才能够识别控制器的存在</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloController</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5、创建springMVC的配置文件"><a href="#5、创建springMVC的配置文件" class="headerlink" title="5、创建springMVC的配置文件"></a>5、创建springMVC的配置文件</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 自动扫描包 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.atguigu.mvc.controller&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 配置Thymeleaf视图解析器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;viewResolver&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.thymeleaf.spring5.view.ThymeleafViewResolver&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;order&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;characterEncoding&quot;</span> <span class="attr">value</span>=<span class="string">&quot;UTF-8&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;templateEngine&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.thymeleaf.spring5.SpringTemplateEngine&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;templateResolver&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.thymeleaf.spring5.templateresolver.SpringResourceTemplateResolver&quot;</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">                    <span class="comment">&lt;!-- 视图前缀 --&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;prefix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;/WEB-INF/templates/&quot;</span>/&gt;</span></span><br><span class="line">    </span><br><span class="line">                    <span class="comment">&lt;!-- 视图后缀 --&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;suffix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;.html&quot;</span>/&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;templateMode&quot;</span> <span class="attr">value</span>=<span class="string">&quot;HTML5&quot;</span>/&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;characterEncoding&quot;</span> <span class="attr">value</span>=<span class="string">&quot;UTF-8&quot;</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- </span></span><br><span class="line"><span class="comment">   处理静态资源，例如html、js、css、jpg</span></span><br><span class="line"><span class="comment">  若只设置该标签，则只能访问静态资源，其他请求则无法访问</span></span><br><span class="line"><span class="comment">  此时必须设置&lt;mvc:annotation-driven/&gt;解决问题</span></span><br><span class="line"><span class="comment"> --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:default-servlet-handler</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 开启mvc注解驱动 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:annotation-driven</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:message-converters</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 处理响应中文内容乱码 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.http.converter.StringHttpMessageConverter&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;defaultCharset&quot;</span> <span class="attr">value</span>=<span class="string">&quot;UTF-8&quot;</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;supportedMediaTypes&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">value</span>&gt;</span>text/html<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">value</span>&gt;</span>application/json<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mvc:message-converters</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mvc:annotation-driven</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="6、测试HelloWorld"><a href="#6、测试HelloWorld" class="headerlink" title="6、测试HelloWorld"></a>6、测试HelloWorld</h3><h5 id="a-gt-实现对首页的访问"><a href="#a-gt-实现对首页的访问" class="headerlink" title="a&gt;实现对首页的访问"></a>a&gt;实现对首页的访问</h5><p>在请求控制器中创建处理请求的方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// @RequestMapping注解：处理请求和控制器方法之间的映射关系</span></span><br><span class="line"><span class="comment">// @RequestMapping注解的value属性可以通过请求地址匹配请求，/表示的当前工程的上下文路径</span></span><br><span class="line"><span class="comment">// localhost:8080/springMVC/</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">index</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//设置视图名称</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;index&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="b-gt-通过超链接跳转到指定页面"><a href="#b-gt-通过超链接跳转到指定页面" class="headerlink" title="b&gt;通过超链接跳转到指定页面"></a>b&gt;通过超链接跳转到指定页面</h5><p>在主页index.html中设置超链接</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span> <span class="attr">xmlns:th</span>=<span class="string">&quot;http://www.thymeleaf.org&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>首页<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>首页<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">th:href</span>=<span class="string">&quot;@&#123;/hello&#125;&quot;</span>&gt;</span>HelloWorld<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在请求控制器中创建处理请求的方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/hello&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">HelloWorld</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;target&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="7、总结"><a href="#7、总结" class="headerlink" title="7、总结"></a>7、总结</h3><p>浏览器发送请求，若请求地址符合前端控制器的url-pattern，该请求就会被前端控制器DispatcherServlet处理。前端控制器会读取SpringMVC的核心配置文件，通过扫描组件找到控制器，将请求地址和控制器中@RequestMapping注解的value属性值进行匹配，若匹配成功，该注解所标识的控制器方法就是处理请求的方法。处理请求的方法需要返回一个字符串类型的视图名称，该视图名称会被视图解析器解析，加上前缀和后缀组成视图的路径，通过Thymeleaf对视图进行渲染，最终转发到视图所对应页面</p>
<h1 id="三、-RequestMapping注解"><a href="#三、-RequestMapping注解" class="headerlink" title="三、@RequestMapping注解"></a>三、@RequestMapping注解</h1><h3 id="1、-RequestMapping注解的功能"><a href="#1、-RequestMapping注解的功能" class="headerlink" title="1、@RequestMapping注解的功能"></a>1、@RequestMapping注解的功能</h3><p>从注解名称上我们可以看到，@RequestMapping注解的作用就是将请求和处理请求的控制器方法关联起来，建立映射关系。</p>
<p>SpringMVC 接收到指定的请求，就会来找到在映射关系中对应的控制器方法来处理这个请求。</p>
<h3 id="2、-RequestMapping注解的位置"><a href="#2、-RequestMapping注解的位置" class="headerlink" title="2、@RequestMapping注解的位置"></a>2、@RequestMapping注解的位置</h3><p>@RequestMapping标识一个类：设置映射请求的请求路径的初始信息</p>
<p>@RequestMapping标识一个方法：设置映射请求请求路径的具体信息</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/test&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RequestMappingController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//此时请求映射所映射的请求的请求路径为：/test/testRequestMapping</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/testRequestMapping&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">testRequestMapping</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3、-RequestMapping注解的value属性"><a href="#3、-RequestMapping注解的value属性" class="headerlink" title="3、@RequestMapping注解的value属性"></a>3、@RequestMapping注解的value属性</h3><p>@RequestMapping注解的value属性通过请求的请求地址匹配请求映射</p>
<p>@RequestMapping注解的value属性是一个字符串类型的数组，表示该请求映射能够匹配多个请求地址所对应的请求</p>
<p>@RequestMapping注解的value属性必须设置，至少通过请求地址匹配请求映射</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">th:href</span>=<span class="string">&quot;@&#123;/testRequestMapping&#125;&quot;</span>&gt;</span>测试@RequestMapping的value属性--&gt;/testRequestMapping<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">th:href</span>=<span class="string">&quot;@&#123;/test&#125;&quot;</span>&gt;</span>测试@RequestMapping的value属性--&gt;/test<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(</span></span><br><span class="line"><span class="meta">        value = &#123;&quot;/testRequestMapping&quot;, &quot;/test&quot;&#125;</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">testRequestMapping</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4、-RequestMapping注解的method属性"><a href="#4、-RequestMapping注解的method属性" class="headerlink" title="4、@RequestMapping注解的method属性"></a>4、@RequestMapping注解的method属性</h3><p>@RequestMapping注解的method属性通过请求的请求方式（get或post）匹配请求映射</p>
<p>@RequestMapping注解的method属性是一个RequestMethod类型的数组，表示该请求映射能够匹配多种请求方式的请求</p>
<p>若当前请求的请求地址满足请求映射的value属性，但是请求方式不满足method属性，则浏览器报错405：Request method ‘POST’ not supported</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">th:href</span>=<span class="string">&quot;@&#123;/test&#125;&quot;</span>&gt;</span>测试@RequestMapping的value属性--&gt;/test<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">th:action</span>=<span class="string">&quot;@&#123;/test&#125;&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(</span></span><br><span class="line"><span class="meta">        value = &#123;&quot;/testRequestMapping&quot;, &quot;/test&quot;&#125;,</span></span><br><span class="line"><span class="meta">        method = &#123;RequestMethod.GET, RequestMethod.POST&#125;</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">testRequestMapping</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注：</p>
<p>1、对于处理指定请求方式的控制器方法，SpringMVC中提供了@RequestMapping的派生注解</p>
<p>处理get请求的映射–&gt;@GetMapping</p>
<p>处理post请求的映射–&gt;@PostMapping</p>
<p>处理put请求的映射–&gt;@PutMapping</p>
<p>处理delete请求的映射–&gt;@DeleteMapping</p>
<p>2、常用的请求方式有get，post，put，delete</p>
<p>但是目前浏览器只支持get和post，若在form表单提交时，为method设置了其他请求方式的字符串（put或delete），则按照默认的请求方式get处理</p>
<p>若要发送put和delete请求，则需要通过spring提供的过滤器HiddenHttpMethodFilter，在RESTful部分会讲到</p>
</blockquote>
<h3 id="5、-RequestMapping注解的params属性（了解）"><a href="#5、-RequestMapping注解的params属性（了解）" class="headerlink" title="5、@RequestMapping注解的params属性（了解）"></a>5、@RequestMapping注解的params属性（了解）</h3><p>@RequestMapping注解的params属性通过请求的请求参数匹配请求映射</p>
<p>@RequestMapping注解的params属性是一个字符串类型的数组，可以通过四种表达式设置请求参数和请求映射的匹配关系</p>
<p>“param”：要求请求映射所匹配的请求必须携带param请求参数</p>
<p>“!param”：要求请求映射所匹配的请求必须不能携带param请求参数</p>
<p>“param=value”：要求请求映射所匹配的请求必须携带param请求参数且param=value</p>
<p>“param!=value”：要求请求映射所匹配的请求必须携带param请求参数但是param!=value</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">th:href</span>=<span class="string">&quot;@&#123;/test(username=&#x27;admin&#x27;,password=123456)&quot;</span>&gt;</span>测试@RequestMapping的params属性--&gt;/test<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(</span></span><br><span class="line"><span class="meta">        value = &#123;&quot;/testRequestMapping&quot;, &quot;/test&quot;&#125;</span></span><br><span class="line"><span class="meta">        ,method = &#123;RequestMethod.GET, RequestMethod.POST&#125;</span></span><br><span class="line"><span class="meta">        ,params = &#123;&quot;username&quot;,&quot;password!=123456&quot;&#125;</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">testRequestMapping</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注：</p>
<p>若当前请求满足@RequestMapping注解的value和method属性，但是不满足params属性，此时页面回报错400：Parameter conditions “username, password!=123456” not met for actual request parameters: username={admin}, password={123456}</p>
</blockquote>
<h3 id="6、-RequestMapping注解的headers属性（了解）"><a href="#6、-RequestMapping注解的headers属性（了解）" class="headerlink" title="6、@RequestMapping注解的headers属性（了解）"></a>6、@RequestMapping注解的headers属性（了解）</h3><p>@RequestMapping注解的headers属性通过请求的请求头信息匹配请求映射</p>
<p>@RequestMapping注解的headers属性是一个字符串类型的数组，可以通过四种表达式设置请求头信息和请求映射的匹配关系</p>
<p>“header”：要求请求映射所匹配的请求必须携带header请求头信息</p>
<p>“!header”：要求请求映射所匹配的请求必须不能携带header请求头信息</p>
<p>“header=value”：要求请求映射所匹配的请求必须携带header请求头信息且header=value</p>
<p>“header!=value”：要求请求映射所匹配的请求必须携带header请求头信息且header!=value</p>
<p>若当前请求满足@RequestMapping注解的value和method属性，但是不满足headers属性，此时页面显示404错误，即资源未找到</p>
<h3 id="7、SpringMVC支持ant风格的路径"><a href="#7、SpringMVC支持ant风格的路径" class="headerlink" title="7、SpringMVC支持ant风格的路径"></a>7、SpringMVC支持ant风格的路径</h3><p>？：表示任意的单个字符</p>
<p>*：表示任意的0个或多个字符</p>
<p>**：表示任意的一层或多层目录</p>
<p>注意：在使用**时，只能使用/**/xxx的方式</p>
<h3 id="8、SpringMVC支持路径中的占位符（重点）"><a href="#8、SpringMVC支持路径中的占位符（重点）" class="headerlink" title="8、SpringMVC支持路径中的占位符（重点）"></a>8、SpringMVC支持路径中的占位符（重点）</h3><p>原始方式：/deleteUser?id=1</p>
<p>rest方式：/deleteUser/1</p>
<p>SpringMVC路径中的占位符常用于RESTful风格中，当请求路径中将某些数据通过路径的方式传输到服务器中，就可以在相应的@RequestMapping注解的value属性中通过占位符{xxx}表示传输的数据，在通过@PathVariable注解，将占位符所表示的数据赋值给控制器方法的形参</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">th:href</span>=<span class="string">&quot;@&#123;/testRest/1/admin&#125;&quot;</span>&gt;</span>测试路径中的占位符--&gt;/testRest<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/testRest/&#123;id&#125;/&#123;username&#125;&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">testRest</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> String id, <span class="meta">@PathVariable(&quot;username&quot;)</span> String username)</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;id:&quot;</span>+id+<span class="string">&quot;,username:&quot;</span>+username);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//最终输出的内容为--&gt;id:1,username:admin</span></span><br></pre></td></tr></table></figure>

<h1 id="四、SpringMVC获取请求参数"><a href="#四、SpringMVC获取请求参数" class="headerlink" title="四、SpringMVC获取请求参数"></a>四、SpringMVC获取请求参数</h1><h3 id="1、通过ServletAPI获取"><a href="#1、通过ServletAPI获取" class="headerlink" title="1、通过ServletAPI获取"></a>1、通过ServletAPI获取</h3><p>将HttpServletRequest作为控制器方法的形参，此时HttpServletRequest类型的参数表示封装了当前请求的请求报文的对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/testParam&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">testParam</span><span class="params">(HttpServletRequest request)</span></span>&#123;</span><br><span class="line">    String username = request.getParameter(<span class="string">&quot;username&quot;</span>);</span><br><span class="line">    String password = request.getParameter(<span class="string">&quot;password&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;username:&quot;</span>+username+<span class="string">&quot;,password:&quot;</span>+password);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2、通过控制器方法的形参获取请求参数"><a href="#2、通过控制器方法的形参获取请求参数" class="headerlink" title="2、通过控制器方法的形参获取请求参数"></a>2、通过控制器方法的形参获取请求参数</h3><p>在控制器方法的形参位置，设置和请求参数同名的形参，当浏览器发送请求，匹配到请求映射时，在DispatcherServlet中就会将请求参数赋值给相应的形参</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">th:href</span>=<span class="string">&quot;@&#123;/testParam(username=&#x27;admin&#x27;,password=123456)&#125;&quot;</span>&gt;</span>测试获取请求参数--&gt;/testParam<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/testParam&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">testParam</span><span class="params">(String username, String password)</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;username:&quot;</span>+username+<span class="string">&quot;,password:&quot;</span>+password);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注：</p>
<p>若请求所传输的请求参数中有多个同名的请求参数，此时可以在控制器方法的形参中设置字符串数组或者字符串类型的形参接收此请求参数</p>
<p>若使用字符串数组类型的形参，此参数的数组中包含了每一个数据</p>
<p>若使用字符串类型的形参，此参数的值为每个数据中间使用逗号拼接的结果</p>
</blockquote>
<h3 id="3、-RequestParam"><a href="#3、-RequestParam" class="headerlink" title="3、@RequestParam"></a>3、@RequestParam</h3><p>@RequestParam是将请求参数和控制器方法的形参创建映射关系</p>
<p>@RequestParam注解一共有三个属性：</p>
<p>value：指定为形参赋值的请求参数的参数名</p>
<p>required：设置是否必须传输此请求参数，默认值为true</p>
<p>若设置为true时，则当前请求必须传输value所指定的请求参数，若没有传输该请求参数，且没有设置defaultValue属性，则页面报错400：Required String parameter ‘xxx’ is not present；若设置为false，则当前请求不是必须传输value所指定的请求参数，若没有传输，则注解所标识的形参的值为null</p>
<p>defaultValue：不管required属性值为true或false，当value所指定的请求参数没有传输或传输的值为””时，则使用默认值为形参赋值</p>
<h3 id="4、-RequestHeader"><a href="#4、-RequestHeader" class="headerlink" title="4、@RequestHeader"></a>4、@RequestHeader</h3><p>@RequestHeader是将请求头信息和控制器方法的形参创建映射关系</p>
<p>@RequestHeader注解一共有三个属性：value、required、defaultValue，用法同@RequestParam</p>
<h3 id="5、-CookieValue"><a href="#5、-CookieValue" class="headerlink" title="5、@CookieValue"></a>5、@CookieValue</h3><p>@CookieValue是将cookie数据和控制器方法的形参创建映射关系</p>
<p>@CookieValue注解一共有三个属性：value、required、defaultValue，用法同@RequestParam</p>
<h3 id="6、通过POJO获取请求参数"><a href="#6、通过POJO获取请求参数" class="headerlink" title="6、通过POJO获取请求参数"></a>6、通过POJO获取请求参数</h3><p>可以在控制器方法的形参位置设置一个实体类类型的形参，此时若浏览器传输的请求参数的参数名和实体类中的属性名一致，那么请求参数就会为此属性赋值</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">th:action</span>=<span class="string">&quot;@&#123;/testpojo&#125;&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line">    用户名：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    密码：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    性别：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;sex&quot;</span> <span class="attr">value</span>=<span class="string">&quot;男&quot;</span>&gt;</span>男<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;sex&quot;</span> <span class="attr">value</span>=<span class="string">&quot;女&quot;</span>&gt;</span>女<span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    年龄：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;age&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    邮箱：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;email&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/testpojo&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">testPOJO</span><span class="params">(User user)</span></span>&#123;</span><br><span class="line">    System.out.println(user);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//最终结果--&gt;User&#123;id=null, username=&#x27;张三&#x27;, password=&#x27;123&#x27;, age=23, sex=&#x27;男&#x27;, email=&#x27;123@qq.com&#x27;&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="7、解决获取请求参数的乱码问题"><a href="#7、解决获取请求参数的乱码问题" class="headerlink" title="7、解决获取请求参数的乱码问题"></a>7、解决获取请求参数的乱码问题</h3><p>解决获取请求参数的乱码问题，可以使用SpringMVC提供的编码过滤器CharacterEncodingFilter，但是必须在web.xml中进行注册</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置springMVC的编码过滤器--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>org.springframework.web.filter.CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>encoding<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>forceResponseEncoding<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>true<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>注：</p>
<p>SpringMVC中处理编码的过滤器一定要配置到其他过滤器之前，否则无效</p>
</blockquote>
<h1 id="五、域对象共享数据"><a href="#五、域对象共享数据" class="headerlink" title="五、域对象共享数据"></a>五、域对象共享数据</h1><h3 id="1、使用ServletAPI向request域对象共享数据"><a href="#1、使用ServletAPI向request域对象共享数据" class="headerlink" title="1、使用ServletAPI向request域对象共享数据"></a>1、使用ServletAPI向request域对象共享数据</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/testServletAPI&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">testServletAPI</span><span class="params">(HttpServletRequest request)</span></span>&#123;</span><br><span class="line">    request.setAttribute(<span class="string">&quot;testScope&quot;</span>, <span class="string">&quot;hello,servletAPI&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2、使用ModelAndView向request域对象共享数据"><a href="#2、使用ModelAndView向request域对象共享数据" class="headerlink" title="2、使用ModelAndView向request域对象共享数据"></a>2、使用ModelAndView向request域对象共享数据</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/testModelAndView&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ModelAndView <span class="title">testModelAndView</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * ModelAndView有Model和View的功能</span></span><br><span class="line"><span class="comment">     * Model主要用于向请求域共享数据</span></span><br><span class="line"><span class="comment">     * View主要用于设置视图，实现页面跳转</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ModelAndView mav = <span class="keyword">new</span> ModelAndView();</span><br><span class="line">    <span class="comment">//向请求域共享数据</span></span><br><span class="line">    mav.addObject(<span class="string">&quot;testScope&quot;</span>, <span class="string">&quot;hello,ModelAndView&quot;</span>);</span><br><span class="line">    <span class="comment">//设置视图，实现页面跳转</span></span><br><span class="line">    mav.setViewName(<span class="string">&quot;success&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> mav;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3、使用Model向request域对象共享数据"><a href="#3、使用Model向request域对象共享数据" class="headerlink" title="3、使用Model向request域对象共享数据"></a>3、使用Model向request域对象共享数据</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/testModel&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">testModel</span><span class="params">(Model model)</span></span>&#123;</span><br><span class="line">    model.addAttribute(<span class="string">&quot;testScope&quot;</span>, <span class="string">&quot;hello,Model&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4、使用map向request域对象共享数据"><a href="#4、使用map向request域对象共享数据" class="headerlink" title="4、使用map向request域对象共享数据"></a>4、使用map向request域对象共享数据</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/testMap&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">testMap</span><span class="params">(Map&lt;String, Object&gt; map)</span></span>&#123;</span><br><span class="line">    map.put(<span class="string">&quot;testScope&quot;</span>, <span class="string">&quot;hello,Map&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5、使用ModelMap向request域对象共享数据"><a href="#5、使用ModelMap向request域对象共享数据" class="headerlink" title="5、使用ModelMap向request域对象共享数据"></a>5、使用ModelMap向request域对象共享数据</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/testModelMap&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">testModelMap</span><span class="params">(ModelMap modelMap)</span></span>&#123;</span><br><span class="line">    modelMap.addAttribute(<span class="string">&quot;testScope&quot;</span>, <span class="string">&quot;hello,ModelMap&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6、Model、ModelMap、Map的关系"><a href="#6、Model、ModelMap、Map的关系" class="headerlink" title="6、Model、ModelMap、Map的关系"></a>6、Model、ModelMap、Map的关系</h3><p>Model、ModelMap、Map类型的参数其实本质上都是 BindingAwareModelMap 类型的</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public interface Model&#123;&#125;</span><br><span class="line">public class ModelMap extends LinkedHashMap&lt;String, Object&gt; &#123;&#125;</span><br><span class="line">public class ExtendedModelMap extends ModelMap implements Model &#123;&#125;</span><br><span class="line">public class BindingAwareModelMap extends ExtendedModelMap &#123;&#125;</span><br></pre></td></tr></table></figure>

<h3 id="7、向session域共享数据"><a href="#7、向session域共享数据" class="headerlink" title="7、向session域共享数据"></a>7、向session域共享数据</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/testSession&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">testSession</span><span class="params">(HttpSession session)</span></span>&#123;</span><br><span class="line">    session.setAttribute(<span class="string">&quot;testSessionScope&quot;</span>, <span class="string">&quot;hello,session&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="8、向application域共享数据"><a href="#8、向application域共享数据" class="headerlink" title="8、向application域共享数据"></a>8、向application域共享数据</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/testApplication&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">testApplication</span><span class="params">(HttpSession session)</span></span>&#123;</span><br><span class="line">	ServletContext application = session.getServletContext();</span><br><span class="line">    application.setAttribute(<span class="string">&quot;testApplicationScope&quot;</span>, <span class="string">&quot;hello,application&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="六、SpringMVC的视图"><a href="#六、SpringMVC的视图" class="headerlink" title="六、SpringMVC的视图"></a>六、SpringMVC的视图</h1><p>SpringMVC中的视图是View接口，视图的作用渲染数据，将模型Model中的数据展示给用户</p>
<p>SpringMVC视图的种类很多，默认有转发视图和重定向视图</p>
<p>当工程引入jstl的依赖，转发视图会自动转换为JstlView</p>
<p>若使用的视图技术为Thymeleaf，在SpringMVC的配置文件中配置了Thymeleaf的视图解析器，由此视图解析器解析之后所得到的是ThymeleafView</p>
<h3 id="1、ThymeleafView"><a href="#1、ThymeleafView" class="headerlink" title="1、ThymeleafView"></a>1、ThymeleafView</h3><p>当控制器方法中所设置的视图名称没有任何前缀时，此时的视图名称会被SpringMVC配置文件中所配置的视图解析器解析，视图名称拼接视图前缀和视图后缀所得到的最终路径，会通过转发的方式实现跳转</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/testHello&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">testHello</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://rulerofterabithia-blog.oss-cn-hangzhou.aliyuncs.com/img/20221016220439.png"></p>
<h3 id="2、转发视图"><a href="#2、转发视图" class="headerlink" title="2、转发视图"></a>2、转发视图</h3><p>SpringMVC中默认的转发视图是InternalResourceView</p>
<p>SpringMVC中创建转发视图的情况：</p>
<p>当控制器方法中所设置的视图名称以”forward:”为前缀时，创建InternalResourceView视图，此时的视图名称不会被SpringMVC配置文件中所配置的视图解析器解析，而是会将前缀”forward:”去掉，剩余部分作为最终路径通过转发的方式实现跳转</p>
<p>例如”forward:/“，”forward:/employee”</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/testForward&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">testForward</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;forward:/testHello&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://rulerofterabithia-blog.oss-cn-hangzhou.aliyuncs.com/img/20221016220513.png"></p>
<h3 id="3、重定向视图"><a href="#3、重定向视图" class="headerlink" title="3、重定向视图"></a>3、重定向视图</h3><p>SpringMVC中默认的重定向视图是RedirectView</p>
<p>当控制器方法中所设置的视图名称以”redirect:”为前缀时，创建RedirectView视图，此时的视图名称不会被SpringMVC配置文件中所配置的视图解析器解析，而是会将前缀”redirect:”去掉，剩余部分作为最终路径通过重定向的方式实现跳转</p>
<p>例如”redirect:/“，”redirect:/employee”</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/testRedirect&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">testRedirect</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;redirect:/testHello&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://rulerofterabithia-blog.oss-cn-hangzhou.aliyuncs.com/img/20221016220545.png"></p>
<blockquote>
<p>注：</p>
<p>重定向视图在解析时，会先将redirect:前缀去掉，然后会判断剩余部分是否以/开头，若是则会自动拼接上下文路径</p>
</blockquote>
<h3 id="4、视图控制器view-controller"><a href="#4、视图控制器view-controller" class="headerlink" title="4、视图控制器view-controller"></a>4、视图控制器view-controller</h3><p>当控制器方法中，仅仅用来实现页面跳转，即只需要设置视图名称时，可以将处理器方法使用view-controller标签进行表示</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">	path：设置处理的请求地址</span></span><br><span class="line"><span class="comment">	view-name：设置请求地址所对应的视图名称</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:view-controller</span> <span class="attr">path</span>=<span class="string">&quot;/testView&quot;</span> <span class="attr">view-name</span>=<span class="string">&quot;success&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">mvc:view-controller</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>注：</p>
<p>当SpringMVC中设置任何一个view-controller时，其他控制器中的请求映射将全部失效，此时需要在SpringMVC的核心配置文件中设置开启mvc注解驱动的标签：</p>
<p>&lt;mvc:annotation-driven /&gt;</p>
</blockquote>
<h1 id="七、RESTful"><a href="#七、RESTful" class="headerlink" title="七、RESTful"></a>七、RESTful</h1><h3 id="1、RESTful简介"><a href="#1、RESTful简介" class="headerlink" title="1、RESTful简介"></a>1、RESTful简介</h3><p>REST：<strong>Re</strong>presentational <strong>S</strong>tate <strong>T</strong>ransfer，表现层资源状态转移。</p>
<h5 id="a-gt-资源"><a href="#a-gt-资源" class="headerlink" title="a&gt;资源"></a>a&gt;资源</h5><p>资源是一种看待服务器的方式，即，将服务器看作是由很多离散的资源组成。每个资源是服务器上一个可命名的抽象概念。因为资源是一个抽象的概念，所以它不仅仅能代表服务器文件系统中的一个文件、数据库中的一张表等等具体的东西，可以将资源设计的要多抽象有多抽象，只要想象力允许而且客户端应用开发者能够理解。与面向对象设计类似，资源是以名词为核心来组织的，首先关注的是名词。一个资源可以由一个或多个URI来标识。URI既是资源的名称，也是资源在Web上的地址。对某个资源感兴趣的客户端应用，可以通过资源的URI与其进行交互。</p>
<h5 id="b-gt-资源的表述"><a href="#b-gt-资源的表述" class="headerlink" title="b&gt;资源的表述"></a>b&gt;资源的表述</h5><p>资源的表述是一段对于资源在某个特定时刻的状态的描述。可以在客户端-服务器端之间转移（交换）。资源的表述可以有多种格式，例如HTML/XML/JSON/纯文本/图片/视频/音频等等。资源的表述格式可以通过协商机制来确定。请求-响应方向的表述通常使用不同的格式。</p>
<h5 id="c-gt-状态转移"><a href="#c-gt-状态转移" class="headerlink" title="c&gt;状态转移"></a>c&gt;状态转移</h5><p>状态转移说的是：在客户端和服务器端之间转移（transfer）代表资源状态的表述。通过转移和操作资源的表述，来间接实现操作资源的目的。</p>
<h3 id="2、RESTful的实现"><a href="#2、RESTful的实现" class="headerlink" title="2、RESTful的实现"></a>2、RESTful的实现</h3><p>具体说，就是 HTTP 协议里面，四个表示操作方式的动词：GET、POST、PUT、DELETE。</p>
<p>它们分别对应四种基本操作：GET 用来获取资源，POST 用来新建资源，PUT 用来更新资源，DELETE 用来删除资源。</p>
<p>REST 风格提倡 URL 地址使用统一的风格设计，从前到后各个单词使用斜杠分开，不使用问号键值对方式携带请求参数，而是将要发送给服务器的数据作为 URL 地址的一部分，以保证整体风格的一致性。</p>
<table>
<thead>
<tr>
<th>操作</th>
<th>传统方式</th>
<th>REST风格</th>
</tr>
</thead>
<tbody><tr>
<td>查询操作</td>
<td>getUserById?id=1</td>
<td>user/1–&gt;get请求方式</td>
</tr>
<tr>
<td>保存操作</td>
<td>saveUser</td>
<td>user–&gt;post请求方式</td>
</tr>
<tr>
<td>删除操作</td>
<td>deleteUser?id=1</td>
<td>user/1–&gt;delete请求方式</td>
</tr>
<tr>
<td>更新操作</td>
<td>updateUser</td>
<td>user–&gt;put请求方式</td>
</tr>
</tbody></table>
<h3 id="3、HiddenHttpMethodFilter"><a href="#3、HiddenHttpMethodFilter" class="headerlink" title="3、HiddenHttpMethodFilter"></a>3、HiddenHttpMethodFilter</h3><p>由于浏览器只支持发送get和post方式的请求，那么该如何发送put和delete请求呢？</p>
<p>SpringMVC 提供了 <strong>HiddenHttpMethodFilter</strong> 帮助我们<strong>将 POST 请求转换为 DELETE 或 PUT 请求</strong></p>
<p><strong>HiddenHttpMethodFilter</strong> 处理put和delete请求的条件：</p>
<p>a&gt;当前请求的请求方式必须为post</p>
<p>b&gt;当前请求必须传输请求参数_method</p>
<p>满足以上条件，<strong>HiddenHttpMethodFilter</strong> 过滤器就会将当前请求的请求方式转换为请求参数_method的值，因此请求参数_method的值才是最终的请求方式</p>
<p>在web.xml中注册<strong>HiddenHttpMethodFilter</strong> </p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>HiddenHttpMethodFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>org.springframework.web.filter.HiddenHttpMethodFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>HiddenHttpMethodFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>注：</p>
<p>目前为止，SpringMVC中提供了两个过滤器：CharacterEncodingFilter和HiddenHttpMethodFilter</p>
<p>在web.xml中注册时，必须先注册CharacterEncodingFilter，再注册HiddenHttpMethodFilter</p>
<p>原因：</p>
<ul>
<li><p>在 CharacterEncodingFilter 中通过 request.setCharacterEncoding(encoding) 方法设置字符集的</p>
</li>
<li><p>request.setCharacterEncoding(encoding) 方法要求前面不能有任何获取请求参数的操作</p>
</li>
<li><p>而 HiddenHttpMethodFilter 恰恰有一个获取请求方式的操作：</p>
</li>
<li><p>```<br>String paramValue = request.getParameter(this.methodParam);</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 八、RESTful案例</span><br><span class="line"></span><br><span class="line">### 1、准备工作</span><br><span class="line"></span><br><span class="line">和传统 CRUD 一样，实现对员工信息的增删改查。</span><br><span class="line"></span><br><span class="line">- 搭建环境</span><br><span class="line"></span><br><span class="line">- 准备实体类</span><br><span class="line"></span><br><span class="line"> &#96;&#96;&#96;java</span><br><span class="line"> package com.atguigu.mvc.bean;</span><br><span class="line"> </span><br><span class="line"> public class Employee &#123;</span><br><span class="line"> </span><br><span class="line">    private Integer id;</span><br><span class="line">    private String lastName;</span><br><span class="line"> </span><br><span class="line">    private String email;</span><br><span class="line">    &#x2F;&#x2F;1 male, 0 female</span><br><span class="line">    private Integer gender;</span><br><span class="line">    </span><br><span class="line">    public Integer getId() &#123;</span><br><span class="line">       return id;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public void setId(Integer id) &#123;</span><br><span class="line">       this.id &#x3D; id;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public String getLastName() &#123;</span><br><span class="line">       return lastName;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public void setLastName(String lastName) &#123;</span><br><span class="line">       this.lastName &#x3D; lastName;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public String getEmail() &#123;</span><br><span class="line">       return email;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public void setEmail(String email) &#123;</span><br><span class="line">       this.email &#x3D; email;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public Integer getGender() &#123;</span><br><span class="line">       return gender;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public void setGender(Integer gender) &#123;</span><br><span class="line">       this.gender &#x3D; gender;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public Employee(Integer id, String lastName, String email, Integer gender) &#123;</span><br><span class="line">       super();</span><br><span class="line">       this.id &#x3D; id;</span><br><span class="line">       this.lastName &#x3D; lastName;</span><br><span class="line">       this.email &#x3D; email;</span><br><span class="line">       this.gender &#x3D; gender;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public Employee() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</blockquote>
<ul>
<li><p>准备dao模拟数据</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.mvc.dao;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Collection;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.atguigu.mvc.bean.Employee;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Repository;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EmployeeDao</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;Integer, Employee&gt; employees = <span class="keyword">null</span>;</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">static</span>&#123;</span><br><span class="line">      employees = <span class="keyword">new</span> HashMap&lt;Integer, Employee&gt;();</span><br><span class="line"></span><br><span class="line">      employees.put(<span class="number">1001</span>, <span class="keyword">new</span> Employee(<span class="number">1001</span>, <span class="string">&quot;E-AA&quot;</span>, <span class="string">&quot;aa@163.com&quot;</span>, <span class="number">1</span>));</span><br><span class="line">      employees.put(<span class="number">1002</span>, <span class="keyword">new</span> Employee(<span class="number">1002</span>, <span class="string">&quot;E-BB&quot;</span>, <span class="string">&quot;bb@163.com&quot;</span>, <span class="number">1</span>));</span><br><span class="line">      employees.put(<span class="number">1003</span>, <span class="keyword">new</span> Employee(<span class="number">1003</span>, <span class="string">&quot;E-CC&quot;</span>, <span class="string">&quot;cc@163.com&quot;</span>, <span class="number">0</span>));</span><br><span class="line">      employees.put(<span class="number">1004</span>, <span class="keyword">new</span> Employee(<span class="number">1004</span>, <span class="string">&quot;E-DD&quot;</span>, <span class="string">&quot;dd@163.com&quot;</span>, <span class="number">0</span>));</span><br><span class="line">      employees.put(<span class="number">1005</span>, <span class="keyword">new</span> Employee(<span class="number">1005</span>, <span class="string">&quot;E-EE&quot;</span>, <span class="string">&quot;ee@163.com&quot;</span>, <span class="number">1</span>));</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> Integer initId = <span class="number">1006</span>;</span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">(Employee employee)</span></span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(employee.getId() == <span class="keyword">null</span>)&#123;</span><br><span class="line">         employee.setId(initId++);</span><br><span class="line">      &#125;</span><br><span class="line">      employees.put(employee.getId(), employee);</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">public</span> Collection&lt;Employee&gt; <span class="title">getAll</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="keyword">return</span> employees.values();</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">public</span> Employee <span class="title">get</span><span class="params">(Integer id)</span></span>&#123;</span><br><span class="line">      <span class="keyword">return</span> employees.get(id);</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(Integer id)</span></span>&#123;</span><br><span class="line">      employees.remove(id);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="2、功能清单"><a href="#2、功能清单" class="headerlink" title="2、功能清单"></a>2、功能清单</h3><table>
<thead>
<tr>
<th>功能</th>
<th>URL 地址</th>
<th>请求方式</th>
</tr>
</thead>
<tbody><tr>
<td>访问首页√</td>
<td>/</td>
<td>GET</td>
</tr>
<tr>
<td>查询全部数据√</td>
<td>/employee</td>
<td>GET</td>
</tr>
<tr>
<td>删除√</td>
<td>/employee/2</td>
<td>DELETE</td>
</tr>
<tr>
<td>跳转到添加数据页面√</td>
<td>/toAdd</td>
<td>GET</td>
</tr>
<tr>
<td>执行保存√</td>
<td>/employee</td>
<td>POST</td>
</tr>
<tr>
<td>跳转到更新数据页面√</td>
<td>/employee/2</td>
<td>GET</td>
</tr>
<tr>
<td>执行更新√</td>
<td>/employee</td>
<td>PUT</td>
</tr>
</tbody></table>
<h3 id="3、具体功能：访问首页"><a href="#3、具体功能：访问首页" class="headerlink" title="3、具体功能：访问首页"></a>3、具体功能：访问首页</h3><h5 id="a-gt-配置view-controller"><a href="#a-gt-配置view-controller" class="headerlink" title="a&gt;配置view-controller"></a>a&gt;配置view-controller</h5><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mvc:view-controller</span> <span class="attr">path</span>=<span class="string">&quot;/&quot;</span> <span class="attr">view-name</span>=<span class="string">&quot;index&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<h5 id="b-gt-创建页面"><a href="#b-gt-创建页面" class="headerlink" title="b&gt;创建页面"></a>b&gt;创建页面</h5><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span> <span class="attr">xmlns:th</span>=<span class="string">&quot;http://www.thymeleaf.org&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span> &gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>首页<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">th:href</span>=<span class="string">&quot;@&#123;/employee&#125;&quot;</span>&gt;</span>访问员工信息<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="4、具体功能：查询所有员工数据"><a href="#4、具体功能：查询所有员工数据" class="headerlink" title="4、具体功能：查询所有员工数据"></a>4、具体功能：查询所有员工数据</h3><h5 id="a-gt-控制器方法"><a href="#a-gt-控制器方法" class="headerlink" title="a&gt;控制器方法"></a>a&gt;控制器方法</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(value = &quot;/employee&quot;, method = RequestMethod.GET)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getEmployeeList</span><span class="params">(Model model)</span></span>&#123;</span><br><span class="line">    Collection&lt;Employee&gt; employeeList = employeeDao.getAll();</span><br><span class="line">    model.addAttribute(<span class="string">&quot;employeeList&quot;</span>, employeeList);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;employee_list&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="b-gt-创建employee-list-html"><a href="#b-gt-创建employee-list-html" class="headerlink" title="b&gt;创建employee_list.html"></a>b&gt;创建employee_list.html</h5><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span> <span class="attr">xmlns:th</span>=<span class="string">&quot;http://www.thymeleaf.org&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Employee Info<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">th:src</span>=<span class="string">&quot;@&#123;/static/js/vue.js&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">table</span> <span class="attr">border</span>=<span class="string">&quot;1&quot;</span> <span class="attr">cellpadding</span>=<span class="string">&quot;0&quot;</span> <span class="attr">cellspacing</span>=<span class="string">&quot;0&quot;</span> <span class="attr">style</span>=<span class="string">&quot;text-align: center;&quot;</span> <span class="attr">id</span>=<span class="string">&quot;dataTable&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">th</span> <span class="attr">colspan</span>=<span class="string">&quot;5&quot;</span>&gt;</span>Employee Info<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">th</span>&gt;</span>id<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">th</span>&gt;</span>lastName<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">th</span>&gt;</span>email<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">th</span>&gt;</span>gender<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">th</span>&gt;</span>options(<span class="tag">&lt;<span class="name">a</span> <span class="attr">th:href</span>=<span class="string">&quot;@&#123;/toAdd&#125;&quot;</span>&gt;</span>add<span class="tag">&lt;/<span class="name">a</span>&gt;</span>)<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span> <span class="attr">th:each</span>=<span class="string">&quot;employee : $&#123;employeeList&#125;&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;employee.id&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;employee.lastName&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;employee.email&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;employee.gender&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">&quot;deleteA&quot;</span> @<span class="attr">click</span>=<span class="string">&quot;deleteEmployee&quot;</span> <span class="attr">th:href</span>=<span class="string">&quot;@&#123;&#x27;/employee/&#x27;+$&#123;employee.id&#125;&#125;&quot;</span>&gt;</span>delete<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">a</span> <span class="attr">th:href</span>=<span class="string">&quot;@&#123;&#x27;/employee/&#x27;+$&#123;employee.id&#125;&#125;&quot;</span>&gt;</span>update<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="5、具体功能：删除"><a href="#5、具体功能：删除" class="headerlink" title="5、具体功能：删除"></a>5、具体功能：删除</h3><h5 id="a-gt-创建处理delete请求方式的表单"><a href="#a-gt-创建处理delete请求方式的表单" class="headerlink" title="a&gt;创建处理delete请求方式的表单"></a>a&gt;创建处理delete请求方式的表单</h5><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 作用：通过超链接控制表单的提交，将post请求转换为delete请求 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">id</span>=<span class="string">&quot;delete_form&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- HiddenHttpMethodFilter要求：必须传输_method请求参数，并且值为最终的请求方式 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;hidden&quot;</span> <span class="attr">name</span>=<span class="string">&quot;_method&quot;</span> <span class="attr">value</span>=<span class="string">&quot;delete&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h5 id="b-gt-删除超链接绑定点击事件"><a href="#b-gt-删除超链接绑定点击事件" class="headerlink" title="b&gt;删除超链接绑定点击事件"></a>b&gt;删除超链接绑定点击事件</h5><p>引入vue.js</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">th:src</span>=<span class="string">&quot;@&#123;/static/js/vue.js&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>删除超链接</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">&quot;deleteA&quot;</span> @<span class="attr">click</span>=<span class="string">&quot;deleteEmployee&quot;</span> <span class="attr">th:href</span>=<span class="string">&quot;@&#123;&#x27;/employee/&#x27;+$&#123;employee.id&#125;&#125;&quot;</span>&gt;</span>delete<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>通过vue处理点击事件</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> vue = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">        el:<span class="string">&quot;#dataTable&quot;</span>,</span></span><br><span class="line">        methods:&#123;</span><br><span class="line"><span class="javascript">            <span class="comment">//event表示当前事件</span></span></span><br><span class="line"><span class="javascript">            deleteEmployee:<span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">                <span class="comment">//通过id获取表单标签</span></span></span><br><span class="line"><span class="javascript">                <span class="keyword">var</span> delete_form = <span class="built_in">document</span>.getElementById(<span class="string">&quot;delete_form&quot;</span>);</span></span><br><span class="line"><span class="javascript">                <span class="comment">//将触发事件的超链接的href属性为表单的action属性赋值</span></span></span><br><span class="line">                delete_form.action = event.target.href;</span><br><span class="line"><span class="javascript">                <span class="comment">//提交表单</span></span></span><br><span class="line">                delete_form.submit();</span><br><span class="line"><span class="javascript">                <span class="comment">//阻止超链接的默认跳转行为</span></span></span><br><span class="line">                event.preventDefault();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h5 id="c-gt-控制器方法"><a href="#c-gt-控制器方法" class="headerlink" title="c&gt;控制器方法"></a>c&gt;控制器方法</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(value = &quot;/employee/&#123;id&#125;&quot;, method = RequestMethod.DELETE)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">deleteEmployee</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Integer id)</span></span>&#123;</span><br><span class="line">    employeeDao.delete(id);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;redirect:/employee&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6、具体功能：跳转到添加数据页面"><a href="#6、具体功能：跳转到添加数据页面" class="headerlink" title="6、具体功能：跳转到添加数据页面"></a>6、具体功能：跳转到添加数据页面</h3><h5 id="a-gt-配置view-controller-1"><a href="#a-gt-配置view-controller-1" class="headerlink" title="a&gt;配置view-controller"></a>a&gt;配置view-controller</h5><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mvc:view-controller</span> <span class="attr">path</span>=<span class="string">&quot;/toAdd&quot;</span> <span class="attr">view-name</span>=<span class="string">&quot;employee_add&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">mvc:view-controller</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h5 id="b-gt-创建employee-add-html"><a href="#b-gt-创建employee-add-html" class="headerlink" title="b&gt;创建employee_add.html"></a>b&gt;创建employee_add.html</h5><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span> <span class="attr">xmlns:th</span>=<span class="string">&quot;http://www.thymeleaf.org&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Add Employee<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">th:action</span>=<span class="string">&quot;@&#123;/employee&#125;&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line">    lastName:<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;lastName&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    email:<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;email&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    gender:<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;gender&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1&quot;</span>&gt;</span>male</span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;gender&quot;</span> <span class="attr">value</span>=<span class="string">&quot;0&quot;</span>&gt;</span>female<span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;add&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="7、具体功能：执行保存"><a href="#7、具体功能：执行保存" class="headerlink" title="7、具体功能：执行保存"></a>7、具体功能：执行保存</h3><h5 id="a-gt-控制器方法-1"><a href="#a-gt-控制器方法-1" class="headerlink" title="a&gt;控制器方法"></a>a&gt;控制器方法</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(value = &quot;/employee&quot;, method = RequestMethod.POST)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">addEmployee</span><span class="params">(Employee employee)</span></span>&#123;</span><br><span class="line">    employeeDao.save(employee);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;redirect:/employee&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="8、具体功能：跳转到更新数据页面"><a href="#8、具体功能：跳转到更新数据页面" class="headerlink" title="8、具体功能：跳转到更新数据页面"></a>8、具体功能：跳转到更新数据页面</h3><h5 id="a-gt-修改超链接"><a href="#a-gt-修改超链接" class="headerlink" title="a&gt;修改超链接"></a>a&gt;修改超链接</h5><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">th:href</span>=<span class="string">&quot;@&#123;&#x27;/employee/&#x27;+$&#123;employee.id&#125;&#125;&quot;</span>&gt;</span>update<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h5 id="b-gt-控制器方法"><a href="#b-gt-控制器方法" class="headerlink" title="b&gt;控制器方法"></a>b&gt;控制器方法</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(value = &quot;/employee/&#123;id&#125;&quot;, method = RequestMethod.GET)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getEmployeeById</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Integer id, Model model)</span></span>&#123;</span><br><span class="line">    Employee employee = employeeDao.get(id);</span><br><span class="line">    model.addAttribute(<span class="string">&quot;employee&quot;</span>, employee);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;employee_update&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="c-gt-创建employee-update-html"><a href="#c-gt-创建employee-update-html" class="headerlink" title="c&gt;创建employee_update.html"></a>c&gt;创建employee_update.html</h5><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span> <span class="attr">xmlns:th</span>=<span class="string">&quot;http://www.thymeleaf.org&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Update Employee<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">th:action</span>=<span class="string">&quot;@&#123;/employee&#125;&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;hidden&quot;</span> <span class="attr">name</span>=<span class="string">&quot;_method&quot;</span> <span class="attr">value</span>=<span class="string">&quot;put&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;hidden&quot;</span> <span class="attr">name</span>=<span class="string">&quot;id&quot;</span> <span class="attr">th:value</span>=<span class="string">&quot;$&#123;employee.id&#125;&quot;</span>&gt;</span></span><br><span class="line">    lastName:<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;lastName&quot;</span> <span class="attr">th:value</span>=<span class="string">&quot;$&#123;employee.lastName&#125;&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    email:<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;email&quot;</span> <span class="attr">th:value</span>=<span class="string">&quot;$&#123;employee.email&#125;&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">        th:field=&quot;$&#123;employee.gender&#125;&quot;可用于单选框或复选框的回显</span></span><br><span class="line"><span class="comment">        若单选框的value和employee.gender的值一致，则添加checked=&quot;checked&quot;属性</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    gender:<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;gender&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1&quot;</span> <span class="attr">th:field</span>=<span class="string">&quot;$&#123;employee.gender&#125;&quot;</span>&gt;</span>male</span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;gender&quot;</span> <span class="attr">value</span>=<span class="string">&quot;0&quot;</span> <span class="attr">th:field</span>=<span class="string">&quot;$&#123;employee.gender&#125;&quot;</span>&gt;</span>female<span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;update&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="9、具体功能：执行更新"><a href="#9、具体功能：执行更新" class="headerlink" title="9、具体功能：执行更新"></a>9、具体功能：执行更新</h3><h5 id="a-gt-控制器方法-2"><a href="#a-gt-控制器方法-2" class="headerlink" title="a&gt;控制器方法"></a>a&gt;控制器方法</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(value = &quot;/employee&quot;, method = RequestMethod.PUT)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">updateEmployee</span><span class="params">(Employee employee)</span></span>&#123;</span><br><span class="line">    employeeDao.save(employee);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;redirect:/employee&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="八、HttpMessageConverter"><a href="#八、HttpMessageConverter" class="headerlink" title="八、HttpMessageConverter"></a>八、HttpMessageConverter</h1><p>HttpMessageConverter，报文信息转换器，将请求报文转换为Java对象，或将Java对象转换为响应报文</p>
<p>HttpMessageConverter提供了两个注解和两个类型：@RequestBody，@ResponseBody，RequestEntity，</p>
<p>ResponseEntity</p>
<h3 id="1、-RequestBody"><a href="#1、-RequestBody" class="headerlink" title="1、@RequestBody"></a>1、@RequestBody</h3><p>@RequestBody可以获取请求体，需要在控制器方法设置一个形参，使用@RequestBody进行标识，当前请求的请求体就会为当前注解所标识的形参赋值</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">th:action</span>=<span class="string">&quot;@&#123;/testRequestBody&#125;&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line">    用户名：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    密码：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/testRequestBody&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">testRequestBody</span><span class="params">(<span class="meta">@RequestBody</span> String requestBody)</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;requestBody:&quot;</span>+requestBody);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<p>requestBody:username=admin&amp;password=123456</p>
<h3 id="2、RequestEntity"><a href="#2、RequestEntity" class="headerlink" title="2、RequestEntity"></a>2、RequestEntity</h3><p>RequestEntity封装请求报文的一种类型，需要在控制器方法的形参中设置该类型的形参，当前请求的请求报文就会赋值给该形参，可以通过getHeaders()获取请求头信息，通过getBody()获取请求体信息</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/testRequestEntity&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">testRequestEntity</span><span class="params">(RequestEntity&lt;String&gt; requestEntity)</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;requestHeader:&quot;</span>+requestEntity.getHeaders());</span><br><span class="line">    System.out.println(<span class="string">&quot;requestBody:&quot;</span>+requestEntity.getBody());</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：<br>requestHeader:[host:”localhost:8080”, connection:”keep-alive”, content-length:”27”, cache-control:”max-age=0”, sec-ch-ua:”” Not A;Brand”;v=”99”, “Chromium”;v=”90”, “Google Chrome”;v=”90””, sec-ch-ua-mobile:”?0”, upgrade-insecure-requests:”1”, origin:”<a href="http://localhost:8080&quot;">http://localhost:8080&quot;</a>, user-agent:”Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/90.0.4430.93 Safari/537.36”]<br>requestBody:username=admin&amp;password=123</p>
<h3 id="3、-ResponseBody"><a href="#3、-ResponseBody" class="headerlink" title="3、@ResponseBody"></a>3、@ResponseBody</h3><p>@ResponseBody用于标识一个控制器方法，可以将该方法的返回值直接作为响应报文的响应体响应到浏览器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/testResponseBody&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">testResponseBody</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果：浏览器页面显示success</p>
<h3 id="4、SpringMVC处理json"><a href="#4、SpringMVC处理json" class="headerlink" title="4、SpringMVC处理json"></a>4、SpringMVC处理json</h3><p>@ResponseBody处理json的步骤：</p>
<p>a&gt;导入jackson的依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-databind<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.12.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>b&gt;在SpringMVC的核心配置文件中开启mvc的注解驱动，此时在HandlerAdaptor中会自动装配一个消息转换器：MappingJackson2HttpMessageConverter，可以将响应到浏览器的Java对象转换为Json格式的字符串</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;mvc:annotation-driven &#x2F;&gt;</span><br></pre></td></tr></table></figure>

<p>c&gt;在处理器方法上使用@ResponseBody注解进行标识</p>
<p>d&gt;将Java对象直接作为控制器方法的返回值返回，就会自动转换为Json格式的字符串</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/testResponseUser&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> User <span class="title">testResponseUser</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> User(<span class="number">1001</span>,<span class="string">&quot;admin&quot;</span>,<span class="string">&quot;123456&quot;</span>,<span class="number">23</span>,<span class="string">&quot;男&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>浏览器的页面中展示的结果：</p>
<p>{“id”:1001,”username”:”admin”,”password”:”123456”,”age”:23,”sex”:”男”}</p>
<h3 id="5、SpringMVC处理ajax"><a href="#5、SpringMVC处理ajax" class="headerlink" title="5、SpringMVC处理ajax"></a>5、SpringMVC处理ajax</h3><p>a&gt;请求超链接：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">a</span> <span class="attr">th:href</span>=<span class="string">&quot;@&#123;/testAjax&#125;&quot;</span> @<span class="attr">click</span>=<span class="string">&quot;testAjax&quot;</span>&gt;</span>testAjax<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>b&gt;通过vue和axios处理点击事件：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">th:src</span>=<span class="string">&quot;@&#123;/static/js/vue.js&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">th:src</span>=<span class="string">&quot;@&#123;/static/js/axios.min.js&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> vue = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">        el:<span class="string">&quot;#app&quot;</span>,</span></span><br><span class="line">        methods:&#123;</span><br><span class="line"><span class="javascript">            testAjax:<span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span></span><br><span class="line">                axios(&#123;</span><br><span class="line"><span class="javascript">                    method:<span class="string">&quot;post&quot;</span>,</span></span><br><span class="line">                    url:event.target.href,</span><br><span class="line">                    params:&#123;</span><br><span class="line"><span class="javascript">                        username:<span class="string">&quot;admin&quot;</span>,</span></span><br><span class="line"><span class="javascript">                        password:<span class="string">&quot;123456&quot;</span></span></span><br><span class="line">                    &#125;</span><br><span class="line"><span class="javascript">                &#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params">response</span>) </span>&#123;</span></span><br><span class="line">                    alert(response.data);</span><br><span class="line">                &#125;);</span><br><span class="line">                event.preventDefault();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>c&gt;控制器方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/testAjax&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">testAjax</span><span class="params">(String username, String password)</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;username:&quot;</span>+username+<span class="string">&quot;,password:&quot;</span>+password);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;hello,ajax&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6、-RestController注解"><a href="#6、-RestController注解" class="headerlink" title="6、@RestController注解"></a>6、@RestController注解</h3><p>@RestController注解是springMVC提供的一个复合注解，标识在控制器的类上，就相当于为类添加了@Controller注解，并且为其中的每个方法添加了@ResponseBody注解</p>
<h3 id="7、ResponseEntity"><a href="#7、ResponseEntity" class="headerlink" title="7、ResponseEntity"></a>7、ResponseEntity</h3><p>ResponseEntity用于控制器方法的返回值类型，该控制器方法的返回值就是响应到浏览器的响应报文</p>
<h1 id="九、文件上传和下载"><a href="#九、文件上传和下载" class="headerlink" title="九、文件上传和下载"></a>九、文件上传和下载</h1><h3 id="1、文件下载"><a href="#1、文件下载" class="headerlink" title="1、文件下载"></a>1、文件下载</h3><p>使用ResponseEntity实现下载文件的功能</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/testDown&quot;)</span></span><br><span class="line"><span class="keyword">public</span> ResponseEntity&lt;<span class="keyword">byte</span>[]&gt; testResponseEntity(HttpSession session) <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">//获取ServletContext对象</span></span><br><span class="line">    ServletContext servletContext = session.getServletContext();</span><br><span class="line">    <span class="comment">//获取服务器中文件的真实路径</span></span><br><span class="line">    String realPath = servletContext.getRealPath(<span class="string">&quot;/static/img/1.jpg&quot;</span>);</span><br><span class="line">    <span class="comment">//创建输入流</span></span><br><span class="line">    InputStream is = <span class="keyword">new</span> FileInputStream(realPath);</span><br><span class="line">    <span class="comment">//创建字节数组</span></span><br><span class="line">    <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[is.available()];</span><br><span class="line">    <span class="comment">//将流读到字节数组中</span></span><br><span class="line">    is.read(bytes);</span><br><span class="line">    <span class="comment">//创建HttpHeaders对象设置响应头信息</span></span><br><span class="line">    MultiValueMap&lt;String, String&gt; headers = <span class="keyword">new</span> HttpHeaders();</span><br><span class="line">    <span class="comment">//设置要下载方式以及下载文件的名字</span></span><br><span class="line">    headers.add(<span class="string">&quot;Content-Disposition&quot;</span>, <span class="string">&quot;attachment;filename=1.jpg&quot;</span>);</span><br><span class="line">    <span class="comment">//设置响应状态码</span></span><br><span class="line">    HttpStatus statusCode = HttpStatus.OK;</span><br><span class="line">    <span class="comment">//创建ResponseEntity对象</span></span><br><span class="line">    ResponseEntity&lt;<span class="keyword">byte</span>[]&gt; responseEntity = <span class="keyword">new</span> ResponseEntity&lt;&gt;(bytes, headers, statusCode);</span><br><span class="line">    <span class="comment">//关闭输入流</span></span><br><span class="line">    is.close();</span><br><span class="line">    <span class="keyword">return</span> responseEntity;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2、文件上传"><a href="#2、文件上传" class="headerlink" title="2、文件上传"></a>2、文件上传</h3><p>文件上传要求form表单的请求方式必须为post，并且添加属性enctype=”multipart/form-data”</p>
<p>SpringMVC中将上传的文件封装到MultipartFile对象中，通过此对象可以获取文件相关信息</p>
<p>上传步骤：</p>
<p>a&gt;添加依赖：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/commons-fileupload/commons-fileupload --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-fileupload<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-fileupload<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>b&gt;在SpringMVC的配置文件中添加配置：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--必须通过文件解析器的解析才能将文件转换为MultipartFile对象--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;multipartResolver&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.multipart.commons.CommonsMultipartResolver&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>c&gt;控制器方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/testUp&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">testUp</span><span class="params">(MultipartFile photo, HttpSession session)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">//获取上传的文件的文件名</span></span><br><span class="line">    String fileName = photo.getOriginalFilename();</span><br><span class="line">    <span class="comment">//处理文件重名问题</span></span><br><span class="line">    String hzName = fileName.substring(fileName.lastIndexOf(<span class="string">&quot;.&quot;</span>));</span><br><span class="line">    fileName = UUID.randomUUID().toString() + hzName;</span><br><span class="line">    <span class="comment">//获取服务器中photo目录的路径</span></span><br><span class="line">    ServletContext servletContext = session.getServletContext();</span><br><span class="line">    String photoPath = servletContext.getRealPath(<span class="string">&quot;photo&quot;</span>);</span><br><span class="line">    File file = <span class="keyword">new</span> File(photoPath);</span><br><span class="line">    <span class="keyword">if</span>(!file.exists())&#123;</span><br><span class="line">        file.mkdir();</span><br><span class="line">    &#125;</span><br><span class="line">    String finalPath = photoPath + File.separator + fileName;</span><br><span class="line">    <span class="comment">//实现上传功能</span></span><br><span class="line">    photo.transferTo(<span class="keyword">new</span> File(finalPath));</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="十、拦截器"><a href="#十、拦截器" class="headerlink" title="十、拦截器"></a>十、拦截器</h1><h3 id="1、拦截器的配置"><a href="#1、拦截器的配置" class="headerlink" title="1、拦截器的配置"></a>1、拦截器的配置</h3><p>SpringMVC中的拦截器用于拦截控制器方法的执行</p>
<p>SpringMVC中的拦截器需要实现HandlerInterceptor</p>
<p>SpringMVC的拦截器必须在SpringMVC的配置文件中进行配置：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.atguigu.interceptor.FirstInterceptor&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">&quot;firstInterceptor&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">ref</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 以上两种配置方式都是对DispatcherServlet所处理的所有的请求进行拦截 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:mapping</span> <span class="attr">path</span>=<span class="string">&quot;/**&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:exclude-mapping</span> <span class="attr">path</span>=<span class="string">&quot;/testRequestEntity&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">&quot;firstInterceptor&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">ref</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- </span></span><br><span class="line"><span class="comment">	以上配置方式可以通过ref或bean标签设置拦截器，通过mvc:mapping设置需要拦截的请求，通过mvc:exclude-mapping设置需要排除的请求，即不需要拦截的请求</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="2、拦截器的三个抽象方法"><a href="#2、拦截器的三个抽象方法" class="headerlink" title="2、拦截器的三个抽象方法"></a>2、拦截器的三个抽象方法</h3><p>SpringMVC中的拦截器有三个抽象方法：</p>
<p>preHandle：控制器方法执行之前执行preHandle()，其boolean类型的返回值表示是否拦截或放行，返回true为放行，即调用控制器方法；返回false表示拦截，即不调用控制器方法</p>
<p>postHandle：控制器方法执行之后执行postHandle()</p>
<p>afterComplation：处理完视图和模型数据，渲染视图完毕之后执行afterComplation()</p>
<h3 id="3、多个拦截器的执行顺序"><a href="#3、多个拦截器的执行顺序" class="headerlink" title="3、多个拦截器的执行顺序"></a>3、多个拦截器的执行顺序</h3><p>a&gt;若每个拦截器的preHandle()都返回true</p>
<p>此时多个拦截器的执行顺序和拦截器在SpringMVC的配置文件的配置顺序有关：</p>
<p>preHandle()会按照配置的顺序执行，而postHandle()和afterComplation()会按照配置的反序执行</p>
<p>b&gt;若某个拦截器的preHandle()返回了false</p>
<p>preHandle()返回false和它之前的拦截器的preHandle()都会执行，postHandle()都不执行，返回false的拦截器之前的拦截器的afterComplation()会执行</p>
<h1 id="十一、异常处理器"><a href="#十一、异常处理器" class="headerlink" title="十一、异常处理器"></a>十一、异常处理器</h1><h3 id="1、基于配置的异常处理"><a href="#1、基于配置的异常处理" class="headerlink" title="1、基于配置的异常处理"></a>1、基于配置的异常处理</h3><p>SpringMVC提供了一个处理控制器方法执行过程中所出现的异常的接口：HandlerExceptionResolver</p>
<p>HandlerExceptionResolver接口的实现类有：DefaultHandlerExceptionResolver和SimpleMappingExceptionResolver</p>
<p>SpringMVC提供了自定义的异常处理器SimpleMappingExceptionResolver，使用方式：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.servlet.handler.SimpleMappingExceptionResolver&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;exceptionMappings&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">props</span>&gt;</span></span><br><span class="line">        	<span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">        		properties的键表示处理器方法执行过程中出现的异常</span></span><br><span class="line"><span class="comment">        		properties的值表示若出现指定异常时，设置一个新的视图名称，跳转到指定页面</span></span><br><span class="line"><span class="comment">        	--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;java.lang.ArithmeticException&quot;</span>&gt;</span>error<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">props</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">    	exceptionAttribute属性设置一个属性名，将出现的异常信息在请求域中进行共享</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;exceptionAttribute&quot;</span> <span class="attr">value</span>=<span class="string">&quot;ex&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="2、基于注解的异常处理"><a href="#2、基于注解的异常处理" class="headerlink" title="2、基于注解的异常处理"></a>2、基于注解的异常处理</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//@ControllerAdvice将当前类标识为异常处理的组件</span></span><br><span class="line"><span class="meta">@ControllerAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExceptionController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//@ExceptionHandler用于设置所标识方法处理的异常</span></span><br><span class="line">    <span class="meta">@ExceptionHandler(ArithmeticException.class)</span></span><br><span class="line">    <span class="comment">//ex表示当前请求处理中出现的异常对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">handleArithmeticException</span><span class="params">(Exception ex, Model model)</span></span>&#123;</span><br><span class="line">        model.addAttribute(<span class="string">&quot;ex&quot;</span>, ex);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;error&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="十二、注解配置SpringMVC"><a href="#十二、注解配置SpringMVC" class="headerlink" title="十二、注解配置SpringMVC"></a>十二、注解配置SpringMVC</h1><p>使用配置类和注解代替web.xml和SpringMVC配置文件的功能</p>
<h3 id="1、创建初始化类，代替web-xml"><a href="#1、创建初始化类，代替web-xml" class="headerlink" title="1、创建初始化类，代替web.xml"></a>1、创建初始化类，代替web.xml</h3><p>在Servlet3.0环境中，容器会在类路径中查找实现javax.servlet.ServletContainerInitializer接口的类，如果找到的话就用它来配置Servlet容器。<br>Spring提供了这个接口的实现，名为SpringServletContainerInitializer，这个类反过来又会查找实现WebApplicationInitializer的类并将配置的任务交给它们来完成。Spring3.2引入了一个便利的WebApplicationInitializer基础实现，名为AbstractAnnotationConfigDispatcherServletInitializer，当我们的类扩展了AbstractAnnotationConfigDispatcherServletInitializer并将其部署到Servlet3.0容器的时候，容器会自动发现它，并用它来配置Servlet上下文。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebInit</span> <span class="keyword">extends</span> <span class="title">AbstractAnnotationConfigDispatcherServletInitializer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 指定spring的配置类</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt;[] getRootConfigClasses() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Class[]&#123;SpringConfig.class&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 指定SpringMVC的配置类</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt;[] getServletConfigClasses() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Class[]&#123;WebConfig.class&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 指定DispatcherServlet的映射规则，即url-pattern</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> String[] getServletMappings() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> String[]&#123;<span class="string">&quot;/&quot;</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 添加过滤器</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Filter[] getServletFilters() &#123;</span><br><span class="line">        CharacterEncodingFilter encodingFilter = <span class="keyword">new</span> CharacterEncodingFilter();</span><br><span class="line">        encodingFilter.setEncoding(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">        encodingFilter.setForceRequestEncoding(<span class="keyword">true</span>);</span><br><span class="line">        HiddenHttpMethodFilter hiddenHttpMethodFilter = <span class="keyword">new</span> HiddenHttpMethodFilter();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Filter[]&#123;encodingFilter, hiddenHttpMethodFilter&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2、创建SpringConfig配置类，代替spring的配置文件"><a href="#2、创建SpringConfig配置类，代替spring的配置文件" class="headerlink" title="2、创建SpringConfig配置类，代替spring的配置文件"></a>2、创建SpringConfig配置类，代替spring的配置文件</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringConfig</span> </span>&#123;</span><br><span class="line">	<span class="comment">//ssm整合之后，spring的配置信息写在此类中</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3、创建WebConfig配置类，代替SpringMVC的配置文件"><a href="#3、创建WebConfig配置类，代替SpringMVC的配置文件" class="headerlink" title="3、创建WebConfig配置类，代替SpringMVC的配置文件"></a>3、创建WebConfig配置类，代替SpringMVC的配置文件</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="comment">//扫描组件</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;com.atguigu.mvc.controller&quot;)</span></span><br><span class="line"><span class="comment">//开启MVC注解驱动</span></span><br><span class="line"><span class="meta">@EnableWebMvc</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebConfig</span> <span class="keyword">implements</span> <span class="title">WebMvcConfigurer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用默认的servlet处理静态资源</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configureDefaultServletHandling</span><span class="params">(DefaultServletHandlerConfigurer configurer)</span> </span>&#123;</span><br><span class="line">        configurer.enable();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//配置文件上传解析器</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CommonsMultipartResolver <span class="title">multipartResolver</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CommonsMultipartResolver();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//配置拦截器</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> </span>&#123;</span><br><span class="line">        FirstInterceptor firstInterceptor = <span class="keyword">new</span> FirstInterceptor();</span><br><span class="line">        registry.addInterceptor(firstInterceptor).addPathPatterns(<span class="string">&quot;/**&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//配置视图控制</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*@Override</span></span><br><span class="line"><span class="comment">    public void addViewControllers(ViewControllerRegistry registry) &#123;</span></span><br><span class="line"><span class="comment">        registry.addViewController(&quot;/&quot;).setViewName(&quot;index&quot;);</span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//配置异常映射</span></span><br><span class="line">    <span class="comment">/*@Override</span></span><br><span class="line"><span class="comment">    public void configureHandlerExceptionResolvers(List&lt;HandlerExceptionResolver&gt; resolvers) &#123;</span></span><br><span class="line"><span class="comment">        SimpleMappingExceptionResolver exceptionResolver = new SimpleMappingExceptionResolver();</span></span><br><span class="line"><span class="comment">        Properties prop = new Properties();</span></span><br><span class="line"><span class="comment">        prop.setProperty(&quot;java.lang.ArithmeticException&quot;, &quot;error&quot;);</span></span><br><span class="line"><span class="comment">        //设置异常映射</span></span><br><span class="line"><span class="comment">        exceptionResolver.setExceptionMappings(prop);</span></span><br><span class="line"><span class="comment">        //设置共享异常信息的键</span></span><br><span class="line"><span class="comment">        exceptionResolver.setExceptionAttribute(&quot;ex&quot;);</span></span><br><span class="line"><span class="comment">        resolvers.add(exceptionResolver);</span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//配置生成模板解析器</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ITemplateResolver <span class="title">templateResolver</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        WebApplicationContext webApplicationContext = ContextLoader.getCurrentWebApplicationContext();</span><br><span class="line">        <span class="comment">// ServletContextTemplateResolver需要一个ServletContext作为构造参数，可通过WebApplicationContext 的方法获得</span></span><br><span class="line">        ServletContextTemplateResolver templateResolver = <span class="keyword">new</span> ServletContextTemplateResolver(</span><br><span class="line">                webApplicationContext.getServletContext());</span><br><span class="line">        templateResolver.setPrefix(<span class="string">&quot;/WEB-INF/templates/&quot;</span>);</span><br><span class="line">        templateResolver.setSuffix(<span class="string">&quot;.html&quot;</span>);</span><br><span class="line">        templateResolver.setCharacterEncoding(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">        templateResolver.setTemplateMode(TemplateMode.HTML);</span><br><span class="line">        <span class="keyword">return</span> templateResolver;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//生成模板引擎并为模板引擎注入模板解析器</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> SpringTemplateEngine <span class="title">templateEngine</span><span class="params">(ITemplateResolver templateResolver)</span> </span>&#123;</span><br><span class="line">        SpringTemplateEngine templateEngine = <span class="keyword">new</span> SpringTemplateEngine();</span><br><span class="line">        templateEngine.setTemplateResolver(templateResolver);</span><br><span class="line">        <span class="keyword">return</span> templateEngine;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//生成视图解析器并未解析器注入模板引擎</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ViewResolver <span class="title">viewResolver</span><span class="params">(SpringTemplateEngine templateEngine)</span> </span>&#123;</span><br><span class="line">        ThymeleafViewResolver viewResolver = <span class="keyword">new</span> ThymeleafViewResolver();</span><br><span class="line">        viewResolver.setCharacterEncoding(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">        viewResolver.setTemplateEngine(templateEngine);</span><br><span class="line">        <span class="keyword">return</span> viewResolver;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4、测试功能"><a href="#4、测试功能" class="headerlink" title="4、测试功能"></a>4、测试功能</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">index</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;index&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="十三、SpringMVC执行流程"><a href="#十三、SpringMVC执行流程" class="headerlink" title="十三、SpringMVC执行流程"></a>十三、SpringMVC执行流程</h1><h3 id="1、SpringMVC常用组件"><a href="#1、SpringMVC常用组件" class="headerlink" title="1、SpringMVC常用组件"></a>1、SpringMVC常用组件</h3><ul>
<li>DispatcherServlet：<strong>前端控制器</strong>，不需要工程师开发，由框架提供</li>
</ul>
<p>作用：统一处理请求和响应，整个流程控制的中心，由它调用其它组件处理用户的请求</p>
<ul>
<li>HandlerMapping：<strong>处理器映射器</strong>，不需要工程师开发，由框架提供</li>
</ul>
<p>作用：根据请求的url、method等信息查找Handler，即控制器方法</p>
<ul>
<li>Handler：<strong>处理器</strong>，需要工程师开发</li>
</ul>
<p>作用：在DispatcherServlet的控制下Handler对具体的用户请求进行处理</p>
<ul>
<li>HandlerAdapter：<strong>处理器适配器</strong>，不需要工程师开发，由框架提供</li>
</ul>
<p>作用：通过HandlerAdapter对处理器（控制器方法）进行执行</p>
<ul>
<li>ViewResolver：<strong>视图解析器</strong>，不需要工程师开发，由框架提供</li>
</ul>
<p>作用：进行视图解析，得到相应的视图，例如：ThymeleafView、InternalResourceView、RedirectView</p>
<ul>
<li>View：<strong>视图</strong></li>
</ul>
<p>作用：将模型数据通过页面展示给用户</p>
<h3 id="2、DispatcherServlet初始化过程"><a href="#2、DispatcherServlet初始化过程" class="headerlink" title="2、DispatcherServlet初始化过程"></a>2、DispatcherServlet初始化过程</h3><p>DispatcherServlet 本质上是一个 Servlet，所以天然的遵循 Servlet 的生命周期。所以宏观上是 Servlet 生命周期来进行调度。</p>
<p><img src="https://rulerofterabithia-blog.oss-cn-hangzhou.aliyuncs.com/img/20221016220656.png"></p>
<h5 id="a-gt-初始化WebApplicationContext"><a href="#a-gt-初始化WebApplicationContext" class="headerlink" title="a&gt;初始化WebApplicationContext"></a>a&gt;初始化WebApplicationContext</h5><p>所在类：org.springframework.web.servlet.FrameworkServlet</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> WebApplicationContext <span class="title">initWebApplicationContext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    WebApplicationContext rootContext =</span><br><span class="line">        WebApplicationContextUtils.getWebApplicationContext(getServletContext());</span><br><span class="line">    WebApplicationContext wac = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.webApplicationContext != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// A context instance was injected at construction time -&gt; use it</span></span><br><span class="line">        wac = <span class="keyword">this</span>.webApplicationContext;</span><br><span class="line">        <span class="keyword">if</span> (wac <span class="keyword">instanceof</span> ConfigurableWebApplicationContext) &#123;</span><br><span class="line">            ConfigurableWebApplicationContext cwac = (ConfigurableWebApplicationContext) wac;</span><br><span class="line">            <span class="keyword">if</span> (!cwac.isActive()) &#123;</span><br><span class="line">                <span class="comment">// The context has not yet been refreshed -&gt; provide services such as</span></span><br><span class="line">                <span class="comment">// setting the parent context, setting the application context id, etc</span></span><br><span class="line">                <span class="keyword">if</span> (cwac.getParent() == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// The context instance was injected without an explicit parent -&gt; set</span></span><br><span class="line">                    <span class="comment">// the root application context (if any; may be null) as the parent</span></span><br><span class="line">                    cwac.setParent(rootContext);</span><br><span class="line">                &#125;</span><br><span class="line">                configureAndRefreshWebApplicationContext(cwac);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (wac == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// No context instance was injected at construction time -&gt; see if one</span></span><br><span class="line">        <span class="comment">// has been registered in the servlet context. If one exists, it is assumed</span></span><br><span class="line">        <span class="comment">// that the parent context (if any) has already been set and that the</span></span><br><span class="line">        <span class="comment">// user has performed any initialization such as setting the context id</span></span><br><span class="line">        wac = findWebApplicationContext();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (wac == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// No context instance is defined for this servlet -&gt; create a local one</span></span><br><span class="line">        <span class="comment">// 创建WebApplicationContext</span></span><br><span class="line">        wac = createWebApplicationContext(rootContext);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.refreshEventReceived) &#123;</span><br><span class="line">        <span class="comment">// Either the context is not a ConfigurableApplicationContext with refresh</span></span><br><span class="line">        <span class="comment">// support or the context injected at construction time had already been</span></span><br><span class="line">        <span class="comment">// refreshed -&gt; trigger initial onRefresh manually here.</span></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>.onRefreshMonitor) &#123;</span><br><span class="line">            <span class="comment">// 刷新WebApplicationContext</span></span><br><span class="line">            onRefresh(wac);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.publishContext) &#123;</span><br><span class="line">        <span class="comment">// Publish the context as a servlet context attribute.</span></span><br><span class="line">        <span class="comment">// 将IOC容器在应用域共享</span></span><br><span class="line">        String attrName = getServletContextAttributeName();</span><br><span class="line">        getServletContext().setAttribute(attrName, wac);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> wac;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="b-gt-创建WebApplicationContext"><a href="#b-gt-创建WebApplicationContext" class="headerlink" title="b&gt;创建WebApplicationContext"></a>b&gt;创建WebApplicationContext</h5><p>所在类：org.springframework.web.servlet.FrameworkServlet</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> WebApplicationContext <span class="title">createWebApplicationContext</span><span class="params">(<span class="meta">@Nullable</span> ApplicationContext parent)</span> </span>&#123;</span><br><span class="line">    Class&lt;?&gt; contextClass = getContextClass();</span><br><span class="line">    <span class="keyword">if</span> (!ConfigurableWebApplicationContext.class.isAssignableFrom(contextClass)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ApplicationContextException(</span><br><span class="line">            <span class="string">&quot;Fatal initialization error in servlet with name &#x27;&quot;</span> + getServletName() +</span><br><span class="line">            <span class="string">&quot;&#x27;: custom WebApplicationContext class [&quot;</span> + contextClass.getName() +</span><br><span class="line">            <span class="string">&quot;] is not of type ConfigurableWebApplicationContext&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 通过反射创建 IOC 容器对象</span></span><br><span class="line">    ConfigurableWebApplicationContext wac =</span><br><span class="line">        (ConfigurableWebApplicationContext) BeanUtils.instantiateClass(contextClass);</span><br><span class="line"></span><br><span class="line">    wac.setEnvironment(getEnvironment());</span><br><span class="line">    <span class="comment">// 设置父容器</span></span><br><span class="line">    wac.setParent(parent);</span><br><span class="line">    String configLocation = getContextConfigLocation();</span><br><span class="line">    <span class="keyword">if</span> (configLocation != <span class="keyword">null</span>) &#123;</span><br><span class="line">        wac.setConfigLocation(configLocation);</span><br><span class="line">    &#125;</span><br><span class="line">    configureAndRefreshWebApplicationContext(wac);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> wac;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="c-gt-DispatcherServlet初始化策略"><a href="#c-gt-DispatcherServlet初始化策略" class="headerlink" title="c&gt;DispatcherServlet初始化策略"></a>c&gt;DispatcherServlet初始化策略</h5><p>FrameworkServlet创建WebApplicationContext后，刷新容器，调用onRefresh(wac)，此方法在DispatcherServlet中进行了重写，调用了initStrategies(context)方法，初始化策略，即初始化DispatcherServlet的各个组件</p>
<p>所在类：org.springframework.web.servlet.DispatcherServlet</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initStrategies</span><span class="params">(ApplicationContext context)</span> </span>&#123;</span><br><span class="line">   initMultipartResolver(context);</span><br><span class="line">   initLocaleResolver(context);</span><br><span class="line">   initThemeResolver(context);</span><br><span class="line">   initHandlerMappings(context);</span><br><span class="line">   initHandlerAdapters(context);</span><br><span class="line">   initHandlerExceptionResolvers(context);</span><br><span class="line">   initRequestToViewNameTranslator(context);</span><br><span class="line">   initViewResolvers(context);</span><br><span class="line">   initFlashMapManager(context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3、DispatcherServlet调用组件处理请求"><a href="#3、DispatcherServlet调用组件处理请求" class="headerlink" title="3、DispatcherServlet调用组件处理请求"></a>3、DispatcherServlet调用组件处理请求</h3><h5 id="a-gt-processRequest"><a href="#a-gt-processRequest" class="headerlink" title="a&gt;processRequest()"></a>a&gt;processRequest()</h5><p>FrameworkServlet重写HttpServlet中的service()和doXxx()，这些方法中调用了processRequest(request, response)</p>
<p>所在类：org.springframework.web.servlet.FrameworkServlet</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">processRequest</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> startTime = System.currentTimeMillis();</span><br><span class="line">    Throwable failureCause = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    LocaleContext previousLocaleContext = LocaleContextHolder.getLocaleContext();</span><br><span class="line">    LocaleContext localeContext = buildLocaleContext(request);</span><br><span class="line"></span><br><span class="line">    RequestAttributes previousAttributes = RequestContextHolder.getRequestAttributes();</span><br><span class="line">    ServletRequestAttributes requestAttributes = buildRequestAttributes(request, response, previousAttributes);</span><br><span class="line"></span><br><span class="line">    WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request);</span><br><span class="line">    asyncManager.registerCallableInterceptor(FrameworkServlet.class.getName(), <span class="keyword">new</span> RequestBindingInterceptor());</span><br><span class="line"></span><br><span class="line">    initContextHolders(request, localeContext, requestAttributes);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="comment">// 执行服务，doService()是一个抽象方法，在DispatcherServlet中进行了重写</span></span><br><span class="line">        doService(request, response);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (ServletException | IOException ex) &#123;</span><br><span class="line">        failureCause = ex;</span><br><span class="line">        <span class="keyword">throw</span> ex;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">        failureCause = ex;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NestedServletException(<span class="string">&quot;Request processing failed&quot;</span>, ex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">finally</span> &#123;</span><br><span class="line">        resetContextHolders(request, previousLocaleContext, previousAttributes);</span><br><span class="line">        <span class="keyword">if</span> (requestAttributes != <span class="keyword">null</span>) &#123;</span><br><span class="line">            requestAttributes.requestCompleted();</span><br><span class="line">        &#125;</span><br><span class="line">        logResult(request, response, failureCause, asyncManager);</span><br><span class="line">        publishRequestHandledEvent(request, response, startTime, failureCause);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="b-gt-doService"><a href="#b-gt-doService" class="headerlink" title="b&gt;doService()"></a>b&gt;doService()</h5><p>所在类：org.springframework.web.servlet.DispatcherServlet</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doService</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    logRequest(request);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Keep a snapshot of the request attributes in case of an include,</span></span><br><span class="line">    <span class="comment">// to be able to restore the original attributes after the include.</span></span><br><span class="line">    Map&lt;String, Object&gt; attributesSnapshot = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (WebUtils.isIncludeRequest(request)) &#123;</span><br><span class="line">        attributesSnapshot = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        Enumeration&lt;?&gt; attrNames = request.getAttributeNames();</span><br><span class="line">        <span class="keyword">while</span> (attrNames.hasMoreElements()) &#123;</span><br><span class="line">            String attrName = (String) attrNames.nextElement();</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.cleanupAfterInclude || attrName.startsWith(DEFAULT_STRATEGIES_PREFIX)) &#123;</span><br><span class="line">                attributesSnapshot.put(attrName, request.getAttribute(attrName));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Make framework objects available to handlers and view objects.</span></span><br><span class="line">    request.setAttribute(WEB_APPLICATION_CONTEXT_ATTRIBUTE, getWebApplicationContext());</span><br><span class="line">    request.setAttribute(LOCALE_RESOLVER_ATTRIBUTE, <span class="keyword">this</span>.localeResolver);</span><br><span class="line">    request.setAttribute(THEME_RESOLVER_ATTRIBUTE, <span class="keyword">this</span>.themeResolver);</span><br><span class="line">    request.setAttribute(THEME_SOURCE_ATTRIBUTE, getThemeSource());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.flashMapManager != <span class="keyword">null</span>) &#123;</span><br><span class="line">        FlashMap inputFlashMap = <span class="keyword">this</span>.flashMapManager.retrieveAndUpdate(request, response);</span><br><span class="line">        <span class="keyword">if</span> (inputFlashMap != <span class="keyword">null</span>) &#123;</span><br><span class="line">            request.setAttribute(INPUT_FLASH_MAP_ATTRIBUTE, Collections.unmodifiableMap(inputFlashMap));</span><br><span class="line">        &#125;</span><br><span class="line">        request.setAttribute(OUTPUT_FLASH_MAP_ATTRIBUTE, <span class="keyword">new</span> FlashMap());</span><br><span class="line">        request.setAttribute(FLASH_MAP_MANAGER_ATTRIBUTE, <span class="keyword">this</span>.flashMapManager);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    RequestPath requestPath = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.parseRequestPath &amp;&amp; !ServletRequestPathUtils.hasParsedRequestPath(request)) &#123;</span><br><span class="line">        requestPath = ServletRequestPathUtils.parseAndCache(request);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 处理请求和响应</span></span><br><span class="line">        doDispatch(request, response);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!WebAsyncUtils.getAsyncManager(request).isConcurrentHandlingStarted()) &#123;</span><br><span class="line">            <span class="comment">// Restore the original attribute snapshot, in case of an include.</span></span><br><span class="line">            <span class="keyword">if</span> (attributesSnapshot != <span class="keyword">null</span>) &#123;</span><br><span class="line">                restoreAttributesAfterInclude(request, attributesSnapshot);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (requestPath != <span class="keyword">null</span>) &#123;</span><br><span class="line">            ServletRequestPathUtils.clearParsedRequestPath(request);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="c-gt-doDispatch"><a href="#c-gt-doDispatch" class="headerlink" title="c&gt;doDispatch()"></a>c&gt;doDispatch()</h5><p>所在类：org.springframework.web.servlet.DispatcherServlet</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doDispatch</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    HttpServletRequest processedRequest = request;</span><br><span class="line">    HandlerExecutionChain mappedHandler = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">boolean</span> multipartRequestParsed = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ModelAndView mv = <span class="keyword">null</span>;</span><br><span class="line">        Exception dispatchException = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            processedRequest = checkMultipart(request);</span><br><span class="line">            multipartRequestParsed = (processedRequest != request);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Determine handler for the current request.</span></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">            	mappedHandler：调用链</span></span><br><span class="line"><span class="comment">                包含handler、interceptorList、interceptorIndex</span></span><br><span class="line"><span class="comment">            	handler：浏览器发送的请求所匹配的控制器方法</span></span><br><span class="line"><span class="comment">            	interceptorList：处理控制器方法的所有拦截器集合</span></span><br><span class="line"><span class="comment">            	interceptorIndex：拦截器索引，控制拦截器afterCompletion()的执行</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            mappedHandler = getHandler(processedRequest);</span><br><span class="line">            <span class="keyword">if</span> (mappedHandler == <span class="keyword">null</span>) &#123;</span><br><span class="line">                noHandlerFound(processedRequest, response);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Determine handler adapter for the current request.</span></span><br><span class="line">           	<span class="comment">// 通过控制器方法创建相应的处理器适配器，调用所对应的控制器方法</span></span><br><span class="line">            HandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler());</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Process last-modified header, if supported by the handler.</span></span><br><span class="line">            String method = request.getMethod();</span><br><span class="line">            <span class="keyword">boolean</span> isGet = <span class="string">&quot;GET&quot;</span>.equals(method);</span><br><span class="line">            <span class="keyword">if</span> (isGet || <span class="string">&quot;HEAD&quot;</span>.equals(method)) &#123;</span><br><span class="line">                <span class="keyword">long</span> lastModified = ha.getLastModified(request, mappedHandler.getHandler());</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">new</span> ServletWebRequest(request, response).checkNotModified(lastModified) &amp;&amp; isGet) &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">			</span><br><span class="line">            <span class="comment">// 调用拦截器的preHandle()</span></span><br><span class="line">            <span class="keyword">if</span> (!mappedHandler.applyPreHandle(processedRequest, response)) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Actually invoke the handler.</span></span><br><span class="line">            <span class="comment">// 由处理器适配器调用具体的控制器方法，最终获得ModelAndView对象</span></span><br><span class="line">            mv = ha.handle(processedRequest, response, mappedHandler.getHandler());</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (asyncManager.isConcurrentHandlingStarted()) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            applyDefaultViewName(processedRequest, mv);</span><br><span class="line">            <span class="comment">// 调用拦截器的postHandle()</span></span><br><span class="line">            mappedHandler.applyPostHandle(processedRequest, response, mv);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">            dispatchException = ex;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Throwable err) &#123;</span><br><span class="line">            <span class="comment">// As of 4.3, we&#x27;re processing Errors thrown from handler methods as well,</span></span><br><span class="line">            <span class="comment">// making them available for @ExceptionHandler methods and other scenarios.</span></span><br><span class="line">            dispatchException = <span class="keyword">new</span> NestedServletException(<span class="string">&quot;Handler dispatch failed&quot;</span>, err);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 后续处理：处理模型数据和渲染视图</span></span><br><span class="line">        processDispatchResult(processedRequest, response, mappedHandler, mv, dispatchException);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">        triggerAfterCompletion(processedRequest, response, mappedHandler, ex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Throwable err) &#123;</span><br><span class="line">        triggerAfterCompletion(processedRequest, response, mappedHandler,</span><br><span class="line">                               <span class="keyword">new</span> NestedServletException(<span class="string">&quot;Handler processing failed&quot;</span>, err));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (asyncManager.isConcurrentHandlingStarted()) &#123;</span><br><span class="line">            <span class="comment">// Instead of postHandle and afterCompletion</span></span><br><span class="line">            <span class="keyword">if</span> (mappedHandler != <span class="keyword">null</span>) &#123;</span><br><span class="line">                mappedHandler.applyAfterConcurrentHandlingStarted(processedRequest, response);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Clean up any resources used by a multipart request.</span></span><br><span class="line">            <span class="keyword">if</span> (multipartRequestParsed) &#123;</span><br><span class="line">                cleanupMultipart(processedRequest);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="d-gt-processDispatchResult"><a href="#d-gt-processDispatchResult" class="headerlink" title="d&gt;processDispatchResult()"></a>d&gt;processDispatchResult()</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processDispatchResult</span><span class="params">(HttpServletRequest request, HttpServletResponse response,</span></span></span><br><span class="line"><span class="function"><span class="params">                                   <span class="meta">@Nullable</span> HandlerExecutionChain mappedHandler, <span class="meta">@Nullable</span> ModelAndView mv,</span></span></span><br><span class="line"><span class="function"><span class="params">                                   <span class="meta">@Nullable</span> Exception exception)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> errorView = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (exception != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (exception <span class="keyword">instanceof</span> ModelAndViewDefiningException) &#123;</span><br><span class="line">            logger.debug(<span class="string">&quot;ModelAndViewDefiningException encountered&quot;</span>, exception);</span><br><span class="line">            mv = ((ModelAndViewDefiningException) exception).getModelAndView();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            Object handler = (mappedHandler != <span class="keyword">null</span> ? mappedHandler.getHandler() : <span class="keyword">null</span>);</span><br><span class="line">            mv = processHandlerException(request, response, handler, exception);</span><br><span class="line">            errorView = (mv != <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Did the handler return a view to render?</span></span><br><span class="line">    <span class="keyword">if</span> (mv != <span class="keyword">null</span> &amp;&amp; !mv.wasCleared()) &#123;</span><br><span class="line">        <span class="comment">// 处理模型数据和渲染视图</span></span><br><span class="line">        render(mv, request, response);</span><br><span class="line">        <span class="keyword">if</span> (errorView) &#123;</span><br><span class="line">            WebUtils.clearErrorRequestAttributes(request);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">            logger.trace(<span class="string">&quot;No view rendering, null ModelAndView returned.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (WebAsyncUtils.getAsyncManager(request).isConcurrentHandlingStarted()) &#123;</span><br><span class="line">        <span class="comment">// Concurrent handling started during a forward</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mappedHandler != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// Exception (if any) is already handled..</span></span><br><span class="line">        <span class="comment">// 调用拦截器的afterCompletion()</span></span><br><span class="line">        mappedHandler.triggerAfterCompletion(request, response, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4、SpringMVC的执行流程"><a href="#4、SpringMVC的执行流程" class="headerlink" title="4、SpringMVC的执行流程"></a>4、SpringMVC的执行流程</h3><ol>
<li><p>用户向服务器发送请求，请求被SpringMVC 前端控制器 DispatcherServlet捕获。</p>
</li>
<li><p>DispatcherServlet对请求URL进行解析，得到请求资源标识符（URI），判断请求URI对应的映射：</p>
</li>
</ol>
<p>a) 不存在</p>
<p>i. 再判断是否配置了mvc:default-servlet-handler</p>
<p>ii. 如果没配置，则控制台报映射查找不到，客户端展示404错误</p>
<p><img src="https://rulerofterabithia-blog.oss-cn-hangzhou.aliyuncs.com/img/20221016220738.png"></p>
<p><img src="https://rulerofterabithia-blog.oss-cn-hangzhou.aliyuncs.com/img/20221016220808.png"></p>
<p>iii. 如果有配置，则访问目标资源（一般为静态资源，如：JS,CSS,HTML），找不到客户端也会展示404错误</p>
<p><img src="https://rulerofterabithia-blog.oss-cn-hangzhou.aliyuncs.com/img/20221016220837.png"></p>
<p><img src="https://rulerofterabithia-blog.oss-cn-hangzhou.aliyuncs.com/img/20221016220905.png"></p>
<p>b) 存在则执行下面的流程</p>
<ol start="3">
<li><p>根据该URI，调用HandlerMapping获得该Handler配置的所有相关的对象（包括Handler对象以及Handler对象对应的拦截器），最后以HandlerExecutionChain执行链对象的形式返回。</p>
</li>
<li><p>DispatcherServlet 根据获得的Handler，选择一个合适的HandlerAdapter。</p>
</li>
<li><p>如果成功获得HandlerAdapter，此时将开始执行拦截器的preHandler(…)方法【正向】</p>
</li>
<li><p>提取Request中的模型数据，填充Handler入参，开始执行Handler（Controller)方法，处理请求。在填充Handler的入参过程中，根据你的配置，Spring将帮你做一些额外的工作：</p>
</li>
</ol>
<p>a) HttpMessageConveter： 将请求消息（如Json、xml等数据）转换成一个对象，将对象转换为指定的响应信息</p>
<p>b) 数据转换：对请求消息进行数据转换。如String转换成Integer、Double等</p>
<p>c) 数据格式化：对请求消息进行数据格式化。 如将字符串转换成格式化数字或格式化日期等</p>
<p>d) 数据验证： 验证数据的有效性（长度、格式等），验证结果存储到BindingResult或Error中</p>
<ol start="7">
<li><p>Handler执行完成后，向DispatcherServlet 返回一个ModelAndView对象。</p>
</li>
<li><p>此时将开始执行拦截器的postHandle(…)方法【逆向】。</p>
</li>
<li><p>根据返回的ModelAndView（此时会判断是否存在异常：如果存在异常，则执行HandlerExceptionResolver进行异常处理）选择一个适合的ViewResolver进行视图解析，根据Model和View，来渲染视图。</p>
</li>
<li><p>渲染视图完毕执行拦截器的afterCompletion(…)方法【逆向】。</p>
</li>
<li><p>将渲染结果返回给客户端。</p>
</li>
</ol>
]]></content>
      <tags>
        <tag>SpringMVC</tag>
      </tags>
  </entry>
  <entry>
    <title>VS Code上传代码到 github（命令实现）</title>
    <url>/hexo-blog/2021/11/20/VS%20Code%E4%B8%8A%E4%BC%A0%E4%BB%A3%E7%A0%81%E5%88%B0%20Github/</url>
    <content><![CDATA[<h1 id="VS-Code上传代码到-github（命令实现）"><a href="#VS-Code上传代码到-github（命令实现）" class="headerlink" title="VS Code上传代码到 github（命令实现）"></a>VS Code上传代码到 github（命令实现）</h1><p>（1）用VS Code打开你的项目，点击Terminal–&gt;new Terminal</p>
<p>（2）初始化项目，在终端输入git init</p>
<p><img src="https://rulerofterabithia-blog.oss-cn-hangzhou.aliyuncs.com/img/20221017095330.jpeg"></p>
<p>完成之后，是这个样子的：</p>
<p><img src="https://rulerofterabithia-blog.oss-cn-hangzhou.aliyuncs.com/img/20221017095451.jpeg"></p>
<p>（3）使用git status查看状态：</p>
<p><img src="https://rulerofterabithia-blog.oss-cn-hangzhou.aliyuncs.com/img/20221017095523.jpeg"></p>
<p>（4）使用git add添加将要上传的项目文件夹</p>
<p><img src="https://rulerofterabithia-blog.oss-cn-hangzhou.aliyuncs.com/img/20221017095550.jpeg"></p>
<p>（5）认证一下邮箱和用户名</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git config --global user.name &#39;rulerofterabithia&#39;</span><br><span class="line">git config --global user.email &#39;caiyongkangofficial@gmail.com&#39;</span><br></pre></td></tr></table></figure>

<p>（6）使用git commit -m ‘student-system’命令，单引号中的名称随意，使用git status命令查看状态，发现将要                  上传的文件夹或文件没有罗列出来，证明添加成功</p>
<p><img src="https://rulerofterabithia-blog.oss-cn-hangzhou.aliyuncs.com/img/20221017095737.jpeg"></p>
<p>（7）使用git branch查看分支</p>
<p><img src="https://rulerofterabithia-blog.oss-cn-hangzhou.aliyuncs.com/img/20221017095851.jpeg"></p>
<p>（8）推送到远程仓库，后面的地址为你的仓库地址</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git remote add origin https:&#x2F;&#x2F;github.com&#x2F;rulerofterabithia&#x2F;student-system.git</span><br></pre></td></tr></table></figure>

<p><img src="https://rulerofterabithia-blog.oss-cn-hangzhou.aliyuncs.com/img/20221017095925.png"></p>
<p>（9）push，如果失败了，可能是网络原因，可以多试几次</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure>

<p><img src="https://rulerofterabithia-blog.oss-cn-hangzhou.aliyuncs.com/img/20221017100001.png">（10)出现了以下的界面，点击Sign in with your browser</p>
<p><img src="https://rulerofterabithia-blog.oss-cn-hangzhou.aliyuncs.com/img/20221017100035.jpeg"></p>
<p><img src="https://rulerofterabithia-blog.oss-cn-hangzhou.aliyuncs.com/img/20221017100148.jpeg"></p>
<p>（11）跳转到浏览器</p>
<p><img src="https://rulerofterabithia-blog.oss-cn-hangzhou.aliyuncs.com/img/20221017100219.jpeg"></p>
<p>（12）出现以下弹框，点击Allow</p>
<p><img src="https://rulerofterabithia-blog.oss-cn-hangzhou.aliyuncs.com/img/20221017100249.jpeg"></p>
<p>（13）点击Continue</p>
<p><img src="https://rulerofterabithia-blog.oss-cn-hangzhou.aliyuncs.com/img/20221017100318.jpeg"></p>
<p>（14）点击Authorize github</p>
<p><img src="https://rulerofterabithia-blog.oss-cn-hangzhou.aliyuncs.com/img/20221017100347.jpeg"></p>
<p>（15）成功！</p>
<p><img src="https://rulerofterabithia-blog.oss-cn-hangzhou.aliyuncs.com/img/20221017100419.png"></p>
<p><img src="https://rulerofterabithia-blog.oss-cn-hangzhou.aliyuncs.com/img/20221017100452.png"></p>
]]></content>
      <tags>
        <tag>Github</tag>
      </tags>
  </entry>
  <entry>
    <title>Java核心技术</title>
    <url>/hexo-blog/2022/04/08/Java%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="Java核心技术"><a href="#Java核心技术" class="headerlink" title="Java核心技术"></a>Java核心技术</h1><h2 id="一、Java基本语法"><a href="#一、Java基本语法" class="headerlink" title="一、Java基本语法"></a>一、Java基本语法</h2><h3 id="1、关键字与保留字"><a href="#1、关键字与保留字" class="headerlink" title="1、关键字与保留字"></a>1、关键字与保留字</h3><h4 id="关键字的定义和特点"><a href="#关键字的定义和特点" class="headerlink" title="关键字的定义和特点"></a>关键字的定义和特点</h4><ul>
<li>被Java语言赋予了特殊含义，用做专门用途的字符串（单词）</li>
<li>关键字中所有字母都为小写</li>
</ul>
<h4 id="保留字的定义"><a href="#保留字的定义" class="headerlink" title="保留字的定义"></a>保留字的定义</h4><ul>
<li>现有Java版本尚未使用，但以后版本可能会作为关键字使用。命名标识符时要避免使用这些保留字。</li>
</ul>
<blockquote>
<p>总结：48个关键字、2个保留字、3个字面值</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">用于定义数据类型的关键字</span><br><span class="line">class interface enum byte short int long float double char boolean void</span><br><span class="line">用于定义流程控制的关键字</span><br><span class="line">if else switch case default while do for break continue return</span><br><span class="line">用于定义访问权限修饰符的关键字</span><br><span class="line">private protected public</span><br><span class="line">用于定义类，函数，变量修饰符的关键字</span><br><span class="line">abstract final static synchronized</span><br><span class="line">用于定义类与类之间关系的关键字</span><br><span class="line">extends implements</span><br><span class="line">用于定义建立实例及引用实例，判断实例的关键字</span><br><span class="line">new this super instanceof</span><br><span class="line">用于异常处理的关键字</span><br><span class="line">try catch finally throw throws</span><br><span class="line">用于包的关键字</span><br><span class="line">package import</span><br><span class="line">其他修饰符关键字</span><br><span class="line">native strictfp transient volatile assert</span><br><span class="line"></span><br><span class="line">保留字</span><br><span class="line">goto const</span><br><span class="line"></span><br><span class="line">用于定义数据类型值的字面值</span><br><span class="line">true false null</span><br></pre></td></tr></table></figure>

<h3 id="2、标识符"><a href="#2、标识符" class="headerlink" title="2、标识符"></a>2、标识符</h3><h4 id="标识符的定义"><a href="#标识符的定义" class="headerlink" title="标识符的定义"></a>标识符的定义</h4><ul>
<li>Java对各种变量、方法和类等要素命名时使用的字符序列称为标识符</li>
</ul>
<blockquote>
<p>技巧：凡是自己可以起名字的地方都叫标识符</p>
</blockquote>
<h4 id="定义合法标识符规则"><a href="#定义合法标识符规则" class="headerlink" title="定义合法标识符规则"></a>定义合法标识符规则</h4><ul>
<li>由26个英文字母大小写，0-9，_或$组成</li>
<li>数字不可以开头</li>
<li>不可以使用关键字和保留字，但能包含关键字和保留字</li>
<li>Java中严格区分大小写，长度无限制</li>
<li>标识符不能包含空格</li>
</ul>
<h4 id="Java中的名称命名规范"><a href="#Java中的名称命名规范" class="headerlink" title="Java中的名称命名规范"></a>Java中的名称命名规范</h4><ul>
<li>包名：多单词组成时所有字母都小写：xxxyyyzzz</li>
<li>类名、接口名：多单词组成时，所有单词的首字母大写：XxxYyyZzz</li>
<li>变量名、方法名：多单词组成时，第一个单词首字母小写，第二个单词开始每个单词首字母大写：xxxYyyZzz</li>
<li>常量名：所有字母都大写，多单词时每个单词用下划线连接：XXX_YYY_ZZZ</li>
</ul>
<blockquote>
<p>注意点：<br>1、在起名字时，为了提高阅读性，要尽量有意义，“见名知意”。<br>2、Java采用unicode字符集，因此标识符也可以使用汉字声明，但是不建议使用。</p>
</blockquote>
<h3 id="3、变量"><a href="#3、变量" class="headerlink" title="3、变量"></a>3、变量</h3><h4 id="变量的概念"><a href="#变量的概念" class="headerlink" title="变量的概念"></a>变量的概念</h4><ul>
<li>内存中的一个存储区域</li>
<li>该区域的数据可以在同一类型范围内不断变化</li>
<li>变量是程序中最基本的存储单元，包含<strong>变量类型</strong>、<strong>变量名</strong>、<strong>存储的值</strong></li>
</ul>
<h4 id="变量的作用"><a href="#变量的作用" class="headerlink" title="变量的作用"></a>变量的作用</h4><ul>
<li>用于在内存中保存数据</li>
</ul>
<h4 id="使用变量注意"><a href="#使用变量注意" class="headerlink" title="使用变量注意"></a>使用变量注意</h4><ul>
<li><strong>Java中每个变量必须先声明，后使用</strong></li>
<li>使用变量名来访问这块区域的数据</li>
<li>变量的作用域：其定义所在的一对{}内</li>
<li>变量只有在其作用域内才有效</li>
<li>同一个作用域内，不能定义重名的变量</li>
</ul>
<h4 id="变量的分类"><a href="#变量的分类" class="headerlink" title="变量的分类"></a>变量的分类</h4><p>按数据类型分类</p>
<ul>
<li>基本数据类型<ul>
<li>数值型<ul>
<li>整数类型 <strong>(byte short int long)</strong></li>
<li>浮点类型 <strong>(float double)</strong></li>
</ul>
</li>
<li>字符型 <strong>(char)</strong></li>
<li>布尔型 <strong>(boolean)</strong></li>
</ul>
</li>
<li>引用数据类型<ul>
<li>类 <strong>(class)</strong></li>
<li>接口 <strong>(interface)</strong></li>
<li>数组 <strong>([])</strong></li>
</ul>
</li>
</ul>
<p>按声明位置分类</p>
<ul>
<li>成员变量<ul>
<li>实例变量 <strong>(不以static修饰)</strong></li>
<li>类变量 <strong>(以static修饰)</strong></li>
</ul>
</li>
<li>局部变量<ul>
<li>形参 <strong>(方法、构造器中定义的变量)</strong></li>
<li>方法局部变量 <strong>(在方法内部定义)</strong></li>
<li>代码块局部变量 <strong>(在代码块内定义)</strong></li>
</ul>
</li>
</ul>
<h4 id="整数变量：byte、short、int、long"><a href="#整数变量：byte、short、int、long" class="headerlink" title="整数变量：byte、short、int、long"></a>整数变量：byte、short、int、long</h4><ul>
<li>Java各整数类型有固定的表数范围和字段长度，不受具体OS的影响，以保证Java程序的可移植性。</li>
<li>Java的整型常量默认为int型，声明long型常量须加<code>l</code>或者<code>L</code></li>
<li>Java程序中变量通常声明为int型，除非不足以表示较大的数，才使用long</li>
</ul>
<table>
<thead>
<tr>
<th align="center">类型</th>
<th align="center">占用存储空间</th>
<th align="center">表数范围</th>
</tr>
</thead>
<tbody><tr>
<td align="center">byte</td>
<td align="center">1字节=8bit位</td>
<td align="center">-128~127</td>
</tr>
<tr>
<td align="center">short</td>
<td align="center">2字节</td>
<td align="center">-$2^{15}$~$2^{15}$-1</td>
</tr>
<tr>
<td align="center">int</td>
<td align="center">4字节</td>
<td align="center">-$2^{31}$~$2^{31}$-1(约21亿)</td>
</tr>
<tr>
<td align="center">long</td>
<td align="center">8字节</td>
<td align="center">-$2^{63}$~$2^{63}$-1</td>
</tr>
</tbody></table>
<blockquote>
<p>bit：计算机中的最小存储单位。byte：计算机中基本存储单元。</p>
</blockquote>
<h4 id="浮点类型：float、double"><a href="#浮点类型：float、double" class="headerlink" title="浮点类型：float、double"></a>浮点类型：float、double</h4><ul>
<li>与整数类型类似，Java浮点类型也有固定的表数范围和字段长度，不受具体操作系统的影响</li>
<li>浮点型常量有两种表示形式：<ul>
<li>十进制数形式</li>
<li>科学计数法形式</li>
</ul>
</li>
<li>float：单精度，尾数可以精确到7位有效数字。很多情况下，精度很难满足需求。</li>
<li>double：双精度，精度是float的两倍。通常采用此类型。</li>
<li>Java的浮点型常量默认是double型，声明float型常量，须后加<code>f</code>或<code>F</code>。</li>
</ul>
<table>
<thead>
<tr>
<th align="center">类型</th>
<th align="center">占用存储空间</th>
<th align="center">表数范围</th>
</tr>
</thead>
<tbody><tr>
<td align="center">float</td>
<td align="center">4字节</td>
<td align="center">-3.403E38~3.403E38</td>
</tr>
<tr>
<td align="center">double</td>
<td align="center">8字节</td>
<td align="center">-1.798E308~1.798E308</td>
</tr>
</tbody></table>
<blockquote>
<p>注意点：float表示数值的范围比long还大</p>
</blockquote>
<h4 id="字符类型：char"><a href="#字符类型：char" class="headerlink" title="字符类型：char"></a>字符类型：char</h4><ul>
<li>char型数据用来表示通常意义上“字符”（2字节）</li>
<li>Java中所有字符都使用Unicode编码，故一个字符可以存储一个字母，一个汉字，或其他书面语的一个字符。</li>
<li>字符型变量的三种表现形式：<ul>
<li>字符常量是用单引号’’括起来的单个字符。</li>
<li>Java中还允许使用转义字符’\‘来将其后的字符转变为特殊字符型常量。</li>
<li>直接使用Unicode值来表示字符型常量。</li>
</ul>
</li>
<li>char类型是可以进行运算的。因为它都对应有Unicode编码。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> c1 = <span class="string">&#x27;a&#x27;</span>; <span class="comment">// 编译通过</span></span><br><span class="line"><span class="comment">// char c2 = &#x27;AB&#x27;; // 编译不通过</span></span><br><span class="line"><span class="keyword">char</span> c3 = <span class="string">&#x27;中&#x27;</span>; <span class="comment">// 编译通过</span></span><br><span class="line"><span class="keyword">char</span> c4 = <span class="string">&#x27;\n&#x27;</span>; <span class="comment">// 编译通过</span></span><br><span class="line"><span class="keyword">char</span> c5 = <span class="string">&#x27;\u0043&#x27;</span>; <span class="comment">// 编译通过</span></span><br><span class="line"><span class="comment">// char c6 = &#x27;&#x27;; // 编译不通过</span></span><br><span class="line"><span class="keyword">char</span> c7 = <span class="number">97</span>; <span class="comment">// a, 开发中极其少见</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>常用ASCII码值： ‘a’ == 97; ‘A’ == 65;</p>
</blockquote>
<h4 id="布尔型：boolean"><a href="#布尔型：boolean" class="headerlink" title="布尔型：boolean"></a>布尔型：boolean</h4><ul>
<li>只能取两个值之一：true、false</li>
<li>常常在条件判断、循环结构中使用</li>
</ul>
<h4 id="基本数据类型转换"><a href="#基本数据类型转换" class="headerlink" title="基本数据类型转换"></a>基本数据类型转换</h4><ul>
<li>自动类型转换：容量小的类型自动转换为容量大的数据类型。数据类型按容量大小排序为：<code>char、byte、short --&gt; int --&gt; long --&gt; float --&gt; double</code></li>
<li>有多种类型的数据混合运算时，系统首先自动将所有数据类型转换为容量最大的那种数据类型，然后再进行计算</li>
<li>byte,short,char之间不会互相转换，他们三者在计算时首先转换为int类型<blockquote>
<p>Java在做运算的时候，如果操作数均在int范围内，那么一律在int的空间内运算。</p>
</blockquote>
</li>
<li>boolean类型不能与其它数据类型运算</li>
<li>当把任何基本数据类型的值和字符串(String)进行连接运算时(+)，基本数据类型的值将自动转化为字符串(String)类型</li>
</ul>
<blockquote>
<p>说明：此时的容量大小指的是表示数的范围的大小。比如：float容量要大于long的容量</p>
</blockquote>
<h4 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h4><ul>
<li>自动类型转换的逆过程，将容量大的数据类型转换为容量小的数据类型。使用时要加上强制转换符：<code>()</code>，但可能造成<strong>精度降低或溢出</strong>，格外要注意<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">double</span> d1 = <span class="number">12.9</span>;</span><br><span class="line"><span class="keyword">int</span> i1 = (<span class="keyword">int</span>)d1; <span class="comment">// 12，截断操作</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> i2 = <span class="number">128</span>;</span><br><span class="line"><span class="keyword">byte</span> b = (<span class="keyword">byte</span>)i2; <span class="comment">// -128</span></span><br></pre></td></tr></table></figure></li>
<li>通常，字符串不能直接转换为基本类型，但通过基本类型对应的包装类则可以实现把字符串转换为基本类型<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String a = <span class="string">&quot;43&quot;</span>;</span><br><span class="line"><span class="keyword">int</span> i = Integer.parseInt(a);</span><br></pre></td></tr></table></figure></li>
<li>boolean类型不可以转换为其它的数据类型</li>
</ul>
<blockquote>
<p>说明：整型常量，默认类型是int型；浮点型常量，默认类型是double型。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">byte</span> b = <span class="number">12</span>;</span><br><span class="line"><span class="comment">// byte b1 = b + 1; // 编译失败</span></span><br><span class="line"><span class="comment">// float f1 = b + 12.3; // 编译失败</span></span><br></pre></td></tr></table></figure>
<h4 id="字符串类型：String"><a href="#字符串类型：String" class="headerlink" title="字符串类型：String"></a>字符串类型：String</h4><ul>
<li>String不是基本数据类型，属于引用数据类型</li>
<li>使用方式与基本数据类型一致。</li>
<li>一个字符串可以串接另一个字符串，也可以直接串接其他类型的数据。<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String str = <span class="string">&quot;abcd&quot;</span>;</span><br><span class="line">str = str + <span class="string">&quot;xyz&quot;</span>;</span><br><span class="line"><span class="keyword">int</span> n = <span class="number">100</span>;</span><br><span class="line">str = str + n; <span class="comment">// abcdxyz100</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="4、进制"><a href="#4、进制" class="headerlink" title="4、进制"></a>4、进制</h3><ul>
<li>所有数字在计算机底层都是以<strong>二进制</strong>形式存在。</li>
<li>对于整数，有四种表示方式：<ul>
<li>二进制(binary)：0,1，满2进1，以<code>0b</code>或<code>0B</code>开头</li>
<li>十进制(decimal)：0-9，满10进1</li>
<li>八进制(octal)：0-7，满8进1，以数字<code>0</code>开头表示</li>
<li>十六进制(hex)：0-9及A-F，满16进1，以<code>0x</code>或<code>0X</code>开头表示。此处的A-F不区分大小写。</li>
</ul>
</li>
<li>Java整数常量默认是int类型，当用二进制定义整数时，其第32位(最高位)是符号位：当是long类型时，二进制默认占64位，第64位是符号位</li>
<li>二进制的整数有如下三种形式：<ul>
<li>原码：直接将一个数值换成二进制数。最高位是符号位</li>
<li>负数的反码：是对原码按位取反，只有最高位(符号位)确认为1</li>
<li>负数的补码：其反码加1</li>
</ul>
</li>
<li>计算机以二进制<strong>补码</strong>的形式保持所有的整数<ul>
<li>正数的原码、反码、补码都相同</li>
<li>负数的补码是其反码+1</li>
</ul>
</li>
</ul>
<h3 id="5、运算符"><a href="#5、运算符" class="headerlink" title="5、运算符"></a>5、运算符</h3><p>运算符是一种特殊的符号，用以表示数据的运算、赋值和比较等。</p>
<ul>
<li>算术运算符</li>
<li>赋值运算符</li>
<li>比较运算符（关系运算符）</li>
<li>逻辑运算符</li>
<li>位运算符</li>
<li>三元运算符</li>
</ul>
<h4 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h4><table>
<thead>
<tr>
<th align="center">运算符</th>
<th align="center">运算</th>
<th align="center">范例</th>
<th align="center">结果</th>
</tr>
</thead>
<tbody><tr>
<td align="center">+</td>
<td align="center">正号</td>
<td align="center">+3</td>
<td align="center">3</td>
</tr>
<tr>
<td align="center">-</td>
<td align="center">负号</td>
<td align="center">b=4; -b</td>
<td align="center">-4</td>
</tr>
<tr>
<td align="center">+</td>
<td align="center">加</td>
<td align="center">5+5</td>
<td align="center">10</td>
</tr>
<tr>
<td align="center">-</td>
<td align="center">减</td>
<td align="center">6-4</td>
<td align="center">2</td>
</tr>
<tr>
<td align="center">*</td>
<td align="center">乘</td>
<td align="center">3*4</td>
<td align="center">12</td>
</tr>
<tr>
<td align="center">/</td>
<td align="center">除</td>
<td align="center">5/5</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">%</td>
<td align="center">取模(取余)</td>
<td align="center">7%5</td>
<td align="center">2</td>
</tr>
<tr>
<td align="center">++</td>
<td align="center">自增(前)，先运算后取值</td>
<td align="center">a=2;b=++a;</td>
<td align="center">a=3;b=3</td>
</tr>
<tr>
<td align="center">++</td>
<td align="center">自增(后)，先取值后运算</td>
<td align="center">a=2;b=a++;</td>
<td align="center">a=3;b=2</td>
</tr>
<tr>
<td align="center">–</td>
<td align="center">自减(前)，先运算后取值</td>
<td align="center">a=2;b=–a;</td>
<td align="center">a=1;b=1</td>
</tr>
<tr>
<td align="center">–</td>
<td align="center">自减(后)，先取值后运算</td>
<td align="center">a=2;b=a–;</td>
<td align="center">a=1;b=2</td>
</tr>
<tr>
<td align="center">+</td>
<td align="center">字符串连接</td>
<td align="center">“He”+”llo”</td>
<td align="center">“Hello”</td>
</tr>
</tbody></table>
<p><strong>疑难点1：<code>%</code>取余运算，结果的符号与被模数的符号相同</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> m1 = <span class="number">12</span>;</span><br><span class="line"><span class="keyword">int</span> n1 = <span class="number">5</span>;</span><br><span class="line">System.out.println(<span class="string">&quot;m1 % n1 = &quot;</span> + m1 % n1); <span class="comment">// m1 % n1 = 2</span></span><br><span class="line"><span class="keyword">int</span> m2 = -<span class="number">12</span>;</span><br><span class="line"><span class="keyword">int</span> n2 = <span class="number">5</span>;</span><br><span class="line">System.out.println(<span class="string">&quot;m1 % n1 = &quot;</span> + m2 % n2); <span class="comment">// m1 % n1 = -2</span></span><br><span class="line"><span class="keyword">int</span> m3 = <span class="number">12</span>;</span><br><span class="line"><span class="keyword">int</span> n3 = -<span class="number">5</span>;</span><br><span class="line">System.out.println(<span class="string">&quot;m1 % n1 = &quot;</span> + m3 % n3); <span class="comment">// m1 % n1 = 2</span></span><br><span class="line"><span class="keyword">int</span> m4 = -<span class="number">12</span>;</span><br><span class="line"><span class="keyword">int</span> n4 = -<span class="number">5</span>;</span><br><span class="line">System.out.println(<span class="string">&quot;m1 % n1 = &quot;</span> + m4 % n4); <span class="comment">// m1 % n1 = -2</span></span><br></pre></td></tr></table></figure>

<p><strong>疑难点2：++ 和 – 不会改变变量本身的数据类型</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">short</span> s = <span class="number">10</span>;</span><br><span class="line"><span class="comment">//s = s + 1; //编译失败</span></span><br><span class="line">s = (<span class="keyword">short</span>) (s + <span class="number">1</span>); <span class="comment">//正确</span></span><br><span class="line">s++; <span class="comment">//正确</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">byte</span> b = <span class="number">127</span>;</span><br><span class="line">b++;</span><br><span class="line">System.out.println(b); <span class="comment">//-128</span></span><br></pre></td></tr></table></figure>

<h4 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h4><p>符号：<code>=</code> 拓展赋值运算符：<code>+=</code>,<code>-=</code>,<code>*=</code>,<code>/=</code>,<code>%=</code></p>
<ul>
<li>当<code>=</code>两侧数据类型不一致时，可以使用自动类型转换或使用强制类型转换原则进行处理</li>
<li>支持连续赋值<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i, j;</span><br><span class="line"><span class="comment">//连续赋值</span></span><br><span class="line">i = j = <span class="number">10</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>疑难点：拓展赋值运算符不会改变变量本身的数据类型</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">short</span> s = <span class="number">10</span>;</span><br><span class="line"><span class="comment">//s = s + 2; //编译失败</span></span><br><span class="line">s += <span class="number">2</span>;</span><br><span class="line">System.out.println(s); <span class="comment">//12</span></span><br><span class="line"><span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">i *= <span class="number">0.1</span>;</span><br><span class="line">System.out.println(i); <span class="comment">// 0</span></span><br></pre></td></tr></table></figure>

<h4 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h4><table>
<thead>
<tr>
<th align="center">运算符</th>
<th align="center">运算</th>
<th align="center">范例</th>
<th align="center">结果</th>
</tr>
</thead>
<tbody><tr>
<td align="center">==</td>
<td align="center">相等于</td>
<td align="center">4==3</td>
<td align="center">false</td>
</tr>
<tr>
<td align="center">!=</td>
<td align="center">不等于</td>
<td align="center">4!=3</td>
<td align="center">true</td>
</tr>
<tr>
<td align="center">&lt;</td>
<td align="center">小于</td>
<td align="center">4&lt;3</td>
<td align="center">false</td>
</tr>
<tr>
<td align="center">&gt;</td>
<td align="center">大于</td>
<td align="center">4&gt;3</td>
<td align="center">true</td>
</tr>
<tr>
<td align="center">&lt;=</td>
<td align="center">小于等于</td>
<td align="center">4&lt;=3</td>
<td align="center">false</td>
</tr>
<tr>
<td align="center">&gt;=</td>
<td align="center">大于等于</td>
<td align="center">4&gt;=3</td>
<td align="center">true</td>
</tr>
<tr>
<td align="center">instanceof</td>
<td align="center">检查是否是类的对象</td>
<td align="center">“Hello” instanceof String</td>
<td align="center">true</td>
</tr>
</tbody></table>
<ul>
<li>比较运算符的结果都是boolean型，也就是要么是true，要么是false。</li>
<li><strong>比较运算符<code>==</code>不能误写成<code>=</code></strong></li>
<li><code>&gt;</code> <code>&lt;</code> <code>&gt;=</code> <code>&lt;=</code>：只能使用在数值类型的数据之间</li>
<li><code>==</code>：不仅可以使用在数值类型数据之间，还可以使用在其他引用类型变量之间。</li>
</ul>
<h4 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h4><p><code>&amp;</code>-逻辑与<br><code>|</code>-逻辑或<br><code>!</code>-逻辑非<br><code>&amp;&amp;</code>-短路与<br><code>||</code>-短路或<br><code>^</code>-逻辑异或</p>
<table>
<thead>
<tr>
<th align="center">a</th>
<th align="center">b</th>
<th align="center">a&amp;b</th>
<th align="center">a&amp;&amp;b</th>
<th align="center">a|b</th>
<th align="center">a||b</th>
<th align="center">!a</th>
<th align="center">a^b</th>
</tr>
</thead>
<tbody><tr>
<td align="center">true</td>
<td align="center">true</td>
<td align="center">true</td>
<td align="center">true</td>
<td align="center">true</td>
<td align="center">true</td>
<td align="center">false</td>
<td align="center">false</td>
</tr>
<tr>
<td align="center">true</td>
<td align="center">false</td>
<td align="center">false</td>
<td align="center">false</td>
<td align="center">true</td>
<td align="center">true</td>
<td align="center">false</td>
<td align="center">true</td>
</tr>
<tr>
<td align="center">false</td>
<td align="center">true</td>
<td align="center">false</td>
<td align="center">false</td>
<td align="center">true</td>
<td align="center">true</td>
<td align="center">true</td>
<td align="center">true</td>
</tr>
<tr>
<td align="center">false</td>
<td align="center">false</td>
<td align="center">false</td>
<td align="center">false</td>
<td align="center">false</td>
<td align="center">false</td>
<td align="center">true</td>
<td align="center">false</td>
</tr>
</tbody></table>
<p><strong>区分 &amp; 与 &amp;&amp;</strong></p>
<ul>
<li>相同点1：&amp;与&amp;&amp;的运算结果相同</li>
<li>相同点2：当符号左边为true时，二者都会执行符号右边的运算</li>
<li>不同点：当符号左边为false时，&amp;继续执行符号右边的运算，&amp;&amp;不再执行符号右边的运算</li>
</ul>
<p><strong>区分 | 与 ||</strong></p>
<ul>
<li>相同点1：|与||的运算结果相同</li>
<li>相同点2：当符号左边是false时，二者都会执行符号右边的运算</li>
<li>不同点1：当符号左边是true时，|继续执行符号右边的运算，而||不再执行符号右边的运算</li>
</ul>
<h4 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h4><table>
<thead>
<tr>
<th align="center">运算符</th>
<th align="center">运算</th>
<th align="center">范例</th>
</tr>
</thead>
<tbody><tr>
<td align="center">&lt;&lt;</td>
<td align="center">左移</td>
<td align="center">3 &lt;&lt; 2 = 12 –&gt; 3*2*2=12</td>
</tr>
<tr>
<td align="center">&gt;&gt;</td>
<td align="center">右移</td>
<td align="center">3 &gt;&gt; 1 = 1 –&gt; 3/2=1</td>
</tr>
<tr>
<td align="center">&gt;&gt;&gt;</td>
<td align="center">无符号右移</td>
<td align="center">3 &gt;&gt;&gt; 1 = 1 –&gt; 3/2=1</td>
</tr>
<tr>
<td align="center">&amp;</td>
<td align="center">与运算</td>
<td align="center">6 &amp; 3 = 2</td>
</tr>
<tr>
<td align="center">|</td>
<td align="center">或运算</td>
<td align="center">6 | 3 = 7</td>
</tr>
<tr>
<td align="center">^</td>
<td align="center">异或运算</td>
<td align="center">6 ^ 3 = 5</td>
</tr>
<tr>
<td align="center">~</td>
<td align="center">取反运算</td>
<td align="center">~6 = -7</td>
</tr>
</tbody></table>
<blockquote>
<p>位运算时直接对整数的二进制进行的运算</p>
</blockquote>
<table>
<thead>
<tr>
<th align="center">运算符</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">&lt;&lt;</td>
<td align="center">空位补0，被移除的高位丢弃，空缺位补0</td>
</tr>
<tr>
<td align="center">&gt;&gt;</td>
<td align="center">被移除的二进制最高位是0，右移后，空缺位补0，若最高位是1，空缺位补1</td>
</tr>
<tr>
<td align="center">&gt;&gt;&gt;</td>
<td align="center">被移位二进制最高位无论是0或者是1，空缺位都用0补</td>
</tr>
<tr>
<td align="center">&amp;</td>
<td align="center">二进制位进行&amp;运算，只有1&amp;1时结果是1，否则是0</td>
</tr>
<tr>
<td align="center">|</td>
<td align="center">二进制位进行|运算，只有0|0时结果是0，否则是1</td>
</tr>
<tr>
<td align="center">^</td>
<td align="center">相同二进制进行^运算结果是0：1^1=0,0^0=0；不相同二进制位^运算结果是1：1^0=1，0^1=1</td>
</tr>
<tr>
<td align="center">~</td>
<td align="center">各二进制码按补码各位取反</td>
</tr>
</tbody></table>
<blockquote>
<p>m = k ^ n = (m ^ n) ^ n</p>
</blockquote>
<h4 id="三元运算符"><a href="#三元运算符" class="headerlink" title="三元运算符"></a>三元运算符</h4><ul>
<li>格式：(条件表达式) ? 表达式1 : 表达式2;</li>
<li>表达式1和表达式2为同种类型</li>
</ul>
<p><strong>三元运算符与if-else的联系与区别</strong></p>
<ul>
<li>三元运算符可简化if-else语句</li>
<li>三元运算符要求必须返回一个结果</li>
<li>if后的代码块可有多个语句</li>
</ul>
<p><strong>附加：运算符的优先级</strong><br>| | . () {} ; , |<br>| :—: | :—: |<br>| R–&gt;L | <code>++</code> <code>--</code> <code>~</code> <code>!(data type)</code> |<br>| L–&gt;R | <code>*</code> <code>/</code> <code>%</code> |<br>| L–&gt;R | <code>+</code> <code>-</code> |<br>| L–&gt;R | <code>&lt;&lt;</code> <code>&gt;&gt;</code> <code>&gt;&gt;&gt;</code> |<br>| L–&gt;R | <code>&lt;</code> <code>&gt;</code> <code>&lt;=</code> <code>&gt;=</code> <code>instanceof</code> |<br>| L–&gt;R | <code>==</code> <code>!=</code> |<br>| L–&gt;R | <code>&amp;</code> |<br>| L–&gt;R | <code>^</code> |<br>| L–&gt;R | <code>\|</code> |<br>| L–&gt;R | <code>&amp;&amp;</code> |<br>| L–&gt;R | <code>\|\|</code> |<br>| R–&gt;L | <code>? :</code> |<br>| R–&gt;L | <code>=</code> <code>*=</code> <code>/=</code> <code>%=</code> |<br>|  | <code>+=</code> <code>-=</code> <code>&lt;&lt;=</code> <code>&gt;&gt;=</code> |<br>|  | <code>&gt;&gt;&gt;=</code> <code>&amp;=</code> <code>^=</code> <code>\|=</code> |</p>
<h3 id="6、程序流程控制"><a href="#6、程序流程控制" class="headerlink" title="6、程序流程控制"></a>6、程序流程控制</h3><ul>
<li>程序控制语句是用来控制程序中各语句执行顺序的语句，可以把语句组合成能完成一定功能的小逻辑模块。</li>
<li>其流程控制方式采用结构化程序设计中规定的三种基本流程结果，即：顺序结构、分支结构、循环结构</li>
</ul>
<h4 id="分支结构"><a href="#分支结构" class="headerlink" title="分支结构"></a>分支结构</h4><p><strong>if-else结构</strong></p>
<ul>
<li>else 结构是可选的</li>
<li>针对与条件表达式：<ul>
<li>如果多个条件表达式之间是“互斥”关系（或没有交集的关系），哪个判断和执行语句声明在上面还是下面，无所谓。</li>
<li>如果多个条件表达式之间有交集的关系，需要根据实际情况，考虑清楚应该将哪个结构声明在上面。</li>
<li>如果多个条件表达式之间有包含关系，通常情况下，需要将范围小的声明在范围大的上面。否则，范围小的就没有机会执行</li>
</ul>
</li>
<li>if-else 结构是可以互相嵌套的。</li>
<li>如果if-else结构中的执行语句只有一行时，对应的一对{}可以省略的。但是，不建议大家省略。</li>
<li>多个if-else时，if-else的配对方式采用就近原则进行配对</li>
</ul>
<p><strong>switch-case结构</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span>(表达式)&#123;</span><br><span class="line">  <span class="keyword">case</span> 常量<span class="number">1</span>:</span><br><span class="line">    语句<span class="number">1</span>;</span><br><span class="line">    <span class="comment">// break;</span></span><br><span class="line">  <span class="keyword">case</span> 常量<span class="number">2</span>:</span><br><span class="line">    语句<span class="number">2</span>;</span><br><span class="line">    <span class="comment">// break;</span></span><br><span class="line">  ... ...</span><br><span class="line">  <span class="keyword">case</span> 常量N:</span><br><span class="line">    语句N;</span><br><span class="line">    <span class="comment">// break;</span></span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    语句;</span><br><span class="line">    <span class="comment">// break;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>根据switch表达式中的值，依次匹配各个case中的常量。一旦匹配成功，则进入相应的case结构中，调用其执行语句。当调用完执行语句以后，则仍然继续向下执行其他case结构中的执行语句，直到遇到break关键字或此switch-case结构末尾结束为止。</li>
<li>break，可以使用在switch-case结构中，表示一旦执行到此关键字，就跳出switch-case结构</li>
<li>switch结构中的表达式，只能是如下的6种数据类型之一：byte、short、char、int、枚举类型（JDK5.0新增）、String类型（JDK7.0新增）</li>
<li>case 之后只能声明常量，不能声明范围。</li>
<li>break 关键字是可选的</li>
<li>default：相当于if-else结构中的else。default结构是可选的，而且位置是灵活的。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> number = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// Console: zero</span></span><br><span class="line"><span class="keyword">switch</span>(number) &#123;</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    System.out.println(<span class="string">&quot;other&quot;</span>);</span><br><span class="line">  <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">    System.out.println(<span class="string">&quot;zero&quot;</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">    System.out.println(<span class="string">&quot;one&quot;</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>凡是可以使用switch-case的结构，都可以转换为if-else。反之，不成立。</li>
<li>当发现既可以使用switch-case且switch中表达式的取值情况不太多，又可以使用if-else时，我们优先选择使用switch-case。原因：switch-case执行效率稍高。</li>
</ul>
<h4 id="循环结构"><a href="#循环结构" class="headerlink" title="循环结构"></a>循环结构</h4><p>循环语句的四个组成部分</p>
<ul>
<li>初始化部分</li>
<li>循环条件部分</li>
<li>循环体部分</li>
<li>迭代部分</li>
</ul>
<p><strong>for循环结构</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(初始化部分;循环条件部分;迭代部分) &#123;</span><br><span class="line">  循环体部分</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">执行过程：初始化部分-循环条件部分-循环体部分-迭代部分-循环条件部分-循环体部分-迭代部分- ... - 循环条件部分</span><br></pre></td></tr></table></figure>

<p><strong>while循环结构</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">初始化部分</span><br><span class="line"><span class="keyword">while</span>(循环条件部分) &#123;</span><br><span class="line">  循环体部分</span><br><span class="line">  迭代部分</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">执行过程：初始化部分-循环条件部分-循环体部分-迭代部分-循环条件部分-循环体部分-迭代部分- ... - 循环条件部分</span><br></pre></td></tr></table></figure>
<ul>
<li>写while循环千万小心不要丢了迭代条件。一旦丢了，就可能导致死循环！</li>
<li>写程序需要避免出现死循环。</li>
<li>for循环和while循环是可以相互转换的。区别在于for循环和while循环的初始化条件部分的作用范围不同。</li>
</ul>
<p><strong>do-while循环结构</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">初始化部分</span><br><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">  循环体部分</span><br><span class="line">  迭代部分</span><br><span class="line">&#125;<span class="keyword">while</span>(循环条件部分);</span><br><span class="line"></span><br><span class="line">执行过程：初始化部分-循环体部分-迭代部分-循环条件部分-循环体部分-迭代部分- ... - 循环条件部分</span><br></pre></td></tr></table></figure>
<ul>
<li>do-while循环至少会执行一次循环体！</li>
<li>开发中，使用for和while更多一些。较少使用do-while</li>
</ul>
<p><strong>特殊关键字的使用</strong><br>|  | 适用范围 | 不同点 | 相同点 |<br>| :—: | :—: | :—: | :—: |<br>| break | switch-case和循环结构中 | 结束当前循环 | 关键字后面不能声明执行语句 |<br>| continue | 循环结构中 | 结束当次循环 | 关键字后面不能声明执行语句 |</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">label: <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">4</span>; i++) &#123;</span><br><span class="line">          <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">10</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j % <span class="number">4</span> == <span class="number">0</span>) &#123;</span><br><span class="line">              <span class="comment">//break; //默认跳出包裹此关键字最近的一层循环</span></span><br><span class="line">              <span class="comment">//continue;</span></span><br><span class="line">              </span><br><span class="line">              <span class="comment">//break label; //结束指定标识的一层循环结构</span></span><br><span class="line">              <span class="keyword">continue</span> label; <span class="comment">//结束指定标识的一层循环结构当次循环</span></span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>return：并非专门用于结束循环的，它的功能是结束一个方法。当一个方法执行到一个return语句时，这个方法将被结束。</li>
<li>与break和continue不同的是，return直接结束整个方法，不管这个return处于多少层循环之内</li>
</ul>
<h3 id="7、数组"><a href="#7、数组" class="headerlink" title="7、数组"></a>7、数组</h3><ul>
<li>数组(Array)，是多个相同类型数据按一定顺序排列的集合，并使用一个名字命名，并通过编号的方式对这些数据进行统一管理。</li>
<li>数组本身是<strong>引用数据类型</strong>，而数组中的元素可以是任何数据类型，包括基本数据类型和引用数据类型。</li>
<li>创建数组对象会在内存中开辟一整块连续的空间，而数组名中引用的是这块连续空间的首地址。</li>
<li>数组的长度一旦确定，就不能修改。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.一维数组的声明和初始化		</span></span><br><span class="line"><span class="keyword">int</span>[] ids;<span class="comment">//声明</span></span><br><span class="line"><span class="comment">//1.1静态初始化：数组的初始化和数组元素的赋值操作同时进行</span></span><br><span class="line">ids = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1001</span>,<span class="number">1002</span>,<span class="number">1003</span>,<span class="number">1004</span>&#125;;</span><br><span class="line"><span class="comment">//1.2动态初始化：数组的初始化和数组元素的赋值操作分开进行</span></span><br><span class="line">String[] names = <span class="keyword">new</span> String[<span class="number">5</span>];</span><br></pre></td></tr></table></figure>

<p><strong>数组元素的默认初始化值</strong></p>
<ul>
<li>数组元素是整型：0</li>
<li>数组元素是浮点型：0.0</li>
<li>数组元素是char型：0或者’\u0000’，而非’0’</li>
<li>数组元素是boolean型：false</li>
<li>数组元素是引用数据类型：null</li>
</ul>
<blockquote>
<p>对于二维数组的理解：我们可以看成是一维数组array1又作为另一个一维数组array2的元素而存在。其实，从数组底层的运行机制来看，其实没有多维数组。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//一些错误的写法</span></span><br><span class="line"><span class="comment">//int[] ids;</span></span><br><span class="line"><span class="comment">//ids = &#123;1,2,2&#125;; //编译错误</span></span><br><span class="line"><span class="comment">//一些正确但是不标准的写法</span></span><br><span class="line"><span class="keyword">int</span>[] arr1 = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>&#125;; <span class="comment">//类型推断</span></span><br><span class="line"><span class="keyword">int</span>[] arr2[] = <span class="keyword">new</span> <span class="keyword">int</span>[][]&#123;&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>&#125;,&#123;<span class="number">4</span>,<span class="number">5</span>&#125;,&#123;<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>&#125;&#125;; <span class="comment">// 数组[]位置可以随意</span></span><br><span class="line"><span class="keyword">int</span>[] arr3[] = &#123;&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>&#125;,&#123;<span class="number">4</span>,<span class="number">5</span>&#125;,&#123;<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>&#125;&#125;;</span><br><span class="line">String[] strArray1[] = &#123;&#123;<span class="string">&quot;222&quot;</span>, <span class="string">&quot;2222&quot;</span>&#125;,&#123;<span class="string">&quot;111&quot;</span>, <span class="string">&quot;3333&quot;</span>, <span class="string">&quot;5555&quot;</span>&#125;&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="附加：Arrays工具类的使用"><a href="#附加：Arrays工具类的使用" class="headerlink" title="附加：Arrays工具类的使用"></a>附加：Arrays工具类的使用</h3><ul>
<li>java.util.Arrays类即为操作数组的工具类，包含了用来操作数组的各种方法</li>
</ul>
<table>
<thead>
<tr>
<th align="center">方法</th>
<th align="center">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">boolean equals(int[] a,int[] b)</td>
<td align="center">判断两个数组是否相等</td>
</tr>
<tr>
<td align="center">String toString(int[] a)</td>
<td align="center">输出数组信息</td>
</tr>
<tr>
<td align="center">void fill(int[] a,int val)</td>
<td align="center">将指定值填充到数组之中</td>
</tr>
<tr>
<td align="center">void sort(int[] a)</td>
<td align="center">对数组进行排序</td>
</tr>
<tr>
<td align="center">int binarySearch(int[] a,int key)</td>
<td align="center">对排列后的数组进行二分法检索指定的值</td>
</tr>
</tbody></table>
<h2 id="二、面向对象编程"><a href="#二、面向对象编程" class="headerlink" title="二、面向对象编程"></a>二、面向对象编程</h2><h3 id="1、面向过程与面向对象"><a href="#1、面向过程与面向对象" class="headerlink" title="1、面向过程与面向对象"></a>1、面向过程与面向对象</h3><h4 id="面向过程-POP-与面向对象-OOP"><a href="#面向过程-POP-与面向对象-OOP" class="headerlink" title="面向过程(POP)与面向对象(OOP)"></a>面向过程(POP)与面向对象(OOP)</h4><ul>
<li>二者都是一种思想，面向对象是相对于面向过程而言的。面向过程，强调的是功能行为，以函数为最小单位，考虑怎么做。面向对象，将功能封装进对象，强调具备了功能的对象，以类/对象为最小单位，考虑谁来做。</li>
<li>面向对象更加强调运用人类在日常的思维逻辑中采用的思想方法与原则，如抽象、分类、继承、聚合、多态等。</li>
</ul>
<h4 id="面向对象的三大特征"><a href="#面向对象的三大特征" class="headerlink" title="面向对象的三大特征"></a>面向对象的三大特征</h4><ul>
<li>封装性</li>
<li>继承性</li>
<li>多态性</li>
</ul>
<h4 id="面向对象的思想概述"><a href="#面向对象的思想概述" class="headerlink" title="面向对象的思想概述"></a>面向对象的思想概述</h4><ul>
<li>程序员从面向过程的<strong>执行者</strong>转化成了面向对象的<strong>指挥者</strong></li>
<li>面向对象分析方法分析问题的思路和步骤：<ul>
<li>根据问题需要，选择问题所针对的<strong>现实世界的实体</strong>。</li>
<li>从实体中寻找解决问题相关的属性和功能，这些属性和功能就形成了<strong>概念世界中的类</strong>。</li>
<li>把抽象的实体用计算机语言进行描述，<strong>形成计算机世界中的类的定义</strong>。即借助某种程序语言，把类构造成计算机能够识别和处理的数据结构。</li>
<li>把<strong>类实例化成计算机世界中的对象</strong>。对象是计算机世界中解决问题的最终工具。</li>
</ul>
</li>
</ul>
<h3 id="2、Java语言基本元素：类和对象"><a href="#2、Java语言基本元素：类和对象" class="headerlink" title="2、Java语言基本元素：类和对象"></a>2、Java语言基本元素：类和对象</h3><h4 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h4><ul>
<li>类(Class)和对象(Object)是面向对象的核心概念。<ul>
<li>类是对一类事物的描述，是<strong>抽象的</strong>、概念上的定义</li>
<li>对象是<strong>实际存在的</strong>的该类事物的每个个体，因而也称为<strong>实例</strong>。</li>
</ul>
</li>
</ul>
<h4 id="类和对象的使用（面向对象思想落地的实现）"><a href="#类和对象的使用（面向对象思想落地的实现）" class="headerlink" title="类和对象的使用（面向对象思想落地的实现）"></a>类和对象的使用（面向对象思想落地的实现）</h4><ul>
<li>创建类，设计类的成员</li>
<li>创建类的对象</li>
<li>通过”对象.属性”或”对象.方法”调用对象的结构</li>
</ul>
<blockquote>
<p>如果创建了一个类的多个对象，则每个对象都独立的拥有一套类的(非static的)属性。意味着：如果我们修改一个对象的属性a，则不影响另外一个对象属性a的值。</p>
</blockquote>
<h4 id="对象的创建和使用：内存解析"><a href="#对象的创建和使用：内存解析" class="headerlink" title="对象的创建和使用：内存解析"></a>对象的创建和使用：内存解析</h4><ul>
<li><strong>堆(Heap)<strong>，此内存区域的唯一目的就是</strong>存放对象实例</strong>，几乎所有的对象实例都在这里分配内存。这一点在Java虚拟机规范中的描述是：所有的对象实例以及数组都要在堆上分配。</li>
<li>通常所说的<strong>栈(Stack)<strong>，是指虚拟机栈。虚拟机栈用于</strong>存储局部变量</strong>等。局部变量表存放了编译期可知长度的各种基本数据类型(boolean、byte、char、short、int、float、long、double)、对象引用(reference类型，它不等同于对象本身，是对象在堆内存的首地址)。方法执行完，自动释放。</li>
<li><strong>方法区(Method Area)<strong>，用于存储已被虚拟机加载的</strong>类信息、常量、静态变量、即时编译器编译后的代码</strong>等数据</li>
</ul>
<h3 id="3、类的成员之一：属性"><a href="#3、类的成员之一：属性" class="headerlink" title="3、类的成员之一：属性"></a>3、类的成员之一：属性</h3><h4 id="属性-成员变量-VS-局部变量"><a href="#属性-成员变量-VS-局部变量" class="headerlink" title="属性(成员变量) VS 局部变量"></a>属性(成员变量) VS 局部变量</h4><ul>
<li>相同点<ul>
<li>定义变量的格式：数据类型 变量名 = 变量值</li>
<li>先声明，后使用</li>
<li>变量都有其对应的作用域</li>
</ul>
</li>
<li>不同点<ul>
<li>在类中声明的位置不同。属性直接定义在类的一对{}内；局部变量声明在方法内、方法形参、代码块内、构造器形参、构造器内部的变量</li>
<li>关于权限修饰符的不同。属性可以在声明属性时，指明其权限，使用权限修饰符。常用的权限修饰符：private、public、缺省、protected。局部变量不可以使用权限修饰符。</li>
<li>默认初始化值的情况<ul>
<li>属性：类的属性，根据其类型，都有默认初始化值。整型(byte、short、int、long)：0；浮点型(float、double)：0.0；字符型(char)：0(或’\u0000’)；布尔型(boolean)：false；引用数据类型(类、数组、接口)：null</li>
<li>局部变量：没有默认初始值。意味着，我们在调用局部变量之前，一定要显式赋值。特别地，形参在调用时，我们赋值即可。</li>
</ul>
</li>
<li>在内存中加载的位置：属性加载在堆空间中(非static)；局部变量加载在栈空间</li>
</ul>
</li>
</ul>
<h3 id="4、类的成员之二：方法"><a href="#4、类的成员之二：方法" class="headerlink" title="4、类的成员之二：方法"></a>4、类的成员之二：方法</h3><h4 id="方法的声明"><a href="#方法的声明" class="headerlink" title="方法的声明"></a>方法的声明</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">权限修饰符 返回值类型 方法名(形参列表)&#123;</span><br><span class="line">  方法体</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 注意：static、final、abstract来修饰的方法，后面再讲</span></span><br></pre></td></tr></table></figure>

<h4 id="返回值类型：有返回值-VS-没有返回值"><a href="#返回值类型：有返回值-VS-没有返回值" class="headerlink" title="返回值类型：有返回值 VS 没有返回值"></a>返回值类型：有返回值 VS 没有返回值</h4><ul>
<li>如果方法有返回值，则必须在方法声明时，指定返回值的类型。同时，方法中，需要使用return关键字来返回指定类型的变量或常量：“return 数据”。</li>
<li>如果方法没有返回值，则方法声明时，使用void来表示。通常，没有返回值的方法中，就不需要使用return。但是，如果使用的话，只能“return;”表示结束此方法的意思。</li>
</ul>
<h4 id="return-关键字的使用"><a href="#return-关键字的使用" class="headerlink" title="return 关键字的使用"></a>return 关键字的使用</h4><ul>
<li>使用范围：使用在方法体中</li>
<li>作用：1、结束方法；2、针对于有返回值类型的方法，使用”return 数据”方法返回所要的数据。</li>
<li>注意点：return关键字后面不可以声明执行语句。</li>
</ul>
<h4 id="方法的使用"><a href="#方法的使用" class="headerlink" title="方法的使用"></a>方法的使用</h4><ul>
<li>方法的使用中，可以调用当前类的属性或方法。特殊的，方法A中又调用了方法A：递归方法</li>
<li>方法中不可以定义方法。</li>
</ul>
<h4 id="理解“万事万物皆对象”"><a href="#理解“万事万物皆对象”" class="headerlink" title="理解“万事万物皆对象”"></a>理解“万事万物皆对象”</h4><ul>
<li>在Java语言范畴中，我们都将功能、结构等封装到类中，通过类的实例化，来调用具体的功能接口<ul>
<li>Scanner, String等</li>
<li>文件：File</li>
<li>网络资源：URL</li>
</ul>
</li>
<li>涉及到Java与前端Html、后端的数据库交互时，前后端的结构在Java层面交互时，都体现为类和对象。</li>
</ul>
<h4 id="方法的重载-overload"><a href="#方法的重载-overload" class="headerlink" title="方法的重载(overload)"></a>方法的重载(overload)</h4><ul>
<li>重载的概念：在同一个类中，允许存在一个以上的同名方法，只要它们的参数个数或者参数类型不同即可。</li>
<li>重载的特点：与返回值类型无关，只看参数列表，且参数列表必须不同（参数个数或参数类型）。调用时，根据方法参数列表的不同来区分。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 返回两个整数的和</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;<span class="keyword">return</span> x+y;&#125;</span><br><span class="line"><span class="comment">// 返回三个整数的和</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> z)</span> </span>&#123;<span class="keyword">return</span> x+y+z;&#125;</span><br><span class="line"><span class="comment">// 返回两个小数的和</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">add</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">double</span> y)</span> </span>&#123;<span class="keyword">return</span> x+y;&#125;</span><br></pre></td></tr></table></figure>
<h4 id="可变个数的形参"><a href="#可变个数的形参" class="headerlink" title="可变个数的形参"></a>可变个数的形参</h4><blockquote>
<p>JavaSE 5.0中提供了Varargs(variable number of arguments)机制，允许直接定义能和多个实参相匹配的形参。从而，可以用一种更简单的方式，来传递个数可以变的实参。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// JDK 5.0以前：采用数组形参来定义方法，传入多个同一类型的变量</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> a, String[] books)</span></span>;</span><br><span class="line"><span class="comment">// JDK 5.0：采用可变个数形参来定义方法，传入多个同一类型变量</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> a, String...books)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>声明格式：方法名(参数的类型名…参数名)</li>
<li>可变参数：方法参数部分指定类型的参数个数是可变多个：0个，1个或多个</li>
<li>可变个数形参的方法和同名的方法之间，彼此构成重载</li>
<li>可变参数方法的使用与方法参数部分使用数组是一致的</li>
<li><strong>方法的参数部分有可变形参，需要放在形参声明的最后</strong></li>
<li>在一个方法的形参位置，最多只能声明一个可变个数形参</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  DemoTest test = <span class="keyword">new</span> DemoTest();</span><br><span class="line">  test.show(<span class="number">12</span>); <span class="comment">// show(int i)</span></span><br><span class="line">  test.show(<span class="string">&quot;hello&quot;</span>); <span class="comment">// show(String s)</span></span><br><span class="line">  test.show(<span class="string">&quot;hello&quot;</span>,<span class="string">&quot;hello&quot;</span>); <span class="comment">// show(String ... s)</span></span><br><span class="line">  test.show(); <span class="comment">// show(String ... s)</span></span><br><span class="line">  test.show(<span class="keyword">new</span> String[] &#123;<span class="string">&quot;AA&quot;</span>, <span class="string">&quot;BB&quot;</span>, <span class="string">&quot;CC&quot;</span>&#125;); <span class="comment">// show(String ... s)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">  System.out.println(<span class="string">&quot;show(int i)&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">  System.out.println(<span class="string">&quot;show(String s)&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(String ... s)</span> </span>&#123;</span><br><span class="line">  System.out.println(<span class="string">&quot;show(String ... s)&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="方法参数的值传递机制"><a href="#方法参数的值传递机制" class="headerlink" title="方法参数的值传递机制"></a>方法参数的值传递机制</h4><p><strong>Java的实参值如何传入方法呢？</strong></p>
<ul>
<li>Java里方法的参数传递方式只有一种：值传递。即将实际参数值的副本(复制品)传入方法内，而参数本身不受影响。<ul>
<li>形参是基本数据类型：将实参基本数据类型变量的“数据值”传递给形参</li>
<li>形参是引用数据类型：将实参引用数据类型变量的“地址值”传递给形参</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">System.out.println(arr); <span class="comment">//地址值</span></span><br><span class="line"><span class="keyword">char</span>[] arr1 = <span class="keyword">new</span> <span class="keyword">char</span>[] &#123;<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>&#125;;</span><br><span class="line"><span class="comment">// println()方法被重载，所以输出的不是地址值</span></span><br><span class="line">System.out.println(arr1); <span class="comment">//abc</span></span><br></pre></td></tr></table></figure>

<h3 id="5、面向对象特征之一：封装性"><a href="#5、面向对象特征之一：封装性" class="headerlink" title="5、面向对象特征之一：封装性"></a>5、面向对象特征之一：封装性</h3><h4 id="四种访问权限修饰符"><a href="#四种访问权限修饰符" class="headerlink" title="四种访问权限修饰符"></a>四种访问权限修饰符</h4><ul>
<li>Java权限修饰符public、protected、private置于类的成员定义前，用来限定对象对该类成员的访问权限</li>
</ul>
<table>
<thead>
<tr>
<th align="center">修饰符</th>
<th align="center">类内部</th>
<th align="center">同一个包</th>
<th align="center">不同包的子类</th>
<th align="center">同一个工程</th>
</tr>
</thead>
<tbody><tr>
<td align="center">private</td>
<td align="center">Yes</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">(缺省)</td>
<td align="center">Yes</td>
<td align="center">Yes</td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">protected</td>
<td align="center">Yes</td>
<td align="center">Yes</td>
<td align="center">Yes</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">public</td>
<td align="center">Yes</td>
<td align="center">Yes</td>
<td align="center">Yes</td>
<td align="center">Yes</td>
</tr>
</tbody></table>
<p>对于class的权限修饰只可以用public和default(缺省)。</p>
<ul>
<li>public类可以在任意地方被访问。</li>
<li>default类只可以被同一个包内部的类访问。</li>
</ul>
<h4 id="什么是封装性？"><a href="#什么是封装性？" class="headerlink" title="什么是封装性？"></a>什么是封装性？</h4><ul>
<li>隐藏对象内部的复杂性，只对外公开简单的接口。便于外界调用，从而提高系统的可拓展性、可维护性。通俗的说，把该隐藏的隐藏起来，该暴露的暴露出去。这就是封装性的设计思想。</li>
</ul>
<h4 id="封装性的体现"><a href="#封装性的体现" class="headerlink" title="封装性的体现"></a>封装性的体现</h4><ul>
<li>Java规定的四种权限（从小到大排列）：private、缺省、protected、public</li>
<li>4种权限可以修饰类及类的内部结构：属性、方法、构造器、内部类</li>
<li>具体的，4中权限都可以用来修饰类的内部结构：属性、方法、构造器、内部类；修饰类的话，只能使用：缺省、public</li>
</ul>
<blockquote>
<p>总结：Java提供了4种权限修饰符来修饰类及类的内部结构，体现类及类的内部结构在被调用时的可见性的大小</p>
</blockquote>
<h3 id="6、类的成员之三：构造器"><a href="#6、类的成员之三：构造器" class="headerlink" title="6、类的成员之三：构造器"></a>6、类的成员之三：构造器</h3><p>构造器的作用</p>
<ul>
<li>创建对象</li>
<li>初始化对象的信息</li>
</ul>
<p>说明</p>
<ul>
<li>如果没有显示的定义类的构造器的话，则系统默认提供一个空参的构造器，默认构造器的权限修饰符与类修饰符一致</li>
<li>定义构造器的格式：权限修饰符 类名(形参列表){}</li>
<li>一个类中定义的多个构造器，彼此构成重载</li>
<li>一旦我们显式的定义了类的构造器之后，系统就不再提供默认的空参构造器</li>
<li>一个类中，至少会有一个构造器</li>
</ul>
<p>属性赋值的过程</p>
<ul>
<li>默认初始化</li>
<li>显式初始化</li>
<li>构造器中的初始化</li>
<li>通过“对象.属性”或“对象.方法”的方式赋值</li>
</ul>
<h3 id="7、拓展知识"><a href="#7、拓展知识" class="headerlink" title="7、拓展知识"></a>7、拓展知识</h3><p>JavaBean</p>
<ul>
<li>JavaBean是一种Java语言写成的可重用组件。</li>
<li>所谓JavaBean，是指符合如下标准的Java类：<ul>
<li>类是公共的</li>
<li>有一个无参的公共的构造器</li>
<li>有属性，且有对应的get、set方法</li>
</ul>
</li>
</ul>
<p>UML类图</p>
<ul>
<li><code>+</code>表示public类型，<code>-</code>表示private类型，<code>#</code>表示protected类型</li>
<li>方法的写法：方法的类型(+、-) 方法名(参数名: 参数类型): 返回值类型</li>
<li>属性：<code>:</code>前是属性名，<code>:</code>后是属性的类型</li>
</ul>
<h3 id="8、关键字：this"><a href="#8、关键字：this" class="headerlink" title="8、关键字：this"></a>8、关键字：this</h3><ul>
<li>this可以用来修饰、调用：属性、方法、构造器</li>
<li>this修饰属性和方法时可以理解为：当前对象或当前正在创建的对象<ul>
<li>在类的方法中，我们可以使用“this.属性”或者“this.方法”的方式，调用当前对象属性或方法。但是通常情况下，我们都选择省略”this.”。特殊情况下，如果方法的形参和类的属性同名时，我们必须显示的使用“this.变量”的方式，表明此变量是属性，而非形参。</li>
<li>在类的构造器中，我们可以使用“this.属性”或“this.方法”的方式，调用当前正在创建的对象属性或方法，但是通常情况下，我们都选择省略”this.”。特殊情况下，如果构造器的形参和类的属性同名时，我们必须显式的使用“this.变量”的方式，表明此变量是属性，而非形参。</li>
</ul>
</li>
<li>this调用构造器<ul>
<li>我们在类的构造器中，可以显式的使用“this(形参列表)”方式，调用本类中指定的其他构造器</li>
<li>构造器中不能通过“this(形参列表)”方式调用自己</li>
<li>如果一个类中有n个构造器，则最多有n-1个构造器中使用了“this(形参列表)”</li>
<li>规定，“this(形参列表)”必须声明在当前构造器的首行，因此构造器内部，最多只能声明一个“this(形参列表)”，用来调用其他的构造器</li>
</ul>
</li>
</ul>
<h3 id="9、关键字：package"><a href="#9、关键字：package" class="headerlink" title="9、关键字：package"></a>9、关键字：package</h3><ul>
<li>为了更好的实现项目中类的管理，提供了包的概念</li>
<li>使用package声明类或接口所属的包，声明在源文件的首行</li>
<li>包，属于标识符，遵循标识符的命名规则、规范(xxxyyyzzz)、“见名知意”</li>
<li>每“.”一次，就表示一层文件目录</li>
</ul>
<blockquote>
<p>补充：同一个包下，不能命名同名的接口、类；不同包下，可以命名同名的接口、类。</p>
</blockquote>
<h3 id="10、关键字：import"><a href="#10、关键字：import" class="headerlink" title="10、关键字：import"></a>10、关键字：import</h3><ul>
<li>在源文件中使用import显示的导入指定包下的类或接口</li>
<li>声明在包的声明和类的声明之间</li>
<li>如果需要导入多个类或者接口，那么就并列显式多个import语句即可</li>
<li>举例：可以使用java.util.*的方式，一次性导入util包下的所有的类或接口</li>
<li>如果导入的类或接口是java.lang包下的，或者是当前包下的，则可以省略此import语句</li>
<li>如果在代码中使用不同包下的同名的类。那么就需要使用类的全类名的方式指明调用的是哪个类</li>
<li>如果已导入java.a包下的类。那么如果需要使用a包的子包下的类的话，仍然需要导入。</li>
<li>import static组合的使用：调用指定类或接口下的静态的属性或方法</li>
</ul>
<h3 id="11、面向对象特征之二：继承性"><a href="#11、面向对象特征之二：继承性" class="headerlink" title="11、面向对象特征之二：继承性"></a>11、面向对象特征之二：继承性</h3><h4 id="继承性的好处"><a href="#继承性的好处" class="headerlink" title="继承性的好处"></a>继承性的好处</h4><ul>
<li>减少了代码的冗余，提高了代码的复用性</li>
<li>便于功能的拓展</li>
<li>为之后多态性的使用，提供了前提</li>
</ul>
<h4 id="继承性的说明"><a href="#继承性的说明" class="headerlink" title="继承性的说明"></a>继承性的说明</h4><ul>
<li>继承性的格式： class A extends B{}</li>
<li>体现：一旦子类A继承父类B以后，子类A中就获取了父类B中的声明的所有的属性和方法。特别的，父类中声明为private的属性或方法，子类继承父类以后，仍然认为获取了父类中的私有的结构。只是因为封装性的影响，使得子类不能直接调用父类的结构而已。</li>
<li>子类继承父类以后，还可以声明自己特有的属性或方法：实现功能的拓展</li>
</ul>
<h4 id="Java中关于继承性的规定"><a href="#Java中关于继承性的规定" class="headerlink" title="Java中关于继承性的规定"></a>Java中关于继承性的规定</h4><ul>
<li>一个类可以被多个子类继承</li>
<li>Java中类的单继承性：一个类只能有一个父类</li>
<li>子父类是相对的概念</li>
<li>子类直接继承的父类称为直接父类；间接继承的父类称为间接父类</li>
<li>子类继承父类以后，就获取了直接父类以及所有间接父类中声明的属性和方法</li>
</ul>
<p>补充说明</p>
<ul>
<li>如果我们没有显示的声明一个类的父类的话，则此类继承于java.lang.Object类</li>
<li>所有的java类（除java.lang.Object类之外）都直接或间接的继承于java.lang.Object类</li>
<li>意味着，所有的java类都具有java.lang.Object类声明的功能。</li>
</ul>
<h4 id="方法的重写-override-overwrite"><a href="#方法的重写-override-overwrite" class="headerlink" title="方法的重写(override/overwrite)"></a>方法的重写(override/overwrite)</h4><ul>
<li>重写：子类继承父类以后，可以对父类中同名同参数的方法，进行覆盖操作</li>
<li>应用：重写以后，当创建子类对象以后，通过子类对象调用子父类中的同名同参数的方法时，实际执行的是子类重写父类的方法</li>
<li>重写的规定<ul>
<li>子类重写的方法的方法名和形参列表与父类被重写的方法的方法名和形参列表相同</li>
<li>子类重写的方法的权限修饰符不小于父类被重写的方法的权限修饰符<ul>
<li>特殊情况：子类不能重写父类中声明为private权限的方法</li>
</ul>
</li>
<li>返回值类型：<ul>
<li>父类被重写的方法的返回值类型是void，则子类重写的方法的返回值类型只能是void</li>
<li>父类被重写的方法的返回值类型是A类型，则子类重写的方法的返回值类型可以是A类或A类的子类</li>
<li>父类被重写的方法的返回值类型是基本数据类型(比如：double)，则子类重写的方法的返回值类型必须是相同的。</li>
</ul>
</li>
<li>子类重写的方法抛出的异常类型不大于父类被重写的方法抛出的异常类型</li>
<li>子类和父类中的同名同参数的方法要么都声明为非static的（考虑重写），要么都声明为static的（不是重写）。</li>
</ul>
</li>
</ul>
<h3 id="12、关键字：super"><a href="#12、关键字：super" class="headerlink" title="12、关键字：super"></a>12、关键字：super</h3><ul>
<li>super可以用来调用：属性、方法、构造器</li>
<li>super的使用<ul>
<li>我们可以在子类的方法或构造器中。通过使用”super.属性”或”super.方法”的方式，显式的调用父类中声明的属性或方法。但是，通常情况下，我们习惯省略”super.”</li>
<li>特殊情况：当子类和父类中定义了同名的属性时，我们要想要在子类中调用父类中声明的属性，则必须显式的使用”super.属性”的方式，表明调用的是父类中声明的属性，否则默认是调用子类的属性。</li>
<li>特殊情况：当子类重写了父类中的方法以后，我们想在子类中的方法中调用父类中被重写的方法时，则必须显式使用”super.方法”的方式，表明调用的是父类中被重写的方法，否则默认是调用子类的方法。</li>
</ul>
</li>
<li>super调用构造器<ul>
<li>我们可以在子类的构造器中显式的使用”super(形参列表)”的方式，调用父类中声明的指定的构造器</li>
<li>“super(形参列表)”的使用，必须声明在子类构造器的首行</li>
<li>我们在类的构造器中，针对于”this(形参列表)”或”super(形参列表)”只能二选一，不能同时出现</li>
<li>在构造器的首行，没有显示的声明”this(形参列表)”或”super(形参列表)”，则默认调用的是父类中的空参的构造器</li>
<li>在类的多个构造器中，至少有一个类的构造器中使用了”super(形参列表)”，调用父类中的构造器</li>
</ul>
</li>
</ul>
<h4 id="子类对象实例化的全过程"><a href="#子类对象实例化的全过程" class="headerlink" title="子类对象实例化的全过程"></a>子类对象实例化的全过程</h4><ul>
<li>从结果上来看：（继承性）<ul>
<li>子类继承父类以后，就获取了父类中声明的属性或方法。</li>
<li>创建子类的对象，在堆空间中，就会加载所有父类中声明的属性</li>
</ul>
</li>
<li>从过程上来看：<ul>
<li>当我们通过父类的构造器创建子类对象时，我们一定会直接或间接的调用其父类的构造器，进而调用父类的父类的构造器，直到调用了java.lang.Object类中空参的构造器为止。正因为加载过所有的父类的结构，所以才可以看到内存中有父类中的结构，子类对象才可以考虑进行调用。</li>
</ul>
</li>
<li>明确：虽然创建子类对象时，调用了父类的构造器，但是自始至终就创建过一个对象，即为new的子类对象。</li>
</ul>
<h3 id="13、面向对象特征之三：多态性"><a href="#13、面向对象特征之三：多态性" class="headerlink" title="13、面向对象特征之三：多态性"></a>13、面向对象特征之三：多态性</h3><ul>
<li>理解多态性：可以理解为一个事物的多种形态。</li>
<li>何为多态性：<ul>
<li>对象的多态性：父类的引用指向子类的对象（或子类的对象赋给父类的引用）</li>
</ul>
</li>
<li>多态的使用，虚拟方法调用<ul>
<li>有了对象的多态性以后，我们在编译期，只能调用父类中声明的方法，但在运行期，我们实际执行的是子类重写父类的方法。</li>
<li>总结：编译，看左边；运行，看右边。</li>
</ul>
</li>
<li>多态性的使用前提：<ul>
<li>类的继承关系</li>
<li>方法的重写</li>
</ul>
</li>
<li>对象的多态性，只适用于方法，不适用于属性（编译和运行都看左边）</li>
</ul>
<h4 id="区分方法的重载与重写"><a href="#区分方法的重载与重写" class="headerlink" title="区分方法的重载与重写"></a>区分方法的重载与重写</h4><ul>
<li>二者定义的不同：<ul>
<li>重载：在同一个类中，允许存在一个以上的同名方法，只要它们的参数个数或者参数类型不同即可。</li>
<li>重写：子类继承父类以后，可以对父类中同名同参数的方法，进行覆盖操作</li>
</ul>
</li>
<li>从编译和运行的角度看：<ul>
<li>重载，是指允许存在多个同名方法，而这些方法的参数不同。编译器根据方法不同的参数表，对同名方法的名称做修饰。对于编译器而言，这些同名方法就成了不同的方法。它们的调用地址在编译期就绑定了。Java的重载是可以包括父类和子类的，即子类可以重载父类的同名不同参数的方法。</li>
<li>所以：对于重载而言，在方法调用之前，编译期就已经确定了所要调用的方法，这称为“早绑定”或“静态绑定”</li>
<li>而对于多态，只有等到方法调用的那一刻，解释器运行器才会确定所要调用的具体方法，这称为“晚绑定”或“动态绑定”。</li>
</ul>
</li>
</ul>
<h4 id="instanceof-操作符"><a href="#instanceof-操作符" class="headerlink" title="instanceof 操作符"></a>instanceof 操作符</h4><ul>
<li>instanceof 关键字的使用：a instanceof A：判断对象a是否是类A的实例。如果是，返回true；如果不是，返回false</li>
<li>使用情境： 为了避免在向下转型时出现ClassCastException的异常，我们在向下转型之前，先进行instanceof的判断，一旦返回true，就进行向下转型。如果返回false，就不进行向下转型。</li>
<li>如果类B是类A的父类，且a instanceof A返回true，则a instanceof B也返回true</li>
</ul>
<h4 id="和equals的区别"><a href="#和equals的区别" class="headerlink" title="==和equals的区别"></a>==和equals的区别</h4><ul>
<li>==既可以比较基本类型也可以比较引用类型。对于基本类型就是比较值，对于引用类型就是比较内存地址</li>
<li>equals的话，它是属于java.lang.Object类里面的方法，如果该方法没有被重写过默认也是==；我们可以看到String等类的equals方法是被重写过的，而且String类在日常开发中用的比较多，久而久之，形成了equals是比较值的错误观点</li>
<li>具体要看自定义类里有没有重写Object的equals方法来判断</li>
<li>通常情况下，重写equals方法，会比较类中的相应属性是否都相等</li>
</ul>
<h4 id="Java中的JUnit单元测试"><a href="#Java中的JUnit单元测试" class="headerlink" title="Java中的JUnit单元测试"></a>Java中的JUnit单元测试</h4><ul>
<li>创建Java类，进行单元测试。此时的Java类要求：<ul>
<li>此类是public的</li>
<li>此类提供公共的无参的构造器</li>
</ul>
</li>
<li>此类中声明单元测试方法。此时的单元测试方法的权限是public，没有返回值，没有形参</li>
<li>此单元测试方法上需要声明注解：@Test</li>
<li>写完代码后，左键双击单元测试方法名，右键：run as - JUnit Test</li>
<li>说明：如果执行结果没有任何异常：绿条；如果执行结果出现异常：红条</li>
</ul>
<h3 id="14、包装类-Wrapper-的使用"><a href="#14、包装类-Wrapper-的使用" class="headerlink" title="14、包装类(Wrapper)的使用"></a>14、包装类(Wrapper)的使用</h3><table>
<thead>
<tr>
<th align="center">基本数据类型</th>
<th align="center">包装类</th>
</tr>
</thead>
<tbody><tr>
<td align="center">byte</td>
<td align="center">Byte</td>
</tr>
<tr>
<td align="center">short</td>
<td align="center">Short</td>
</tr>
<tr>
<td align="center">int</td>
<td align="center"><strong>Integer</strong></td>
</tr>
<tr>
<td align="center">long</td>
<td align="center">Long</td>
</tr>
<tr>
<td align="center">float</td>
<td align="center">Float</td>
</tr>
<tr>
<td align="center">double</td>
<td align="center">Double</td>
</tr>
<tr>
<td align="center">boolean</td>
<td align="center">Boolean</td>
</tr>
<tr>
<td align="center">char</td>
<td align="center"><strong>Character</strong></td>
</tr>
</tbody></table>
<blockquote>
<p>Byte、Short、Integer、Long、Float、Double的父类为Number；Boolean、Character的父类为Object</p>
</blockquote>
<h4 id="基本类型、包装类与String类间的转换"><a href="#基本类型、包装类与String类间的转换" class="headerlink" title="基本类型、包装类与String类间的转换"></a>基本类型、包装类与String类间的转换</h4><ul>
<li>基本数据类型 –&gt; 包装类：自动装箱</li>
<li>包装类 –&gt; 基本数据类型：自动拆箱</li>
<li>基本数据类型 –&gt; String类：String类的valueOf()方法</li>
<li>String类 –&gt; 基本数据类型：调用相应包装类的parseXxx(String)静态方法</li>
<li>包装类 –&gt; String类：包装类对象的toString()方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用parseBoolean时，如果s非空且在忽略大小写的情况下等于true，则返回true；否则返回false</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">parseBoolean</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;true&quot;</span>.equalsIgnoreCase(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 三元运算符运算过程中会尽量使两边的类型一致，所以new Integer(1)被自动提升了类型</span></span><br><span class="line">Object o1 = <span class="keyword">true</span> ? <span class="keyword">new</span> Integer(<span class="number">1</span>) : <span class="keyword">new</span> Double(<span class="number">2.0</span>);</span><br><span class="line">System.out.println(o1); <span class="comment">// 1.0</span></span><br><span class="line"></span><br><span class="line">Object o2;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">  o2 = <span class="keyword">new</span> Integer(<span class="number">1</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  o2 = <span class="keyword">new</span> Double(<span class="number">2.0</span>);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(o2); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
<ul>
<li>Integer内部定义了IntegerCache结构，IntegerCache中定义了Integer[]，保存了从-128到127范围的整数。如果我们使用自动装箱的方式，给Integer赋值的范围在-128到127范围内时，可以直接使用数组中的元素，不用再去new了。目的为了提高效率</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer i = <span class="keyword">new</span> Integer(<span class="number">1</span>);</span><br><span class="line">Integer j = <span class="keyword">new</span> Integer(<span class="number">1</span>);</span><br><span class="line">System.out.println(i == j);<span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">Integer m = <span class="number">1</span>;</span><br><span class="line">Integer n = <span class="number">1</span>;</span><br><span class="line">System.out.println(m == n);<span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">Integer x = <span class="number">128</span>;</span><br><span class="line">Integer y = <span class="number">128</span>;</span><br><span class="line">System.out.println(x == y);<span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<h3 id="15、关键字：static"><a href="#15、关键字：static" class="headerlink" title="15、关键字：static"></a>15、关键字：static</h3><ul>
<li>使用static修饰属性：静态变量（或类变量）<ul>
<li>属性，按是否使用static修饰，又分为：静态属性 vs 非静态属性（实例变量）<ul>
<li>实例变量：我们创建了类的多个对象，每个对象都独立拥有一套类中的非静态属性。当修改其中一个对象的非静态属性时，不会导致其他对象中同样的属性值修改</li>
<li>静态变量：我们创建了类的多个对象，多个对象共享同一个静态变量。当通过某一个对象修改静态变量时，会导致其他对象调用此静态变量时，是修改过了的</li>
</ul>
</li>
<li>static修饰属性的其他说明<ul>
<li>静态变量随着类的加载而加载。可以通过”类.静态变量”的方式进行调用</li>
<li>静态变量的加载要早于对象的创建</li>
<li>由于类只会加载一次，则静态变量在内存中也只会存在一份：存在方法区的静态域中</li>
</ul>
</li>
</ul>
</li>
<li>使用static修饰方法：静态方法<ul>
<li>随着类的加载而加载，可以通过”类.静态方法”的方式进行调用</li>
<li>静态方法中，只能调用静态的方法或属性；非静态方法中，既可以调用非静态的方法或属性，也可以调用静态的方法或属性</li>
</ul>
</li>
<li>static注意点<ul>
<li>在静态的方法内，不能使用this关键字、super关键字</li>
</ul>
</li>
<li>开发中，如何确定一个属性是否要声明为static的？<ul>
<li>属性可以被多个对象所共享的，不会随着对象的不同而不同</li>
<li>类中的常量也常常声明为static</li>
</ul>
</li>
<li>开发中，如何确定一个方法是否要声明为static的？<ul>
<li>操作静态属性的方法，通常设置为static的</li>
<li>工具类中的方法，习惯上声明为static的</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 单例设计模式：</span></span><br><span class="line"><span class="comment"> * 1、所谓的类的单例设计模式，就是采取一定的方法保证在整个的软件系统中，对某个类只能存在一个对象实例。</span></span><br><span class="line"><span class="comment"> * 2、如何实现？</span></span><br><span class="line"><span class="comment"> * 	饿汉式 vs 懒汉式</span></span><br><span class="line"><span class="comment"> * 3、区分饿汉式和懒汉式</span></span><br><span class="line"><span class="comment"> * 	饿汉式：</span></span><br><span class="line"><span class="comment"> * 		坏处：对象加载时间过长。</span></span><br><span class="line"><span class="comment"> * 		好处：饿汉式是线程安全的</span></span><br><span class="line"><span class="comment"> * 	懒汉式：</span></span><br><span class="line"><span class="comment"> * 		好处：延迟对象的创建。</span></span><br><span class="line"><span class="comment"> * 		目前的写法坏处：线程不安全。(到多线程内容时，再修改)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 饿汉式</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bank</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 1、私有化类的构造器</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="title">Bank</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 2、内部创建类的对象</span></span><br><span class="line">	<span class="comment">// 4、要求此对象也必须声明为静态的</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> Bank instance = <span class="keyword">new</span> Bank();</span><br><span class="line">	<span class="comment">// 3、提供公共的静态的方法，返回类的对象</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Bank <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> instance;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 懒汉式</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Order</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 1、私有化类的构造器</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="title">Order</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 2、声明当前类对象，没有初始化</span></span><br><span class="line">	<span class="comment">// 4、此对象也必须声明为static的</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> Order instance = <span class="keyword">null</span>;</span><br><span class="line">	<span class="comment">// 3、声明public、static的返回当前类对象的方法</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Order <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">			instance = <span class="keyword">new</span> Order();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> instance;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="16、类的成员之四：代码块（或初始化块）"><a href="#16、类的成员之四：代码块（或初始化块）" class="headerlink" title="16、类的成员之四：代码块（或初始化块）"></a>16、类的成员之四：代码块（或初始化块）</h3><ul>
<li>代码块的作用：用来初始化类、对象</li>
<li>代码块如果有修饰的话，只能使用static</li>
<li>分类：静态代码块 VS 非静态代码块</li>
<li>静态代码块<ul>
<li>内部可以有输出语句</li>
<li>随着类的加载而执行，而且只执行一次</li>
<li>作用：初始化类的信息</li>
<li>如果一个类中定义了多个静态代码块，则按照声明的先后顺序执行</li>
<li>静态代码块的执行要优先于非静态代码块的执行</li>
<li>静态代码块内只能调用静态的属性、静态的方法，不能调用非静态的结构</li>
</ul>
</li>
<li>非静态代码块<ul>
<li>内部可以有输出语句</li>
<li>随着对象的创建而执行</li>
<li>每创建一个对象，就执行一次非静态代码块</li>
<li>作用：可以在创建对象时，对对象的属性等进行初始化</li>
<li>如果一个类中定义了多个非静态代码块，则按照声明的先后顺序执行</li>
<li>非静态代码块内可以调用静态的属性、静态的方法，或非静态的属性、非静态的方法</li>
</ul>
</li>
</ul>
<blockquote>
<p>总结：由夫及子，静态先行</p>
</blockquote>
<h4 id="属性赋值的过程"><a href="#属性赋值的过程" class="headerlink" title="属性赋值的过程"></a>属性赋值的过程</h4><ul>
<li>默认初始化</li>
<li>显式初始化/在代码块中赋值</li>
<li>构造器中初始化</li>
<li>有了对象以后，可以通过”对象.属性”或”对象.方法”的方式，进行赋值</li>
</ul>
<blockquote>
<p>显式初始化和在代码块中赋值的顺序先后取决于代码先后顺序</p>
</blockquote>
<h3 id="17、关键字：final"><a href="#17、关键字：final" class="headerlink" title="17、关键字：final"></a>17、关键字：final</h3><ul>
<li>final可以用来修饰的结构：类、方法、变量</li>
<li>final用来修饰一个类：此类不能被其他类所继承。</li>
<li>final用来修饰方法：表明此方法不可以被重写</li>
<li>final用来修饰变量：此时的”变量”就称为是一个常量<ul>
<li>final修饰属性：可以考虑赋值的位置有：显示初始化、代码块中初始化、构造器中初始化</li>
<li>final修饰局部变量：尤其是使用final修饰形参时，表明此形参是一个常量。当我们调用此方法时，给常量形参赋一个实参。一旦赋值以后，就只能在方法体内使用此形参，但不能进行重新赋值。</li>
</ul>
</li>
</ul>
<blockquote>
<p>static final 用来修饰属性：全局变量</p>
</blockquote>
<h3 id="18、关键字：abstract"><a href="#18、关键字：abstract" class="headerlink" title="18、关键字：abstract"></a>18、关键字：abstract</h3><ul>
<li>abstract可以用来修饰的结构：类、方法</li>
<li>abstract修饰类：抽象类<ul>
<li>此类不能实例化</li>
<li>抽象类中一定要有构造器，便于子类实例化时调用(涉及：子类对象实例化的全过程)</li>
<li>开发中，都会提供抽象类的子类，让子类对象实例化，完成相关的操作</li>
</ul>
</li>
<li>abstract修饰方法：抽象方法<ul>
<li>抽象方法只要方法的声明，没有方法体</li>
<li>包含抽象方法的类，一定是一个抽象类。反之，抽象类中可以没有抽象方法的。</li>
<li>若子类重写了父类中的所有抽象方法后，此子类才可以实例化；若子类没有重写父类中的所有的抽象方法，则此子类也是一个抽象类，需要使用abstract修饰</li>
</ul>
</li>
</ul>
<blockquote>
<p>注意点：abstract不能用来修饰：属性、构造器等结构；abstract不能用来修饰私有方法、静态方法、final的方法、final的类</p>
</blockquote>
<h4 id="匿名对象"><a href="#匿名对象" class="headerlink" title="匿名对象"></a>匿名对象</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">method(<span class="keyword">new</span> Student()); <span class="comment">//匿名对象</span></span><br><span class="line"></span><br><span class="line">Worker worker = <span class="keyword">new</span> Worker();</span><br><span class="line">method1(worker); <span class="comment">//非匿名的类非匿名的对象</span></span><br><span class="line"></span><br><span class="line">method1(<span class="keyword">new</span> Worker()); <span class="comment">//非匿名的类匿名的对象</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建匿名子类的非匿名对象</span></span><br><span class="line">Person p = <span class="keyword">new</span> Person() &#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;吃东西&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建匿名子类的匿名对象</span></span><br><span class="line">method1(<span class="keyword">new</span> Person() &#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;吃东西&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="19、关键字：interface"><a href="#19、关键字：interface" class="headerlink" title="19、关键字：interface"></a>19、关键字：interface</h3><ul>
<li>Java中，接口和类是并列的两个结构</li>
<li>如何定义接口，定义接口中的成员<ul>
<li>JDK7及以前：只能定义全局变量和抽象方法<ul>
<li>全局常量：public static final的，但是书写时，可以省略不写</li>
<li>抽象方法：public abstract的</li>
</ul>
</li>
<li>JDK8：除了定义全局常量和抽象方法之外，还可以定义静态方法、默认方法</li>
</ul>
</li>
<li>接口中不能定义构造器！意味着接口不可以实例化</li>
<li>Java开发中，接口通过让类去实现(implements)的方式来使用。如果实现类覆盖了接口中的所有抽象方法，则此实现类就可以实例化；如果实现类没有覆盖接口中所有的抽象方法，则此实现类仍为一个抽象类。</li>
<li>Java类可以实现多个接口：弥补了Java单继承性的局限性。格式：class AA extends BB implements CC,DD,EE</li>
<li>接口与接口之间可以继承，而且可以多继承。格式：interface AA extends BB,CC</li>
<li>接口的具体使用，体现了多态性</li>
<li>接口，实际上可以看做是一种规范</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Flyable</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 全局变量</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_SPEED = <span class="number">7900</span>;</span><br><span class="line">  <span class="keyword">int</span> MIN_SPEED = <span class="number">1</span>; <span class="comment">// 省略了public static final</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 抽象方法</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="comment">// 省略了public abstract</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="comment">// Interfaces cannot have constructors</span></span><br><span class="line">  <span class="comment">// public Flyable() &#123;&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> x = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> <span class="keyword">extends</span> <span class="title">B</span> <span class="keyword">implements</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pX</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 编译不通过，因为x是不明确的</span></span><br><span class="line">    <span class="comment">// System.out.println(x);</span></span><br><span class="line">    System.out.println(<span class="keyword">super</span>.x); <span class="comment">// 1</span></span><br><span class="line">    System.out.println(A.x); <span class="comment">// 0</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>JDK8：除了定义全局常量和抽象方法之外，还可以定义静态方法、默认方法</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CompareA</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 静态方法</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;CompareA：北京&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 默认方法</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">default</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;CompareA：上海&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">method3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;CompareA：上海&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubClass</span> <span class="keyword">extends</span> <span class="title">SuperClass</span> <span class="keyword">implements</span> <span class="title">CompareA</span>, <span class="title">CompareB</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;SubClass：上海&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;SubClass：深圳&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 知识点5：如何在子类(或实现类)的方法中调用父类、接口中被重写的方法</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">myMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    method3();<span class="comment">//调用了自己定义的重写的方法</span></span><br><span class="line">    <span class="keyword">super</span>.method3(); <span class="comment">//调用的是父类中声明的</span></span><br><span class="line">    <span class="comment">//调用接口中的默认方法</span></span><br><span class="line">    CompareA.<span class="keyword">super</span>.method3();</span><br><span class="line">    CompareB.<span class="keyword">super</span>.method3();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SubClassTest</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    SubClass s = <span class="keyword">new</span> SubClass();</span><br><span class="line">    <span class="comment">// 知识点1：接口中定义的静态方法，只能通过接口来调用</span></span><br><span class="line">    <span class="comment">// s.method1(); // 编译错误</span></span><br><span class="line">    <span class="comment">// SubClass.method1(); // 编译错误</span></span><br><span class="line">    CompareA.method1();</span><br><span class="line">    <span class="comment">// 知识点2：通过实现类的对象，可以调用接口中的默认方法。</span></span><br><span class="line">    <span class="comment">// 如果实现类重写了接口中的默认方法，调用时，仍然调用的是重写以后的方法。</span></span><br><span class="line">    s.method2();</span><br><span class="line">    <span class="comment">// 知识点3：如果子类（或实现类）继承的父类和实现的接口中声明了同名同参数的默认方法,</span></span><br><span class="line">    <span class="comment">// 那么子类在没有重写此方法的情况下，默认调用的是父类中的同名同参数的方法(类优先原则)。</span></span><br><span class="line">    <span class="comment">// 知识点4：如果实现类实现了多个接口，而这多个接口中定义了同名同参数的默认方法，</span></span><br><span class="line">    <span class="comment">//那么在实现类没有重写此方法的情况下，会报错——接口冲突</span></span><br><span class="line">    <span class="comment">//这就需要我们必须在实现类中重写此方法</span></span><br><span class="line">    s.method3();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="20、类的内部成员之五：内部类"><a href="#20、类的内部成员之五：内部类" class="headerlink" title="20、类的内部成员之五：内部类"></a>20、类的内部成员之五：内部类</h3><ul>
<li><p>Java中允许将一个类A声明在另一个类B中，则类A就是内部类，类B称为外部类</p>
</li>
<li><p>内部类的分类：成员内部类（静态、非静态） VS 局部内部类（方法内、代码块内、构造器内）</p>
</li>
<li><p>成员内部类：</p>
<ul>
<li>作为外部类的成员：<ul>
<li>调用外部类的结构</li>
<li>可以被static修饰</li>
<li>可以被4种不同的权限修饰</li>
</ul>
</li>
<li>作为一个类：<ul>
<li>类内可以定义属性、方法、构造器等</li>
<li>可以被final修饰，表示此类不能被继承。言外之意，不使用final就可以被继承</li>
<li>可以被abstract修饰</li>
</ul>
</li>
</ul>
</li>
<li><p>如何实例化成员内部类的对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建Dog实例（静态的成员内部类）：</span></span><br><span class="line">Person.Dog dog = <span class="keyword">new</span> Person.Dog();</span><br><span class="line">dog.show();</span><br><span class="line"><span class="comment">// 创建Bird实例（非静态的成员内部类）：</span></span><br><span class="line"><span class="comment">// Person.Bird bird = new Person.Bird(); // 编译错误</span></span><br><span class="line">Person p = <span class="keyword">new</span> Person();</span><br><span class="line">Person.Bird bird = p.<span class="function">new <span class="title">Bird</span><span class="params">()</span></span>;</span><br><span class="line">bird.sing();</span><br></pre></td></tr></table></figure></li>
<li><p>如何在成员内部类中区分调用外部类的结构</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sing</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 调用外部类的非静态方法</span></span><br><span class="line">  Person.<span class="keyword">this</span>.eat();</span><br><span class="line">  eat();</span><br><span class="line">  <span class="comment">// 调用外部类的非静态属性</span></span><br><span class="line">  System.out.println(age);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">  System.out.println(name); <span class="comment">// 方法的形参</span></span><br><span class="line">  System.out.println(<span class="keyword">this</span>.name); <span class="comment">// 内部类的属性</span></span><br><span class="line">  System.out.println(Person.<span class="keyword">this</span>.name); <span class="comment">// 外部类的属性</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>开发中局部内部类的使用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Comparable <span class="title">getComparable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> Comparable() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>在局部内部类的方法中(比如：show)，如果要调用外部类所声明的方法(比如：method)中的局部变量(比如：num)的话，要求此局部变量声明为final的。</p>
<ul>
<li>JDK 7及之前版本：要求此局部变量显式的声明为final的</li>
<li>JDK 8及之后版本：可以省略final的声明<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">//局部变量-JDK 8及之后，final可以省略</span></span><br><span class="line">  <span class="keyword">final</span> <span class="keyword">int</span> num = <span class="number">10</span>;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">AA</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="comment">// num = 20;</span></span><br><span class="line">      System.out.print(num);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>成员内部类和局部内部类，在编译之后，都会生成字节码文件。格式：</p>
<ul>
<li>成员内部类：外部类$内部类名.class</li>
<li>局部内部类：外部类$数字 内部类名.class</li>
</ul>
</li>
</ul>
<h2 id="三、异常处理"><a href="#三、异常处理" class="headerlink" title="三、异常处理"></a>三、异常处理</h2><h3 id="1、异常体系结构"><a href="#1、异常体系结构" class="headerlink" title="1、异常体系结构"></a>1、异常体系结构</h3><ul>
<li>java.lang.Throwable<ul>
<li>java.lang.Error：一般不编写针对性的代码进行处理</li>
<li>java.lang.Exception：可以进行异常的处理<ul>
<li>编译时异常(checked)<ul>
<li>IOException<ul>
<li>FileNotFoundException</li>
</ul>
</li>
<li>ClassNotFoundException</li>
</ul>
</li>
<li>运行时异常(unchecked)<ul>
<li>NullPointerException</li>
<li>ArrayIndexOutOfBoundsException</li>
<li>ClassCastException</li>
<li>NumberFormatException</li>
<li>InputMismatchException</li>
<li>ArithmeticException</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="2、异常处理的方式一：try-catch-finally"><a href="#2、异常处理的方式一：try-catch-finally" class="headerlink" title="2、异常处理的方式一：try-catch-finally"></a>2、异常处理的方式一：try-catch-finally</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="comment">//可能出现异常的代码</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (异常类型<span class="number">1</span> 变量名<span class="number">1</span>) &#123;</span><br><span class="line">  <span class="comment">//处理异常的方式1</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (异常类型<span class="number">2</span> 变量名<span class="number">2</span>) &#123;</span><br><span class="line">  <span class="comment">//处理异常的方式2</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (异常类型<span class="number">3</span> 变量名<span class="number">3</span>) &#123;</span><br><span class="line">  <span class="comment">//处理异常的方式3</span></span><br><span class="line">&#125;</span><br><span class="line">......</span><br><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line">  <span class="comment">//一定会执行的代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="try-catch-finally的说明"><a href="#try-catch-finally的说明" class="headerlink" title="try-catch-finally的说明"></a>try-catch-finally的说明</h4><ul>
<li>使用try将可能出现异常代码包装起来。在执行过程之，一旦出现异常，就会生成一个对应异常类的对象，根据此对象的类型，去catch中进行匹配</li>
<li>一旦try中的异常对象匹配到某一个catch时，就进入catch中进行异常的处理。一旦处理完成，就跳出当前的try-catch结构（在没有写finally的情况）。继续执行其后的代码</li>
<li>catch中的异常类型如果没有子父类关系，则谁声明在上，谁声明在下无所谓；如果满足子父类关系，则要求子类一定声明在父类的上面，否则报错。</li>
<li>常用的异常对象处理的方式：<ul>
<li>String getMessage()</li>
<li>printStackTrace()</li>
</ul>
</li>
<li>在try结构中声明的变量，在出了try结构以后，就不能再被调用</li>
<li>try-catch-finally结构可以嵌套</li>
</ul>
<h4 id="try-catch-finally的体会"><a href="#try-catch-finally的体会" class="headerlink" title="try-catch-finally的体会"></a>try-catch-finally的体会</h4><ul>
<li>使用try-catch-finally处理编译时异常，使得程序在编译时就不再报错，但是运行时仍可能报错。相当于我们使用try-catch-finally将一个编译时可能出现的异常，延迟到运行时出现。</li>
<li>开发中，由于运行时异常比较常见，所以我们通常就不针对运行时异常编写try-catch-finally了。针对编译时异常，我们一定要考虑异常的处理。</li>
</ul>
<h4 id="finally的说明"><a href="#finally的说明" class="headerlink" title="finally的说明"></a>finally的说明</h4><ul>
<li>finally是可选的</li>
<li>finally中声明的是一定会被执行的代码。即使catch中又出现异常了，try中有return语句，catch中有return语句等情况。</li>
<li>像数据库连接、输入输出流、网络编程Socket等资源，JVM是不能自动的回收的，我们需要自己手动的进行资源的释放。此时的资源释放，就需要声明在finally中。</li>
</ul>
<h3 id="3、异常处理的方式二：throws-异常类型"><a href="#3、异常处理的方式二：throws-异常类型" class="headerlink" title="3、异常处理的方式二：throws + 异常类型"></a>3、异常处理的方式二：throws + 异常类型</h3><ul>
<li>“throws + 异常类型”写在方法的声明处。指明此方法执行时，可能会抛出的异常类型。一旦当方法体执行时，出现异常，仍会在异常代码处生成一个异常类的对象，此对象满足throws后异常类型时，就会被抛出。异常代码后续的代码，就不再执行！</li>
<li>try-catch-finally：真正的将异常给处理掉了；throws的方式只是将异常抛给了方法的调用者，并没有真正将异常处理掉。</li>
<li>开发中如何选择使用try-catch-finally还是使用throws？<ul>
<li>如果父类中被重写的方法没有throws方式处理异常，则子类重写的方法也不能使用throws，意味着如果子类重写的方法中有异常，必须使用try-catch-finally方式处理</li>
<li>执行的方法a中，先后又调用了另外的几个方法，这几个方法是递进关系执行的。我们建议这几个方法使用throws的方式进行处理。而执行的方法a可以考虑是用try-catch-finally方式进行处理。</li>
</ul>
</li>
</ul>
<h3 id="4、自定义异常类"><a href="#4、自定义异常类" class="headerlink" title="4、自定义异常类"></a>4、自定义异常类</h3><ul>
<li>继承于现有的异常结构：RuntimeException、Exception</li>
<li>提供全局常量：serialVersionUID</li>
<li>提供重载的构造器</li>
</ul>
<h3 id="5、附加：Eclipse中的快捷键"><a href="#5、附加：Eclipse中的快捷键" class="headerlink" title="5、附加：Eclipse中的快捷键"></a>5、附加：Eclipse中的快捷键</h3><ul>
<li>补全代码的声明：alt + /</li>
<li>快速修饰：ctrl + l</li>
<li>批量导包：ctrl + shift + o</li>
<li>使用单行注释：ctrl + /</li>
<li>使用多行注释：ctrl + shift + /</li>
<li>取消多行注释：ctrl + shift + \</li>
<li>复制指定行的代码：ctrl + alt + down 或 ctrl + alt + up</li>
<li>删除指定行的代码：ctrl + d</li>
<li>上下移动代码：alt + up 或 alt + down</li>
<li>切换到下一行代码空位：shift + enter</li>
<li>切换到上一行代码空位：ctrl + shift + enter</li>
<li>如何查看源码：ctrl + 选中指定的结构 或 ctrl + shift + t</li>
<li>退回到前一个编辑的页面：alt + left</li>
<li>进入到下一个编辑的页面（针对与上面那条来说的）：alt + right</li>
<li>光标选中指定的类，查看继承树结构：ctrl + t</li>
<li>复制代码：ctrl + c</li>
<li>撤销：ctrl + z</li>
<li>反撤销：ctrl + y</li>
<li>剪切：ctrl + x</li>
<li>粘贴：ctrl + v</li>
<li>保存：ctrl + s</li>
<li>全选：ctrl + a</li>
<li>格式化代码：ctrl + shift + f</li>
<li>选中数行，整体往后移动：tab</li>
<li>选中数行，整体往前移动：shift + tab</li>
<li>在当前类中，显示类结构，并支持搜索指定的方法、属性等：ctrl + o</li>
<li>批量修改指定的变量名、方法名、类名等：alt + shift + r</li>
<li>选中的结构的大小写的切换：变成大写：ctrl + shift + x</li>
<li>选中的结构的大小写的切换：变成小写：ctrl + shift + y</li>
<li>调出生成getter/setter/构造器等结构：alt + shift + s</li>
<li>显示当前选择资源(工程 or 文件)的属性：alt + enter</li>
<li>快速查找：参照选中的Word快速定位到下一个：ctrl + k</li>
<li>关闭当前窗口：ctrl + w</li>
<li>关闭所有的窗口：ctrl + shift + w</li>
<li>查看指定的机构使用过的地方：ctrl + alt + g</li>
<li>查找与替换：ctrl + f</li>
<li>最大化当前的View：ctrl + m</li>
<li>直接定位到当前行的首位：home</li>
<li>直接定位到当前行的末位：end</li>
</ul>
<h1 id="Java高级编程"><a href="#Java高级编程" class="headerlink" title="Java高级编程"></a>Java高级编程</h1><h2 id="一、多线程"><a href="#一、多线程" class="headerlink" title="一、多线程"></a>一、多线程</h2><h3 id="1、基本概念：程序、进程、线程"><a href="#1、基本概念：程序、进程、线程" class="headerlink" title="1、基本概念：程序、进程、线程"></a>1、基本概念：程序、进程、线程</h3><h4 id="1-1、程序"><a href="#1-1、程序" class="headerlink" title="1.1、程序"></a>1.1、程序</h4><ul>
<li>概念：是为完成特定任务、用某种语言编写的一组指令的集合。即指一段静态的代码。</li>
</ul>
<h4 id="1-2、进程"><a href="#1-2、进程" class="headerlink" title="1.2、进程"></a>1.2、进程</h4><ul>
<li>概念：程序的一次执行过程，或是正在运行的一个程序。</li>
<li>说明：进程作为资源分配的单位，系统在运行时会为每个进程分配不同的内存区域。</li>
</ul>
<h4 id="1-3、线程"><a href="#1-3、线程" class="headerlink" title="1.3、线程"></a>1.3、线程</h4><ul>
<li>概念：进程可进一步细化为线程，是一个程序内部的一条执行路径。</li>
<li>说明：线程作为调度和执行的单位，每个线程拥有独立的运行栈和程序计数器(pc)，线程切换的开销小。</li>
<li>每个线程，拥有自己独立的：虚拟机栈、程序计数器</li>
<li>多个线程，共享同一个进程中的结构：方法区、堆</li>
</ul>
<h4 id="1-4、单核CPU和多核CPU的理解"><a href="#1-4、单核CPU和多核CPU的理解" class="headerlink" title="1.4、单核CPU和多核CPU的理解"></a>1.4、单核CPU和多核CPU的理解</h4><ul>
<li>单核CPU，其实是一种假的多线程，因为在一个时间单元内，也只能执行一个线程的任务。但是因为CPU时间单元特别短，因此感觉不出来。</li>
<li>如果是多核的话，才能更好的发挥多线程的效率。</li>
<li>一个Java应用程序java.exe，其实至少有三个线程：main()主线程，gc()垃圾回收线程，异常处理线程。当然如果发生异常，会影响主线程。</li>
</ul>
<h4 id="1-5、并行与并发"><a href="#1-5、并行与并发" class="headerlink" title="1.5、并行与并发"></a>1.5、并行与并发</h4><ul>
<li>并行：多个CPU同时执行多个任务。</li>
<li>并发：一个CPU（采用时间片）同时执行多个任务。</li>
</ul>
<h4 id="1-6、使用多线程的优点"><a href="#1-6、使用多线程的优点" class="headerlink" title="1.6、使用多线程的优点"></a>1.6、使用多线程的优点</h4><ul>
<li>背景：以单个CPU为例，只使用单个线程先后完成多个任务（调用多个方法），肯定比用多个线程来完成用的时间更短，为何仍需多线程呢？</li>
<li>多线程程序的优点：<ul>
<li>1、提高应用程序的响应。对图形化界面更有意义，可增强用户体验。</li>
<li>2、提高计算机系统CPU的利用率</li>
<li>3、改善程序结构。将既长又复杂的进程分为多个线程，独立运行，利于理解和修改</li>
</ul>
</li>
</ul>
<h4 id="1-7、何时需要多线程"><a href="#1-7、何时需要多线程" class="headerlink" title="1.7、何时需要多线程"></a>1.7、何时需要多线程</h4><ul>
<li>程序需要同时执行两个或多个任务</li>
<li>程序需要实现一些需要等待的任务时，如用户输入、文件读写操作、网络操作、搜索等。</li>
<li>需要一些后台运行的程序时。</li>
</ul>
<h3 id="2、线程的创建和使用"><a href="#2、线程的创建和使用" class="headerlink" title="2、线程的创建和使用"></a>2、线程的创建和使用</h3><h4 id="2-1、创建多线程的方式一：继承Thread类"><a href="#2-1、创建多线程的方式一：继承Thread类" class="headerlink" title="2.1、创建多线程的方式一：继承Thread类"></a>2.1、创建多线程的方式一：继承Thread类</h4><ul>
<li>1、创建一个继承于Thread类的子类</li>
<li>2、重写Thread类的run() –&gt; 将此线程执行的操作声明在run()中</li>
<li>3、创建Thread类的子类的对象</li>
<li>4、通过此对象调用start()，start()的作用：<ul>
<li>1、启动当前线程</li>
<li>2、调用当前线程的run()</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1、创建一个继承于Thread类的子类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="comment">//2、重写Thread类的run()</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                System.out.println(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//3、创建Thread类的子类的对象</span></span><br><span class="line">        MyThread t1 = <span class="keyword">new</span> MyThread();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4、通过此对象调用start()</span></span><br><span class="line">        t1.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 或者通过创建Thread类的匿名子类的方式</span></span><br><span class="line">        <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;:&quot;</span> + i);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>注意点1：我们不能通过直接调用run()的方式启动线程</li>
<li>注意点2：再启动一个线程需要重新创建一个线程的对象，不可以让已经start()的线程再start()，否则会报IllegalThreadStateException异常</li>
</ul>
<h4 id="2-2、Thread类的有关方法"><a href="#2-2、Thread类的有关方法" class="headerlink" title="2.2、Thread类的有关方法"></a>2.2、Thread类的有关方法</h4><ul>
<li>void start():启动当前线程，调用当前线程的run()</li>
<li>run():通常需要重写Thread类中的此方法，将创建的线程要执行的操作声明在此方法中</li>
<li>String getName():获取当前线程的名字</li>
<li>void setName(String name):设置当前线程的名字</li>
<li>static Thread currentThread():静态方法，获取执行当前代码的线程</li>
<li>static void yield():释放当前CPU的执行权</li>
<li>join():在线程a中调用线程b的join()，此时线程a就进入阻塞状态，直到线程b完全执行完以后，线程a才结束阻塞状态</li>
<li>static void sleep(long millitime):让当前线程“睡眠”指定的millitime毫秒。在指定的millitime毫秒时间内，当前线程是阻塞状态。</li>
<li>stop():已过时。当执行此方法时，强制结束当前线程。</li>
<li>boolean isAlive():判断当前线程是否存活</li>
</ul>
<h4 id="2-3、线程的调度"><a href="#2-3、线程的调度" class="headerlink" title="2.3、线程的调度"></a>2.3、线程的调度</h4><ul>
<li>调度策略<ul>
<li>时间片</li>
<li>抢占式：高优先级的线程抢占CPU</li>
</ul>
</li>
<li>Java的调度方法<ul>
<li>同优先级线程组成先进先出队列，使用时间片策略</li>
<li>对高优先级，使用优先调度的抢占式策略</li>
</ul>
</li>
</ul>
<h4 id="2-4、线程的优先级"><a href="#2-4、线程的优先级" class="headerlink" title="2.4、线程的优先级"></a>2.4、线程的优先级</h4><ul>
<li>线程的优先等级<ul>
<li>MAX_PRIORITY:10</li>
<li>MIN_PRIORITY:1</li>
<li>NORM_PRIORITY:5 –&gt; 默认优先级</li>
</ul>
</li>
<li>涉及的方法<ul>
<li>getPriority():获取线程的优先级</li>
<li>setPriority(int newPriority):设置线程的优先级</li>
</ul>
</li>
<li>线程创建时继承父线程的优先级</li>
<li>低优先级只是获得调度的概率低，并非一定是在高优先级线程之后才被调度</li>
</ul>
<h4 id="2-5、创建多线程的方式二：实现Runnable接口"><a href="#2-5、创建多线程的方式二：实现Runnable接口" class="headerlink" title="2.5、创建多线程的方式二：实现Runnable接口"></a>2.5、创建多线程的方式二：实现Runnable接口</h4><ul>
<li>1、创建一个实现了Runnable接口的类</li>
<li>2、实现类去实现Runnable中的抽象方法：run()</li>
<li>3、创建实现类的对象</li>
<li>4、将此对象作为参数传递到Thread类的构造器中，创建Thread类的对象</li>
<li>5、通过Thread类的对象调用start()</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1、创建一个实现了Runnable接口的类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="comment">//2、实现类去实现Runnable中的抽象方法：run()</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                System.out.println(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTest1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//3、创建实现类的对象</span></span><br><span class="line">        MThread mThread = <span class="keyword">new</span> MThread();</span><br><span class="line">        <span class="comment">//4、将此对象作为参数传递到Thread类的构造器中，创建Thread类的对象</span></span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(mThread);</span><br><span class="line">        <span class="comment">//5、通过Thread类的对象调用start():启动线程，调用当前线程的run() --&gt; 调用了Runnable类型的target的run()</span></span><br><span class="line">        t1.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//再启动一个线程</span></span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(mThread);</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-6、比较创建线程的两种方式"><a href="#2-6、比较创建线程的两种方式" class="headerlink" title="2.6、比较创建线程的两种方式"></a>2.6、比较创建线程的两种方式</h4><ul>
<li>开发中：优先选择实现Runnable接口的方式<ul>
<li>1、实现的方式没有类的单继承性的局限性</li>
<li>2、实现的方式更适合来处理多个线程有共享数据的情况</li>
</ul>
</li>
<li>联系：public class Thread implements Runnable</li>
<li>相同点：两种方式都需要重写run()，将线程要执行的逻辑声明在run()中</li>
</ul>
<h3 id="3、线程的生命周期"><a href="#3、线程的生命周期" class="headerlink" title="3、线程的生命周期"></a>3、线程的生命周期</h3><p><img src="https://rulerofterabithia-blog.oss-cn-hangzhou.aliyuncs.com/img/20221016213835.png"></p>
<h3 id="4、线程的同步"><a href="#4、线程的同步" class="headerlink" title="4、线程的同步"></a>4、线程的同步</h3><h4 id="4-1、线程同步方式一：同步代码块"><a href="#4-1、线程同步方式一：同步代码块" class="headerlink" title="4.1、线程同步方式一：同步代码块"></a>4.1、线程同步方式一：同步代码块</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(同步监视器) &#123;</span><br><span class="line">    <span class="comment">// 需要被同步的代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>1、操作共享数据的代码，即为需要被同步的代码</li>
<li>2、共享数据：多个线程共同操作的变量。</li>
<li>3、同步监视器，俗称：锁。任何一个类的对象，都可以充当锁。<ul>
<li>要求：多个线程必须要共用同一把锁。</li>
</ul>
</li>
<li>补充：在实现Runnable接口创建多线程的方式中，我们可以考虑使用this充当同步监视器</li>
<li>在继承Thread类创建多线程的方式中，慎用this充当同步监视器，考虑使用当前类充当同步监视器</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Window1</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> ticket = <span class="number">100</span>;</span><br><span class="line">    Object obj = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="comment">//正确，只要保证多个线程使用同一个对象当做锁即可</span></span><br><span class="line">            <span class="comment">// synchronized (obj) &#123;</span></span><br><span class="line">            <span class="comment">// 此时的this：唯一的Window1的对象</span></span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (ticket &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;:&quot;</span> + ticket);</span><br><span class="line">                    ticket--;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Window2</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> ticket = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Object obj = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="comment">//正确</span></span><br><span class="line">            <span class="comment">// synchronized (obj) &#123;</span></span><br><span class="line">            <span class="comment">// 错误，因为通过继承Thread方式，需要通过不同的对象来创建线程</span></span><br><span class="line">            <span class="comment">// 此时的this代表着不同的对象 </span></span><br><span class="line">            <span class="comment">// synchronized (this) &#123;</span></span><br><span class="line">            <span class="comment">// 正确，Class clazz = Window2.class，Window2.class只会加载一次</span></span><br><span class="line">            <span class="keyword">synchronized</span> (Window2.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (ticket &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;:&quot;</span> + ticket);</span><br><span class="line">                    ticket--;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>好处：同步的方式，解决了线程的安全问题。</li>
<li>局限性：操作同步代码时，只能有一个线程参与，其他线程等待。相当于一个单线程的过程，效率低。</li>
</ul>
<h4 id="4-2、线程同步方式二：同步方法"><a href="#4-2、线程同步方式二：同步方法" class="headerlink" title="4.2、线程同步方式二：同步方法"></a>4.2、线程同步方式二：同步方法</h4><ul>
<li>同步方法仍然涉及到同步监视器，只是不需要我们显式的声明。</li>
<li>非静态的同步方法，同步监视器是：this；静态的同步方法，同步监视器是：当前类本身</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Window3</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> ticket = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            show();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">show</span> <span class="params">()</span> </span>&#123;<span class="comment">//同步监视器：this</span></span><br><span class="line">        <span class="keyword">if</span> (ticket &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">100</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;:&quot;</span> + ticket);</span><br><span class="line">            ticket--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Window4</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> ticket = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            show();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">show</span> <span class="params">()</span> </span>&#123;<span class="comment">//同步监视器：Window4.class</span></span><br><span class="line">        <span class="keyword">if</span> (ticket &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">100</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;:&quot;</span> + ticket);</span><br><span class="line">            ticket--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-3、设计模式：单例模式"><a href="#4-3、设计模式：单例模式" class="headerlink" title="4.3、设计模式：单例模式"></a>4.3、设计模式：单例模式</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 饿汉式</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bank</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 1、私有化类的构造器</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="title">Bank</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">	<span class="comment">// 2、内部创建类的对象</span></span><br><span class="line">	<span class="comment">// 4、要求此对象也必须声明为静态的</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> Bank instance = <span class="keyword">new</span> Bank();</span><br><span class="line">	<span class="comment">// 3、提供公共的静态的方法，返回类的对象</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Bank <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> instance;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 懒汉式方式一：同步方法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Order</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 1、私有化类的构造器</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="title">Order</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">	<span class="comment">// 2、声明当前类对象，没有初始化</span></span><br><span class="line">	<span class="comment">// 4、此对象也必须声明为static的</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> Order instance = <span class="keyword">null</span>;</span><br><span class="line">	<span class="comment">// 3、声明public、static的返回当前类对象的方法</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Order <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">			instance = <span class="keyword">new</span> Order();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> instance;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 懒汉式方式二：同步代码块</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Order</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 1、私有化类的构造器</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="title">Order</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">	<span class="comment">// 2、声明当前类对象，没有初始化</span></span><br><span class="line">	<span class="comment">// 4、此对象也必须声明为static的</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> Order instance = <span class="keyword">null</span>;</span><br><span class="line">	<span class="comment">// 3、声明public、static的返回当前类对象的方法</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Order <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 方式一：效率稍差</span></span><br><span class="line">    <span class="comment">// synchronized (Order.class) &#123;</span></span><br><span class="line">    <span class="comment">//     if (instance == null) &#123;</span></span><br><span class="line">    <span class="comment">// 	    instance = new Order();</span></span><br><span class="line">    <span class="comment">//     &#125;</span></span><br><span class="line">    <span class="comment">//     return instance;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="comment">// 方式二：效率更高</span></span><br><span class="line">    <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">synchronized</span> (Order.class) &#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> Order();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">		<span class="keyword">return</span> instance;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-4、线程的死锁问题"><a href="#4-4、线程的死锁问题" class="headerlink" title="4.4、线程的死锁问题"></a>4.4、线程的死锁问题</h4><ul>
<li>死锁<ul>
<li>不同的线程分别占用对方需要的同步资源不放弃，都在等待对方放弃自己需要的同步资源，就形成了线程的死锁</li>
<li>出现死锁后，不会出现异常，不会出现提示，只是所有的线程都处于阻塞状态，无法继续</li>
</ul>
</li>
<li>解决方法<ul>
<li>专门的算法、原则</li>
<li>尽量减少同步资源的定义</li>
<li>尽量避免嵌套同步</li>
</ul>
</li>
</ul>
<h4 id="4-5、线程同步方式三：Lock（锁）"><a href="#4-5、线程同步方式三：Lock（锁）" class="headerlink" title="4.5、线程同步方式三：Lock（锁）"></a>4.5、线程同步方式三：Lock（锁）</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Window</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> ticket = <span class="number">100</span>;</span><br><span class="line">    <span class="comment">// 1、实例化ReentrantLock</span></span><br><span class="line">    <span class="keyword">private</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 2、调用锁定方法lock()</span></span><br><span class="line">                lock.lock();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (ticket &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;:&quot;</span> + ticket);</span><br><span class="line">                    ticket--;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">// 3、调用解锁方法：unlock()</span></span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>面试题：synchronized与lock的异同？<ul>
<li>相同：二者都可以解决线程安全问题</li>
<li>不同：synchronized机制在执行完相应的同步代码以后，自动的释放同步监视器；Lock需要手动的启动同步(Lock())，同时结束同步也需要手动的实现(unlock())</li>
</ul>
</li>
<li>优先使用顺序：<ul>
<li>Lock –&gt; 同步代码块 –&gt; 同步方法</li>
</ul>
</li>
</ul>
<h3 id="5、线程的通信"><a href="#5、线程的通信" class="headerlink" title="5、线程的通信"></a>5、线程的通信</h3><ul>
<li><p>涉及到的三个方法：</p>
<ul>
<li>wait()：一旦执行此方法，当前线程就进入阻塞状态，并释放同步监视器</li>
<li>notify()：一旦执行此方法，就会唤醒被wait()的一个线程。如果有多个线程被wait，就唤醒优先级高的线程。</li>
<li>notifyAll()：一旦执行此方法，就会唤醒所有被wait的线程</li>
</ul>
</li>
<li><p>说明：</p>
<ul>
<li>wait()，notify()，notifyAll()三个方法必须使用在同步代码块或同步方法中</li>
<li>wait()，notify()，notifyAll()三个方法的调用者必须是同步代码块或同步方法中的同步监视器，否则会出现IllegalMonitorStateException异常</li>
<li>wait()，notify()，notifyAll()三个方法是定义在java.lang.Object类中</li>
</ul>
</li>
<li><p>面试题：sleep() 和 wait() 的异同？</p>
<ul>
<li>相同点：一旦执行方法，都可以使得当前的线程进入阻塞状态</li>
<li>不同点：<ul>
<li>1、两个方法声明的位置不同：Thread类中声明sleep()，Object类中声明wait()</li>
<li>2、调用的要求不同：sleep()可以在任何需要的场景下调用。wait()必须使用在同步代码块中</li>
<li>3、关于是否释放同步监视器：如果两个方法都使用在同步代码块或同步方法中，sleep()不会释放锁，wait()会释放锁</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="6、JDK5-0新增线程创建方式"><a href="#6、JDK5-0新增线程创建方式" class="headerlink" title="6、JDK5.0新增线程创建方式"></a>6、JDK5.0新增线程创建方式</h3><h4 id="6-1、新增方式一：实现Callable接口"><a href="#6-1、新增方式一：实现Callable接口" class="headerlink" title="6.1、新增方式一：实现Callable接口"></a>6.1、新增方式一：实现Callable接口</h4><ul>
<li>与使用Runnable相比，Callable功能更强大些<ul>
<li>相比run()方法，可以有返回值</li>
<li>方法可以抛出异常</li>
<li>支持泛型的返回值</li>
<li>需要借助FutureTask类，比如获取返回结果</li>
</ul>
</li>
<li>Future接口<ul>
<li>可以对具体Runnable、Callable任务的执行结果进行取消、查询是否完成、获取结果等。</li>
<li>FutrueTask是Futrue接口的唯一实现类</li>
<li>FutrueTask同时实现了Runnable，Future接口。它既可以作为Runnable被线程执行，又可以作为Future得到Callable的返回值</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1、创建一个实现Callable的实现类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NumThread</span> <span class="keyword">implements</span> <span class="title">Callable</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 2、实现call方法，将此线程需要执行的操作声明在call()中</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                System.out.println(i);</span><br><span class="line">                sum += i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadNew</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 3、创建Callable接口实现类的对象</span></span><br><span class="line">        NumThread numThread = <span class="keyword">new</span> NumThread();</span><br><span class="line">        <span class="comment">// 4、将此Callable接口实现类的对象作为传递到FutureTask构造器中，创建FutureTask的对象</span></span><br><span class="line">        FutureTask futureTask = <span class="keyword">new</span> FutureTask(numThread);</span><br><span class="line">        <span class="comment">// 5、将FutureTask的对象作为参数传递到Thread类的构造器中，创建Thread对象，并调用start()</span></span><br><span class="line">        <span class="keyword">new</span> Thread(futureTask).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 6、获取Callable中call方法的返回值</span></span><br><span class="line">            <span class="comment">// get()返回值即为FutureTask构造器参数Callable实现类重写的call()的返回值</span></span><br><span class="line">            Object sum = futureTask.get();</span><br><span class="line">            System.out.println(<span class="string">&quot;总和为：&quot;</span> + sum);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="6-2、新增方式二：使用线程池"><a href="#6-2、新增方式二：使用线程池" class="headerlink" title="6.2、新增方式二：使用线程池"></a>6.2、新增方式二：使用线程池</h4><ul>
<li>背景：经常创建和销毁、使用量特别大的资源，比如并发情况下的线程，对性能影响很大</li>
<li>思路：提前创建好多个线程，放入线程池中，使用时直接获取，使用完放回池中。可以避免频繁创建销毁、实现重复利用。</li>
<li>好处：<ul>
<li>提高响应速度（减少了创建新线程的时间）</li>
<li>降低资源消耗（重复利用线程池中线程，不需要每次都创建）</li>
<li>便于线程管理<ul>
<li>corePoolSize：核心池的大小</li>
<li>maximumPoolSize：最大线程数</li>
<li>keepAliveTime：线程没有任务时最多保持多长时间后会终止</li>
</ul>
</li>
</ul>
</li>
<li>ExecutorService：真正的线程池接口。常见子类ThreadPoolExecutor<ul>
<li>void execute(Runnable command)：执行任务/命令，没有返回值，一般用来执行Runnable</li>
<li><T> Future<T> submit(Callable<T> task)：执行任务，有返回值，一般用来执行Callable</li>
<li>void shutdown()：关闭连接池</li>
</ul>
</li>
<li>Executors：工具类、线程池的工厂类，用于创建并返回不同类型的线程池<ul>
<li>Executors.newCachedThreadPool()：创建一个可根据需要创建新线程的线程池</li>
<li>Executors.newFixedThreadPool(n)：创建一个可重用固定线程数的线程池</li>
<li>Executors.newSingleThreadPool()：创建一个只有一个线程的线程池</li>
<li>Executors.newScheduledThreadPool(n)：创建一个线程池，它可安排在给定延迟后运行命令或者定期地执行</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPool</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1、提供指定线程数量的线程池</span></span><br><span class="line">        ExecutorService service = Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">        <span class="comment">// 2、执行指定的线程的操作。需要提供实现Runnable接口或Callable接口实现类的对象</span></span><br><span class="line">        service.execute(<span class="keyword">new</span> NumberThread()); <span class="comment">// 适用于实现Runnable接口的线程</span></span><br><span class="line">        service.submit(<span class="keyword">new</span> NumberThread1()); <span class="comment">// 适用于实现Callable接口的线</span></span><br><span class="line">        <span class="comment">// 3、关闭连接池</span></span><br><span class="line">        service.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="7、附加：关于锁的操作"><a href="#7、附加：关于锁的操作" class="headerlink" title="7、附加：关于锁的操作"></a>7、附加：关于锁的操作</h3><h4 id="7-1、释放锁的操作"><a href="#7-1、释放锁的操作" class="headerlink" title="7.1、释放锁的操作"></a>7.1、释放锁的操作</h4><ul>
<li>当前线程的同步方法、同步代码块执行结束</li>
<li>当前线程在同步代码块、同步方法中遇到break、return终止了该代码块、该方法的继续执行。</li>
<li>当前线程在同步代码块、同步方法中出现了未处理的Error或Exception，导致异常结束</li>
<li>当前线程在同步代码块、同步方法中执行了线程对象的wait()方法，当前线程暂停，并释放锁</li>
</ul>
<h4 id="7-2、不会释放锁的操作"><a href="#7-2、不会释放锁的操作" class="headerlink" title="7.2、不会释放锁的操作"></a>7.2、不会释放锁的操作</h4><ul>
<li>线程执行同步代码块或同步方法时，程序调用Thread.sleep()、Thread.yield()方法暂停当前线程的执行</li>
<li>线程执行同步代码块时，其他线程调用了该线程的suspend()方法将该线程挂起，该线程不会释放锁（同步监视器）<ul>
<li>应尽量避免使用suspend()和resume()来控制线程</li>
</ul>
</li>
</ul>
<h2 id="二、Java常用类"><a href="#二、Java常用类" class="headerlink" title="二、Java常用类"></a>二、Java常用类</h2><h3 id="1、字符串相关的类"><a href="#1、字符串相关的类" class="headerlink" title="1、字符串相关的类"></a>1、字符串相关的类</h3><h4 id="1-1、字符串相关的类：String"><a href="#1-1、字符串相关的类：String" class="headerlink" title="1.1、字符串相关的类：String"></a>1.1、字符串相关的类：String</h4><ul>
<li>String声明为final的，不可被继承</li>
<li>String实现了Serializable接口：表示字符串是支持序列化的；实现了Comparable接口：表示String可以比较大小</li>
<li>String内部定义了final char[] value用于存储字符串数据</li>
<li>String：代表不可变的字符序列。简称：不可变性。<ul>
<li>1、当对字符串重新赋值时，需要重新指定内存区域赋值，不能使用原有的value进行赋值。</li>
<li>2、当对现有的字符串进行连接操作时，也需要重新指定内存区域赋值，不能使用原有的value进行赋值</li>
<li>3、当调用String的replace()方法修改指定字符或字符串时，也需要重新指定内存区域赋值，不能使用原有的value进行赋值</li>
</ul>
</li>
<li>通过字面量的方式（区别于new）给一个字符串赋值，此时的字符串声明在字符串常量池中</li>
<li>字符串常量池中是不会存储相同内容的字符串的</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  String的实例化方式</span></span><br><span class="line"><span class="comment"> *  方式一：通过字面量定义的方式</span></span><br><span class="line"><span class="comment"> *  方式二：通过new + 构造器的方式</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  面试题：String s = new String(&quot;abc&quot;);方式创建对象，在内存中创建了几个对象？</span></span><br><span class="line"><span class="comment"> *  答：两个：一个是堆空间中new结构，另一个是char[]对应的常量池中的数据：&quot;abc&quot;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 通过字面量定义的方式：此时的s1和s2的数据javaEE声明在方法区中的字符串常量池中。</span></span><br><span class="line">    String s1 = <span class="string">&quot;javaEE&quot;</span>;</span><br><span class="line">    String s2 = <span class="string">&quot;javaEE&quot;</span>;</span><br><span class="line">    <span class="comment">// 通过new + 构造器的方式：此时的s3和s4保存的地址值，是数据在堆空间中开辟空间以后对应的地址值</span></span><br><span class="line">    String s3 = <span class="keyword">new</span> String(<span class="string">&quot;javaEE&quot;</span>);</span><br><span class="line">    String s4 = <span class="keyword">new</span> String(<span class="string">&quot;javaEE&quot;</span>);</span><br><span class="line"></span><br><span class="line">    System.out.println(s1 == s2);<span class="comment">// true</span></span><br><span class="line">    System.out.println(s1 == s3);<span class="comment">// false</span></span><br><span class="line">    System.out.println(s1 == s4);<span class="comment">// false</span></span><br><span class="line">    System.out.println(s3 == s4);<span class="comment">// false</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>常量与常量的拼接结果在常量池。且常量池中不会存在相同内容的常量。</li>
<li>只要其中有一个是变量，结果就在堆中。</li>
<li>如果拼接的结果是调用intern()方法，返回值就在常量池中</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String s1 = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">String s2 = <span class="string">&quot;world&quot;</span>;</span><br><span class="line">String s3 = <span class="string">&quot;hello&quot;</span> + <span class="string">&quot;world&quot;</span>;</span><br><span class="line">String s4 = s1 + <span class="string">&quot;world&quot;</span>;</span><br><span class="line">String s5 = s1 + s2;</span><br><span class="line">String s6 = (s1 + s2).intern();</span><br><span class="line"><span class="keyword">final</span> String s7 = <span class="string">&quot;hello&quot;</span>; <span class="comment">// 此时的s7是一个常量</span></span><br><span class="line">String s8 = s7 + <span class="string">&quot;world&quot;</span>;</span><br><span class="line"></span><br><span class="line">System.out.println(s3 == s4);<span class="comment">// false</span></span><br><span class="line">System.out.println(s3 == s5);<span class="comment">// false</span></span><br><span class="line">System.out.println(s4 == s5);<span class="comment">// false</span></span><br><span class="line">System.out.println(s3 == s6);<span class="comment">// true</span></span><br><span class="line">System.out.println(s3 == s8);<span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h4 id="1-2、字符串相关的类：String常用方法"><a href="#1-2、字符串相关的类：String常用方法" class="headerlink" title="1.2、字符串相关的类：String常用方法"></a>1.2、字符串相关的类：String常用方法</h4><ul>
<li>int length()：返回字符串的长度：return value.length</li>
<li>char charAt(int index)：返回某索引处的字符return value[index]</li>
<li>boolean isEmpty()：判断是否是空字符串：return value.length == 0</li>
<li>String toLowerCase()：使用默认语言环境，将String中的所有字符转换为小写</li>
<li>String toUpperCase()：使用默认语言环境，将String中的所有字符转换为大写</li>
<li>String trim()：返回字符串的副本，忽略首部空白和尾部空白</li>
<li>boolean equals(Object obj)：比较字符串的内容是否相同</li>
<li>boolean equalsIgnoreCase(String anotherString)：与equals方法类似，忽略大小写</li>
<li>String concat(String str)：将指定字符串连接到此字符串的结尾。等价于用”+”</li>
<li>int compareTo(String anotherString)：比较两个字符串的大小</li>
<li>String substring(int beginIndex)：返回一个新的字符串，它是此字符串从beginIndex开始截取到最后的一个子字符串</li>
<li>String substring(int beginIndex, int endIndex)：返回一个新的字符串，它是此字符串从beginIndex开始截取到endIndex（不包含）的一个子字符串</li>
<li>boolean endsWith(String suffix)：测试此字符串是否以指定的后缀结束</li>
<li>boolean startsWith(String prefix)：测试此字符串是否以指定的前缀开始</li>
<li>boolean startsWith(String prefix, int toffset)：测试此字符串从指定索引开始的子字符串是否以指定的前缀开始</li>
<li>boolean contains(CharSequence s)：当且仅当此字符串包含指定的char值序列时，返回true</li>
<li>int indexOf(String str)：返回指定子字符串在此字符串中第一次出现处的索引</li>
<li>int indexOf(String str, int fromIndex)：返回指定子字符串在此字符串中第一次出现处的索引，从指定的索引开始</li>
<li>int lastIndexOf(String str)：返回指定子字符串在此字符串中最右边出现处的索引</li>
<li>int lastIndexOf(String str, int fromIndex)：返回指定子字符串在此字符串中最后一次出现处的索引，从指定的索引开始反向搜索</li>
<li>String replace(char oldChar, char new Char)：返回一个新的字符串，它是通过用newChar替换此字符串中出现的所有oldChar得到的</li>
<li>String replace(CharSequence target, CharSequence replacement)：使用指定的字面值替换序列替换此字符串所有匹配字面值目标序列的子字符串</li>
<li>String replaceAll(String regex, String replacement)：使用给定的replacement替换此字符串所有匹配给定的正则表达式的子字符串</li>
<li>String replaceFirst(String regex, String replacement)：使用给定的replacement替换此字符串匹配给定的正则表达式的第一个子字符串</li>
<li>boolean matches(String regex)：告知此字符串是否匹配给定的正则表达式</li>
<li>String[] split(String regex)：根据给定正则表达式的匹配拆分此字符串</li>
<li>String[] split(String regex, int limit)：根据匹配给定的正则表达式来拆分此字符串，最多不超过limit个，如果超过了，剩下的全部都放到最后一个元素中</li>
</ul>
<h4 id="1-3、String与基本数据类型、包装类之间的转换"><a href="#1-3、String与基本数据类型、包装类之间的转换" class="headerlink" title="1.3、String与基本数据类型、包装类之间的转换"></a>1.3、String与基本数据类型、包装类之间的转换</h4><ul>
<li>String –&gt; 基本数据类型、包装类：调用包装类的静态方法：parseXxx(str)</li>
<li>基本数据类型、包装类 –&gt; String：调用String重载的valueOf(xxx)</li>
</ul>
<h4 id="1-4、String与char-之间的转换"><a href="#1-4、String与char-之间的转换" class="headerlink" title="1.4、String与char[]之间的转换"></a>1.4、String与char[]之间的转换</h4><ul>
<li>String –&gt; char[]：调用String的toCharArray()</li>
<li>char[] –&gt; String：调用String的构造器</li>
</ul>
<h4 id="1-5、String与byte-之间的转换"><a href="#1-5、String与byte-之间的转换" class="headerlink" title="1.5、String与byte[]之间的转换"></a>1.5、String与byte[]之间的转换</h4><ul>
<li>String –&gt; byte[]：调用String的getBytes()</li>
<li>byte[] –&gt; String：调用String的构造器</li>
</ul>
<h4 id="1-6、String、StringBuffer、StringBuilder三者的异同？"><a href="#1-6、String、StringBuffer、StringBuilder三者的异同？" class="headerlink" title="1.6、String、StringBuffer、StringBuilder三者的异同？"></a>1.6、String、StringBuffer、StringBuilder三者的异同？</h4><ul>
<li>String：不可变的字符序列；底层使用final char[]存储</li>
<li>StringBuffer：可变的字符序列；线程安全的，效率低；底层使用char[]存储</li>
<li>StringBuilder：可变的字符序列；JDK 5.0新增的，线程不安全的，效率高；底层使用char[]存储</li>
</ul>
<h4 id="1-7、StringBuffer源码分析"><a href="#1-7、StringBuffer源码分析" class="headerlink" title="1.7、StringBuffer源码分析"></a>1.7、StringBuffer源码分析</h4><ul>
<li>扩容问题：如果要添加的数据底层数组盛不下了，那就需要扩容底层的数组。默认情况下，扩容为原来容量的2倍+2，同时将原有数组中的元素复制到新的数组中</li>
<li>指导意义：开发中建议大家使用：StringBuffer(int capacity) 或 StringBuilder(int capacity)</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String str = <span class="keyword">new</span> String(); <span class="comment">// char[] value = new char[0];</span></span><br><span class="line">String str1 = <span class="keyword">new</span> String(<span class="string">&quot;abc&quot;</span>); <span class="comment">// char[] value = new char[]&#123;&#x27;a&#x27;,&#x27;c&#x27;,&#x27;c&#x27;&#125;;</span></span><br><span class="line"></span><br><span class="line">StringBuffer sb1 = <span class="keyword">new</span> StringBuffer(); <span class="comment">// char[] value = new char[16];底层创建了一个长度是16的数组</span></span><br><span class="line">System.out.println(sb1.length()); <span class="comment">//0</span></span><br><span class="line">sb1.append(<span class="string">&#x27;a&#x27;</span>);<span class="comment">//value[0] = &#x27;a&#x27;;</span></span><br><span class="line">sb1.append(<span class="string">&#x27;b&#x27;</span>);<span class="comment">//value[1] = &#x27;b&#x27;;</span></span><br><span class="line"></span><br><span class="line">StringBuffer sb2 = <span class="keyword">new</span> StringBuffer(<span class="string">&quot;abc&quot;</span>);<span class="comment">//char[] value = new char[&quot;abc&quot;.length() + 16];</span></span><br></pre></td></tr></table></figure>

<h4 id="1-8、StringBuffer类的常用方法"><a href="#1-8、StringBuffer类的常用方法" class="headerlink" title="1.8、StringBuffer类的常用方法"></a>1.8、StringBuffer类的常用方法</h4><ul>
<li>StringBuffer append(xxx)：提供了很多的append()方法，用于进行字符串拼接</li>
<li>StringBuffer delete(int start, int end)：删除指定位置的内容</li>
<li>StringBuffer replace(int start, int end, String  str)：把[start, end)位置替换为str</li>
<li>StringBuffer insert(int offset, xxx)：在指定位置插入xxx</li>
<li>StringBuffer reverse()：把当前字符序列逆转</li>
</ul>
<h4 id="1-9、对比String、StringBuffer、StringBuilder三者的效率"><a href="#1-9、对比String、StringBuffer、StringBuilder三者的效率" class="headerlink" title="1.9、对比String、StringBuffer、StringBuilder三者的效率"></a>1.9、对比String、StringBuffer、StringBuilder三者的效率</h4><ul>
<li>从高到低排列：StringBuilder &gt; StringBuffer &gt; String</li>
</ul>
<h4 id="1-10、String与StringBuffer、StringBuilder之间的转换"><a href="#1-10、String与StringBuffer、StringBuilder之间的转换" class="headerlink" title="1.10、String与StringBuffer、StringBuilder之间的转换"></a>1.10、String与StringBuffer、StringBuilder之间的转换</h4><ul>
<li>String –&gt; StringBufferr、StringBuilder：调用StringBuffer、StringBuilder构造器</li>
<li>StringBufferr、StringBuilder –&gt; String：<ul>
<li>调用String构造器</li>
<li>StringBuffer、StringBuilder的toString()</li>
</ul>
</li>
</ul>
<h3 id="2、JDK-8之前的日期时间API"><a href="#2、JDK-8之前的日期时间API" class="headerlink" title="2、JDK 8之前的日期时间API"></a>2、JDK 8之前的日期时间API</h3><h4 id="2-1、java-lang-System类"><a href="#2-1、java-lang-System类" class="headerlink" title="2.1、java.lang.System类"></a>2.1、java.lang.System类</h4><ul>
<li>System类提供的public static long currentTimeMillis()用来返回当前时间与1970年1月1日0时0分0秒之间以毫秒为单位的时间差。</li>
</ul>
<h4 id="2-2、java-util-Date类"><a href="#2-2、java-util-Date类" class="headerlink" title="2.2、java.util.Date类"></a>2.2、java.util.Date类</h4><ul>
<li>表示特定的瞬间，精确到毫秒</li>
<li>构造器：<ul>
<li>Date()：使用无参构造器创建的对象可以获取本地当前时间</li>
<li>Date(long date)</li>
</ul>
</li>
<li>常用方法<ul>
<li>getTime()：返回自1970年1月1日 00:00:00 GMT 以来此Date对象表示的毫秒数</li>
<li>toString()：把此Date对象转换为以下的形式的String：dow mon dd hh:mm:ss zzz yyyy</li>
</ul>
</li>
</ul>
<h4 id="2-3、java-text-SimpleDateFormat类"><a href="#2-3、java-text-SimpleDateFormat类" class="headerlink" title="2.3、java.text.SimpleDateFormat类"></a>2.3、java.text.SimpleDateFormat类</h4><ul>
<li>Date类的API不易于国际化，大部分被废弃了，java.text.SimpleDateFormat类是一个不与语言环境有关的方式来格式化和解析日期的具体类</li>
<li>格式化：<ul>
<li>SimpleDateFormat()：默认的模式和语言环境创建对象</li>
<li>public SimpleDateFormat(String pattern)：该构造方法可以用参数pattern指定的格式创建一个对象</li>
<li>public String format(Date date)：格式化时间对象date</li>
</ul>
</li>
<li>解析：<ul>
<li>public Date parse(String source)：从给定字符串的开始解析文本，以生成一个日期</li>
</ul>
</li>
</ul>
<h4 id="2-4、java-util-Calendar类"><a href="#2-4、java-util-Calendar类" class="headerlink" title="2.4、java.util.Calendar类"></a>2.4、java.util.Calendar类</h4><ul>
<li>Calendar是一个抽象基类，主要用于完成日期字段之间相互操作的功能</li>
<li>获取Calendar实例的方法<ul>
<li>使用Calendar.getInstance()方法</li>
<li>调用它的子类GregorianCalendar的构造器</li>
</ul>
</li>
<li>一个Calendar的实例是系统时间的抽象表示，通过get(int field)方法来取得想要的时间信息。比如YEAR、MONTH、DAY_OF_WEEK、HOUR_OF_DAY、MINUTE、SECOND<ul>
<li>public void set(int field, int value)</li>
<li>public void add(int field, int amount)</li>
<li>public final Date getTime()</li>
<li>public final void setTime(Date date)</li>
</ul>
</li>
<li>注意<ul>
<li>获取月份时：一月是0，二月是1，以此类推，12月是11</li>
<li>获取星期时：周日是1，周一是2，以此类推，周六是7</li>
</ul>
</li>
</ul>
<h3 id="3、JDK-8中新日期时间API"><a href="#3、JDK-8中新日期时间API" class="headerlink" title="3、JDK 8中新日期时间API"></a>3、JDK 8中新日期时间API</h3><h4 id="3-1、新日期时间API出现的原因"><a href="#3-1、新日期时间API出现的原因" class="headerlink" title="3.1、新日期时间API出现的原因"></a>3.1、新日期时间API出现的原因</h4><ul>
<li>可变性：像日期和时间这样的类应该是不可变的</li>
<li>偏移性：Date中的年份是从1900开始的，而月份都是从0开始</li>
<li>格式化：格式化只对Date有用，Calender则不行</li>
<li>此外，它们都不是线程安全的；不能处理闰秒等</li>
</ul>
<h4 id="3-2、LocalDate、LocalTime、LocalDateTime类"><a href="#3-2、LocalDate、LocalTime、LocalDateTime类" class="headerlink" title="3.2、LocalDate、LocalTime、LocalDateTime类"></a>3.2、LocalDate、LocalTime、LocalDateTime类</h4><ul>
<li>它们的实例是不可变的对象，分别表示使用ISO-8601日历系统的日期、时间、日期和时间。</li>
<li>创建方法：<ul>
<li>now() / now(ZoneId zone)：静态方法，根据当前时间创建对象/指定时区的对象</li>
<li>of()：静态方法，根据指定日期/时间创建对象</li>
</ul>
</li>
<li>get类的方法：<ul>
<li>getDayOfMonth()/getDayOfYear()：获得月份天数(1-31)/获得年份天数(1-366)</li>
<li>getDayOfWeek()：获得星期几(返回一个DayOfWeek枚举值)</li>
<li>getMonth()：获得月份，返回一个Month枚举值</li>
<li>getMonthValue()/getYear()：获得月份(1-12)/获得年份</li>
<li>getHour()/getMinute()/getSecond()：获得当前对象对应的小时、分钟、秒</li>
</ul>
</li>
<li>set类的方法：<ul>
<li>withDayOfMonth()/withDayOfYear()/withMonth()/withYear()：将月份天数、年份天数、月份、年份修改为指定的值并返回新的对象</li>
</ul>
</li>
<li>操作类的方法：<ul>
<li>plusDays()/plusWeeks()/plusMonths()/plusYears()/plusHours()：向当前对象添加几天、几周、几个月、几年、几小时</li>
<li>minusMonths()/minusWeeks()/minusDays()/minusYears()/minusHours()：从当前对象减去几月、几周、几天、几年、几小时</li>
</ul>
</li>
</ul>
<h4 id="3-3、瞬时：Instant"><a href="#3-3、瞬时：Instant" class="headerlink" title="3.3、瞬时：Instant"></a>3.3、瞬时：Instant</h4><ul>
<li>时间线上的一个瞬时点，同样的，在Java中也是从1970年开始，但以毫秒为单位</li>
<li>常用方法：<ul>
<li>now()：静态方法，返回默认UTC时区的Instant类的对象</li>
<li>ofEpochMilli(long epochMilli)：静态方法，返回在1970-01-01 00:00:00基础上加上指定毫秒数之后的Instant类的对象</li>
<li>atOffset(ZoneOffset offset)：结合即时的偏移来创建一个OffsetDateTime</li>
<li>toEpochMilli()：返回1970-01-01 00:00:00到当前时间的毫秒数，即为时间戳</li>
</ul>
</li>
</ul>
<h4 id="3-4、java-time-format-DateTimeFormatter类"><a href="#3-4、java-time-format-DateTimeFormatter类" class="headerlink" title="3.4、java.time.format.DateTimeFormatter类"></a>3.4、java.time.format.DateTimeFormatter类</h4><ul>
<li>预定义的标准格式。如：ISO_LOCAL_DATE_TIME;ISO_LOCAL_DATE;ISO_LOCAL_TIME</li>
<li>本地化相关的格式。如ofLocalizedDateTime(FormatStyle.LONG)</li>
<li>自定义的格式。如：ofPattern(“yyyy-MM-dd hh:mm:ss E”)</li>
<li>常用方法：<ul>
<li>ofPattern(String pattern)：静态方法，返回一个指定字符串格式的DateTimeFormatter</li>
<li>format(TemporalAccessor t)：格式化一个日期、时间，返回字符串</li>
<li>parse(CharSequence test)：将指定格式的字符序列解析为一个日期、时间</li>
</ul>
</li>
</ul>
<h3 id="4、Java比较器"><a href="#4、Java比较器" class="headerlink" title="4、Java比较器"></a>4、Java比较器</h3><h4 id="4-1、方式一：自然排列：java-lang-Comparable"><a href="#4-1、方式一：自然排列：java-lang-Comparable" class="headerlink" title="4.1、方式一：自然排列：java.lang.Comparable"></a>4.1、方式一：自然排列：java.lang.Comparable</h4><ul>
<li>Comparable接口强行对实现它的每个类的对象进行整体排序。这种排序被称为类的自然排序</li>
<li>实现Comparable的类必须实现compareTo(Object obj)方法，两个对象即通过compareTo(Object obj)方法的返回值来比较大小。<ul>
<li>如果当前对象this大于形参对象obj，则返回正整数</li>
<li>如果当前对象this小于形参对象obj，则返回负整数</li>
<li>如果当前对象this等于形参对象obj，则返回零</li>
</ul>
</li>
<li>实现Comparable接口的对象列表（和数组）可以通过Collections.sort或Arrays.sort进行自动排列。</li>
</ul>
<h4 id="4-2、方式二：定制排序：java-util-Comparator"><a href="#4-2、方式二：定制排序：java-util-Comparator" class="headerlink" title="4.2、方式二：定制排序：java.util.Comparator"></a>4.2、方式二：定制排序：java.util.Comparator</h4><ul>
<li>当元素的类型没有实现java.lang.Comparable接口而又不方便修改代码，或者实现了java.lang.Comparable接口的排序规则不适合当前的操作，那么可以考虑使用Comparator的对象来排序</li>
<li>重写compare(Object o1, Object o2)方法，比较o1和o2的大小<ul>
<li>如果方法返回正整数，表示o1大于o2</li>
<li>如果方法返回0，表示相等</li>
<li>返回负整数，表示o1小于o2</li>
</ul>
</li>
<li>可以将Comparator传递给sort方法(如Collections.sort或Arrays.sort)，从而允许在排序顺序上实现精确控制</li>
</ul>
<h3 id="5、System类"><a href="#5、System类" class="headerlink" title="5、System类"></a>5、System类</h3><ul>
<li>System类代表系统，系统级的很多属性和控制方法都放置在该类的内部。</li>
<li>成员变量：<ul>
<li>in：标准输入流（键盘输入）</li>
<li>out：标准输出流（显示器）</li>
<li>err：标准错误输出流（显示器）</li>
</ul>
</li>
<li>成员方法：<ul>
<li>native long currentTimeMillis()：该方法的作用是返回当前的计算机时间，时间的表达格式为当前计算机时间和GMT时间（格林威治时间）1970年1月1日0时0分0秒所差的毫秒数。</li>
<li>void exit(int status)：该方法的作用是退出程序。其中status的值为0代表正常退出，非零代表异常退出。</li>
<li>void gc()：该方法的作用是请求系统进行垃圾回收。至于系统是否立刻回收，则取决于系统中垃圾回收算法的实现以及系统执行时的情况。</li>
<li>String getProperty(String key)：该方法的作用是获得系统中属性名为key的属性对应的值。<ul>
<li>java.version：java运行时环境版本</li>
<li>java.home：java安装目录</li>
<li>os.name：操作系统的名称</li>
<li>os.version：操作系统的版本</li>
<li>user.name：用户的账户名称</li>
<li>user.home：用户的主目录</li>
<li>user.dir：用户的当前工作目录</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="6、Math类"><a href="#6、Math类" class="headerlink" title="6、Math类"></a>6、Math类</h3><ul>
<li>abs：绝对值</li>
<li>acos,asin,atan,cos,sin,tan：三角函数</li>
<li>sqrt：平方根</li>
<li>pow(double a, double b)：a的b次幂</li>
<li>log：自然对数</li>
<li>exp：e为底指数</li>
<li>max(double a, double b)</li>
<li>min(double a, double b)</li>
<li>random()：返回0.0到1.0的随机数</li>
<li>long round(double a)：double型数据a转换为long型（四舍五入）</li>
<li>toDegrees(double angrad)：弧度–&gt;角度</li>
<li>toRadians(double angdeg)：角度–&gt;弧度</li>
</ul>
<h3 id="7、BigInteger与BigDecimal"><a href="#7、BigInteger与BigDecimal" class="headerlink" title="7、BigInteger与BigDecimal"></a>7、BigInteger与BigDecimal</h3><h4 id="7-1-BigInteger类"><a href="#7-1-BigInteger类" class="headerlink" title="7.1 BigInteger类"></a>7.1 BigInteger类</h4><ul>
<li>java.math包的BigInteger可以表示不可变的任意精度的整数</li>
<li>构造器：<ul>
<li>BigInteger(String val)：根据字符串构建BigInteger对象</li>
</ul>
</li>
<li>常用方法：<ul>
<li>public BigInteger abs()：返回此BigInteger的绝对值的BigInteger</li>
<li>BigInteger add(BigInteger val)：返回其值为(this+val)的BigInteger</li>
<li>BigInteger subtract(BigInteger val)：返回其值为(this-val)的BigInteger</li>
<li>BigInteger multiply(BigInteger val)：返回其值为(this*val)的BigInteger</li>
<li>BigInteger divide(BigInteger val)：返回其值为(this/val)的BigInteger。整数相除只保留整数部分</li>
<li>BigInteger remainder(BigInteger val)：返回其值为(this%val)的BigInteger</li>
<li>BigInteger[] divideAndRemainder(BigInteger val)：返回包含(this/val)后跟(this%val)的两个BigInteger的数组</li>
<li>BigInteger pow(int exponent)：返回其值为(this的exponent次方)的BigInteger</li>
</ul>
</li>
</ul>
<h4 id="7-2-BigDecimal类"><a href="#7-2-BigDecimal类" class="headerlink" title="7.2 BigDecimal类"></a>7.2 BigDecimal类</h4><ul>
<li>BigDecimal类支持不可变的、任意精度的有符号十进制定点数</li>
<li>构造器：<ul>
<li>public BigDecimal(double val)</li>
<li>public BigDecimal(String val)</li>
</ul>
</li>
<li>常用方法：<ul>
<li>public BigDecimal add(BigDecimal augend)</li>
<li>public BigDecimal subtract(BigDecimal subtrahend)</li>
<li>public BigDecimal multiply(BigDecimal multiplicand)</li>
<li>public BigDecimal divide(BigDecimal divisor, int scale, int roundingMode)</li>
</ul>
</li>
</ul>
<h2 id="三、枚举类-amp-注解"><a href="#三、枚举类-amp-注解" class="headerlink" title="三、枚举类&amp;注解"></a>三、枚举类&amp;注解</h2><h3 id="1、枚举类的使用"><a href="#1、枚举类的使用" class="headerlink" title="1、枚举类的使用"></a>1、枚举类的使用</h3><h4 id="1-1、枚举类的使用"><a href="#1-1、枚举类的使用" class="headerlink" title="1.1、枚举类的使用"></a>1.1、枚举类的使用</h4><ul>
<li>枚举类的理解：类的对象只有有限个，确定的。我们称此类为枚举类</li>
<li>当需要定义一组常量时，强烈建议使用枚举类</li>
<li>如果枚举类中只有一个对象，则可以作为单例模式的实现方式</li>
</ul>
<h4 id="1-2、如何定义枚举类"><a href="#1-2、如何定义枚举类" class="headerlink" title="1.2、如何定义枚举类"></a>1.2、如何定义枚举类</h4><ul>
<li>方式一：jdk 5.0之前，自定义枚举类</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Season</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1、声明Seaon对象的属性：private final修饰</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String seasonName;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String seasonDesc;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2、私有化类的构造器，并给对象属性赋值</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Season</span><span class="params">(String seasonName, String seasonDesc)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.seasonName = seasonName;</span><br><span class="line">        <span class="keyword">this</span>.seasonDesc = seasonDesc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3、提供当前枚举类的多个对象：public static final的</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Season SPRING = <span class="keyword">new</span> Season(<span class="string">&quot;春天&quot;</span>, <span class="string">&quot;春暖花开&quot;</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Season SUMMER = <span class="keyword">new</span> Season(<span class="string">&quot;夏天&quot;</span>, <span class="string">&quot;夏日炎炎&quot;</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Season AUTUMN = <span class="keyword">new</span> Season(<span class="string">&quot;秋天&quot;</span>, <span class="string">&quot;秋高气爽&quot;</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Season WINTER = <span class="keyword">new</span> Season(<span class="string">&quot;冬天&quot;</span>, <span class="string">&quot;冬日可爱&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>方式二：jdk 5.0，可以使用enum关键字定义枚举类</li>
<li>定义的枚举类默认继承于java.lang.Enum类</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Info</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用enum关键字枚举类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">Season1</span> <span class="keyword">implements</span> <span class="title">Info</span></span>&#123;</span><br><span class="line">    <span class="comment">// 1、提供当前枚举类的对象，多个对象之间用&quot;,&quot;隔开，末尾对象用&quot;;&quot;结束</span></span><br><span class="line">    SPRING(<span class="string">&quot;春天&quot;</span>, <span class="string">&quot;春暖花开&quot;</span>) &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    SUMMER(<span class="string">&quot;夏天&quot;</span>, <span class="string">&quot;夏日炎炎&quot;</span>) &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    AUTUMN(<span class="string">&quot;秋天&quot;</span>, <span class="string">&quot;秋高气爽&quot;</span>) &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    WINTER(<span class="string">&quot;冬天&quot;</span>, <span class="string">&quot;冬日可爱&quot;</span>) &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2、声明Season对象的属性：private final修饰</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String seasonName;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String seasonDesc;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3、私有化类的构造器，并给对象属性赋值</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Season1</span><span class="params">(String seasonName, String seasonDesc)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.seasonName = seasonName;</span><br><span class="line">        <span class="keyword">this</span>.seasonDesc = seasonDesc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 一般都是各个枚举类对象分别实现接口，不推荐在类中实现抽象方法</span></span><br><span class="line">    <span class="comment">// @Override</span></span><br><span class="line">    <span class="comment">// public void show() &#123;</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="1-3、Enum类的主要方法"><a href="#1-3、Enum类的主要方法" class="headerlink" title="1.3、Enum类的主要方法"></a>1.3、Enum类的主要方法</h4><ul>
<li>value()：返回枚举类型的对象数组。该方法可以很方便地遍历所有的枚举类</li>
<li>valueOf(String str)：可以把一个字符串转为对应的枚举类对象。要求字符串必须是枚举类对象的”名字”。如不是，会有运行时异常：illegalArgumentException</li>
<li>toString()：返回当前枚举类对象常量的名称</li>
</ul>
<h3 id="2、注解的使用"><a href="#2、注解的使用" class="headerlink" title="2、注解的使用"></a>2、注解的使用</h3><h4 id="2-1、注解的概述"><a href="#2-1、注解的概述" class="headerlink" title="2.1、注解的概述"></a>2.1、注解的概述</h4><ul>
<li>从JDK 5.0开始，Java增加了对元数据的支持，也就是Annotation(注解)</li>
<li>Annotation其实就是代码里的特殊标记，这些标记可以在编译、类加载、运行时被读取，并执行相应的处理。通过使用Annotation，程序员可以在不改变原有逻辑的情况下，在源文件中嵌入一些补充信息。</li>
<li>框架 = 注解 + 反射 + 设计模式</li>
</ul>
<h4 id="2-2、常见的Annotation示例"><a href="#2-2、常见的Annotation示例" class="headerlink" title="2.2、常见的Annotation示例"></a>2.2、常见的Annotation示例</h4><ul>
<li>示例一：生成文档相关的注解</li>
<li>示例二：在编译时进行格式检查(JDK内置的三个基本注解)<ul>
<li>@Override：限定重写父类方法，该注解只能用于方法</li>
<li>@Deprecated：用于表示所修饰的元素(类，方法等)已过时。通常是因为所修饰的结构危险或存在更好的选择</li>
<li>@SuppressWarnings：抑制编译器警告</li>
</ul>
</li>
<li>示例三：跟踪代码依赖性，实现代替配置文件功能</li>
</ul>
<h4 id="2-3、如何自定义注解：参照-SuppressWarnings定义"><a href="#2-3、如何自定义注解：参照-SuppressWarnings定义" class="headerlink" title="2.3、如何自定义注解：参照@SuppressWarnings定义"></a>2.3、如何自定义注解：参照@SuppressWarnings定义</h4><ul>
<li>注解声明为：@interface</li>
<li>内部定义成员，通常使用value表示</li>
<li>可以指定成员的默认值，使用default定义</li>
<li>如果自定义注解没有成员，表明是一个标识作用</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;TYPE, FIELD, METHOD, PARAMETER, CONSTRUCTOR, LOCAL_VARIABLE&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.SOURCE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyAnnotation &#123;</span><br><span class="line">    <span class="comment">// 多个参数：此时的value是个成员，不是方法</span></span><br><span class="line">    String[] value();</span><br><span class="line">    <span class="comment">// 单个参数：如果有默认值，则如此定义</span></span><br><span class="line">    <span class="comment">// String value() default &quot;Hello&quot;;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>如果注解有成员，在使用注解时，需要指明成员的值</li>
<li>自定义注解必须配上注解的信息处理流程(使用反射)才有意义</li>
<li>自定义注解通常都会指明两个元注解：Retention、Target</li>
</ul>
<h4 id="2-4、JDK提供的4种元注解"><a href="#2-4、JDK提供的4种元注解" class="headerlink" title="2.4、JDK提供的4种元注解"></a>2.4、JDK提供的4种元注解</h4><ul>
<li>元注解：对现有的注解进行解释说明的注解</li>
<li>Retention：指定所修饰的Annotation的生命周期：SOURCE\CLASS(默认值)\RUNTIME，只有声明为RUNTIME生命周期的注解，才能通过反射获取</li>
<li>Target：用于指定被修饰的Annotation能用于修饰哪些程序元素</li>
<li>Documented：表示所修饰的注解在被javadoc解析时，保留下来</li>
<li>Inherited：被它修饰的Annotation将具有继承性</li>
</ul>
<h4 id="2-5、JDK-8中注解的新特性：可重复注解、类型注解"><a href="#2-5、JDK-8中注解的新特性：可重复注解、类型注解" class="headerlink" title="2.5、JDK 8中注解的新特性：可重复注解、类型注解"></a>2.5、JDK 8中注解的新特性：可重复注解、类型注解</h4><ul>
<li>可重复注解：<ul>
<li>在MyAnnotation上声明@Repeatable，成员值为MyAnnotations.class</li>
<li>MyAnnotation的Target和Retention等元注解与MyAnnotations相同</li>
</ul>
</li>
<li>类型注解：<ul>
<li>ElementType.TYPE_PARAMETER：表示该注解能写在类型变量的声明语句中（如：泛型声明）</li>
<li>ElementType.TYPE_USE：表示该注解能写在使用类型的任何语句中</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;TYPE, FIELD, METHOD, PARAMETER, CONSTRUCTOR, LOCAL_VARIABLE&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.SOURCE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyAnnotations &#123;</span><br><span class="line">    MyAnnotation[] value();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Repeatable(MyAnnotations.class)</span></span><br><span class="line"><span class="meta">@Target(&#123;TYPE, FIELD, METHOD, PARAMETER, CONSTRUCTOR, LOCAL_VARIABLE&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.SOURCE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyAnnotation &#123;</span><br><span class="line">    <span class="function">String <span class="title">value1</span><span class="params">()</span> <span class="keyword">default</span> &quot;Hello&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="四、Java集合"><a href="#四、Java集合" class="headerlink" title="四、Java集合"></a>四、Java集合</h2><h3 id="1、Java集合框架概述"><a href="#1、Java集合框架概述" class="headerlink" title="1、Java集合框架概述"></a>1、Java集合框架概述</h3><h4 id="1-1、集合框架的概述"><a href="#1-1、集合框架的概述" class="headerlink" title="1.1、集合框架的概述"></a>1.1、集合框架的概述</h4><ul>
<li>集合、数组都是对多个数据进行存储操作的结构，简称Java容器。</li>
<li>说明：此时的存储，主要指的是内存层面的存储，不涉及到持久化的存储</li>
<li>数组在存储多个数据方面的特点：<ul>
<li>一旦初始化以后，其长度就确定了</li>
<li>数组一旦定义好，其元素的类型也就确定了。我们也就只能操作指定类型的数据了。比如：String[] arr;int[] arr1;Object[] arr2;</li>
</ul>
</li>
<li>数组在存储多个数据方面的缺点：<ul>
<li>一旦初始化以后，其长度就不可修改</li>
<li>数组中提供的方法非常有限，对于添加、删除、插入数据等操作，非常不便，同时效率不高。</li>
<li>获取数组中实际元素的个数的需求，数组没有现成的属性或方法可用。</li>
<li>数组存储数据的特点：有序、可重复。对于无序、不可重复的需求，不能满足。</li>
</ul>
</li>
</ul>
<h4 id="1-2、集合框架"><a href="#1-2、集合框架" class="headerlink" title="1.2、集合框架"></a>1.2、集合框架</h4><ul>
<li>Collection接口：单列集合，用来存储一个一个的对象<ul>
<li>List接口：存储有序的、可重复的数据<ul>
<li>ArrrayList、LinkedList、Vector</li>
</ul>
</li>
<li>Set接口：存储无序的、不可重复的数据<ul>
<li>HashSet、LinkedHashSet、TreeSet</li>
</ul>
</li>
</ul>
</li>
<li>Map接口：双列集合，用来存储一对(key-value)一对的数据<ul>
<li>HashMap、LinkedHashMap、TreeMap、Hashtable、Properties</li>
</ul>
</li>
</ul>
<h3 id="2、Collection接口方法"><a href="#2、Collection接口方法" class="headerlink" title="2、Collection接口方法"></a>2、Collection接口方法</h3><ul>
<li>添加<ul>
<li>add(Object obj)</li>
<li>addAll(Conllection coll)</li>
</ul>
</li>
<li>获取有效元素的个数<ul>
<li>int size()</li>
</ul>
</li>
<li>清空集合<ul>
<li>void clear()</li>
</ul>
</li>
<li>是否是空集合<ul>
<li>boolean isEmpty()</li>
</ul>
</li>
<li>是否包含某个元素<ul>
<li>boolean contains(Object obj)：是通过元素的equals方法来判断是否是同一个对象</li>
<li>boolean containsAll(Collection c)：也是调用元素的equals方法来比较的。拿两个集合的元素挨个比较。</li>
</ul>
</li>
<li>删除<ul>
<li>boolean remove(Object obj)：通过元素的equals方法判断是否是要删除的那个元素。只会删除找到的第一个元素</li>
<li>boolean removeAll(Collection coll)：取当前集合的差集</li>
</ul>
</li>
<li>取两个集合的交集<ul>
<li>boolean retainAll(Collection c)：把交集的结果存在当前集合中，不影响c</li>
</ul>
</li>
<li>集合是否相等<ul>
<li>boolean equals(Object obj)</li>
</ul>
</li>
<li>转成对象数组<ul>
<li>Object[] toArray()</li>
</ul>
</li>
<li>获取集合对象的哈希值<ul>
<li>hashCode()</li>
</ul>
</li>
<li>遍历<ul>
<li>iterator()：返回迭代器对象，用于集合遍历</li>
</ul>
</li>
</ul>
<blockquote>
<p>拓展：数组 –&gt; 集合：调用Arrays类的静态方法asList()</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; list = Arrays.asList(<span class="keyword">new</span> String[]&#123;<span class="string">&quot;AA&quot;</span>, <span class="string">&quot;BB&quot;</span>, <span class="string">&quot;CC&quot;</span>&#125;);</span><br><span class="line">System.out.println(list);</span><br><span class="line"><span class="comment">// Arrays.asList会优先将其当做一个元素，而不会自动装箱当做是两个元素</span></span><br><span class="line">List arr1 = Arrays.asList(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">123</span>, <span class="number">456</span>&#125;);</span><br><span class="line">System.out.println(arr1.size()); <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">List arr2 = Arrays.asList(<span class="keyword">new</span> Integer[]&#123;<span class="number">123</span>, <span class="number">456</span>&#125;);</span><br><span class="line">System.out.println(arr2.size());<span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 推荐写法：避免错误</span></span><br><span class="line">List arr3 = Arrays.asList(<span class="number">123</span>, <span class="number">456</span>);</span><br><span class="line">System.out.println(arr3.size()); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<h3 id="3、Iterator迭代器接口"><a href="#3、Iterator迭代器接口" class="headerlink" title="3、Iterator迭代器接口"></a>3、Iterator迭代器接口</h3><h4 id="3-1、Iterator迭代器概述"><a href="#3-1、Iterator迭代器概述" class="headerlink" title="3.1、Iterator迭代器概述"></a>3.1、Iterator迭代器概述</h4><ul>
<li>Iterator对象称为迭代器，主要用于遍历Collection集合中的元素</li>
<li>GOF给迭代器模式的定义为：提供一种方法访问一个容器(container)对象中各个元素，而又不需暴露该对象的内部细节。迭代器模式，就是为容器而生。</li>
</ul>
<h4 id="3-1、Iterator的使用"><a href="#3-1、Iterator的使用" class="headerlink" title="3.1、Iterator的使用"></a>3.1、Iterator的使用</h4><ul>
<li>内部的方法：hasNext()和next()</li>
<li>集合对象每次调用iterator()方法都得到一个全新的迭代器对象</li>
<li>内部定义了remove()，可以在遍历的时候，删除集合中的元素。如果还未调用next()或在上一次调用next方法之后已经调用了remove方法，再调用remove会报IllegalStateException</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Iterator iterator = coll.iterator();</span><br><span class="line"><span class="comment">// hasNext()：判断是否还有下一个元素</span></span><br><span class="line"><span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">    <span class="comment">// next()：1、指针下移；2、将下移以后集合位置上的元素返回</span></span><br><span class="line">    System.out.println(iterator.next());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>foreach遍历集合时，内部仍然调用了迭代器</p>
</blockquote>
<h3 id="4、Conllection子接口一：List"><a href="#4、Conllection子接口一：List" class="headerlink" title="4、Conllection子接口一：List"></a>4、Conllection子接口一：List</h3><h4 id="4-1、List框架"><a href="#4-1、List框架" class="headerlink" title="4.1、List框架"></a>4.1、List框架</h4><ul>
<li>Collection接口：单列集合，用来存储一个一个的对象<ul>
<li>List接口：存储有序的、可重复的数据<ul>
<li>ArrayList：作为List接口的主要实现类：线程不安全，效率高；底层使用Object[] elementData存储</li>
<li>LinkedList：对于频繁的插入、删除操作，使用此类效率比ArrayList高；底层使用双向链表存储</li>
<li>Vector：作为List接口的古老实现类；线程安全的，效率低；底层使用Object[] elementData存储</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="4-2、ArrayList的源码分析"><a href="#4-2、ArrayList的源码分析" class="headerlink" title="4.2、ArrayList的源码分析"></a>4.2、ArrayList的源码分析</h4><ul>
<li><p>ArrayList的源码分析</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 1、JDK 7情况下</span></span><br><span class="line"><span class="comment"> *  ArrayList list = new ArrayList();//底层创建了长度是10的Object[]数组elementData</span></span><br><span class="line"><span class="comment"> *  list.add(123);//elementData[0] = new Integer(123);</span></span><br><span class="line"><span class="comment"> *  ...</span></span><br><span class="line"><span class="comment"> *  list.add(11);如果此次的添加导致底层elementData数组容量不够，则扩容。</span></span><br><span class="line"><span class="comment"> *  默认情况下，扩容为原来的容量的1.5倍，同时需要将原有数组中的数据复制到新的数组中</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  结论：建议开发中使用带参的构造器：ArrayList list = new ArrayList(int capacity)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 2、JDK 8中ArrayList的变化：</span></span><br><span class="line"><span class="comment"> *  ArrayList list = new ArrayList();//底层Object[] elementData初始化为&#123;&#125;.并没有创建长度是10的Object[]数组elementData</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  list.add(123);//第一次调用add()时，底层才创建了长度10的数组，并将数据123添加到elementData[0]</span></span><br><span class="line"><span class="comment"> *  ...</span></span><br><span class="line"><span class="comment"> *  后续的添加和扩容操作与JDK 7无异</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 3、小结：JDK 7中的ArrayList的对象的创建类似于单例的饿汉式，而JDK 8中的ArrayList的对象</span></span><br><span class="line"><span class="comment"> *          的创建类似于单例的懒汉式，延迟了数组的创建，节省内存。</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure></li>
<li><p>LinkedList的源码分析</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * LinkedList list = new LinkedList(); 内部声明了Node类型的first和last属性，默认值为null</span></span><br><span class="line"><span class="comment"> * list.add(123);//将123封装到Node中，创建了Node对象。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 其中，Node的定义：体现了LinkedList的双向链表的说法</span></span><br><span class="line"><span class="comment"> * private static class Node&lt;E&gt; &#123;</span></span><br><span class="line"><span class="comment"> *      E item;</span></span><br><span class="line"><span class="comment"> *      Node&lt;E&gt; next;</span></span><br><span class="line"><span class="comment"> *      Node&lt;E&gt; prev;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *      Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</span></span><br><span class="line"><span class="comment"> *         this.item = element;</span></span><br><span class="line"><span class="comment"> *         this.next = next;</span></span><br><span class="line"><span class="comment"> *         this.prev = prev;</span></span><br><span class="line"><span class="comment"> *      &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure></li>
<li><p>Vector的源码分析：JDK 7和JDK 8中通过Vector()构造器创建对象时，底层都创建了长度为10的数组，在扩容方面，默认扩容为原来数组长度的2倍。</p>
</li>
</ul>
<h4 id="4-3、面试题：ArrayList、LinkedList、Vector三者的异同？"><a href="#4-3、面试题：ArrayList、LinkedList、Vector三者的异同？" class="headerlink" title="4.3、面试题：ArrayList、LinkedList、Vector三者的异同？"></a>4.3、面试题：ArrayList、LinkedList、Vector三者的异同？</h4><ul>
<li>同：三个类都是实现了List接口，存储数据的特点相同：存储有序的、可重复的数据</li>
<li>不同：见4.1、List框架</li>
</ul>
<h4 id="4-4、List接口方法"><a href="#4-4、List接口方法" class="headerlink" title="4.4、List接口方法"></a>4.4、List接口方法</h4><ul>
<li>List除了从Collection集合继承的方法外，List集合里添加了一些根据索引来操作集合元素的方法</li>
<li>void add(int inde, Object ele)：在index位置插入ele元素</li>
<li>boolean addAll(int index, Collection eles)：从index位置开始将eles中所有元素添加进来</li>
<li>Object get(int index)：获取指定index位置的元素</li>
<li>int indexOf(Object obj)：返回obj在集合中首次出现的位置</li>
<li>int lastIndexOf(Object obj)：返回obj在当前集合中末次出现的位置</li>
<li>Object remove(int index)：移除指定index位置的元素，并返回此元素</li>
<li>Object set(int index, Object ele)：设置指定index位置的元素为ele</li>
<li>List subList(int fromIndex, int toIndex)：返回从fromIndex到toIndex位置的子集合</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 区分List中remove(int index)和remove(Object obj)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testListRemove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    List list = <span class="keyword">new</span> ArrayList();</span><br><span class="line">    list.add(<span class="number">1</span>);</span><br><span class="line">    list.add(<span class="number">2</span>);</span><br><span class="line">    list.add(<span class="number">3</span>);</span><br><span class="line">    updateList(list);</span><br><span class="line">    <span class="comment">// updateList1(list);</span></span><br><span class="line">    System.out.println(list);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">updateList</span><span class="params">(List list)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 注意区分是调用下标还是对象的remove方法</span></span><br><span class="line">    <span class="comment">// list.remove(2); // [1, 2]</span></span><br><span class="line">    <span class="comment">// list.remove(new Integer(2)); // [1, 3]</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">updateList1</span><span class="params">(Collection coll)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 多态，此时父类只有remove(Object obj)的方法</span></span><br><span class="line">    coll.remove(<span class="number">2</span>); <span class="comment">// [1, 3]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5、Conllection子接口二：Set"><a href="#5、Conllection子接口二：Set" class="headerlink" title="5、Conllection子接口二：Set"></a>5、Conllection子接口二：Set</h3><h4 id="5-1、Set接口的框架"><a href="#5-1、Set接口的框架" class="headerlink" title="5.1、Set接口的框架"></a>5.1、Set接口的框架</h4><ul>
<li>Collection接口：单列集合，用来存储一个一个的对象<ul>
<li>Set接口：存储无序的，不可重复的数据<ul>
<li>HashSet：作为Set接口的主要实现类：线程不安全；可以存储null值<ul>
<li>LinkedHashSet：作为HashSet的子类；遍历其内部数据时，可以按照添加的顺序进行遍历。对于频繁的遍历操作，LinkedHashSet效率高于HashSet</li>
</ul>
</li>
<li>TreeSet：可以按照添加对象的指定属性，进行排序</li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>Set接口中没有额外定义新的方法，使用的都是Collection中声明过的方法。</p>
</blockquote>
<h4 id="5-2、无序性与不可重复性（HashSet为例）"><a href="#5-2、无序性与不可重复性（HashSet为例）" class="headerlink" title="5.2、无序性与不可重复性（HashSet为例）"></a>5.2、无序性与不可重复性（HashSet为例）</h4><ul>
<li>无序性：不等于随机性。存储的数据在底层数组中并非按照数组索引的顺序添加，而是根据数据的哈希值决定的。</li>
<li>不可重复性：保证添加的元素按照equals()判断时，不能返回true。即：相同的元素只能添加一个。<ul>
<li>前提是哈希值相同，才会进行equals()判断</li>
</ul>
</li>
</ul>
<h4 id="5-3、HashSet的源码分析"><a href="#5-3、HashSet的源码分析" class="headerlink" title="5.3、HashSet的源码分析"></a>5.3、HashSet的源码分析</h4><ul>
<li>我们向HashSet中添加元素a，首先调用元素a所在类的hashCode()方法，计算元素a的哈希值，此哈希值接着通过某种算法计算出在HashSet底层数组中的存放位置（即为：索引位置），判断数组此位置上是否已经有元素：<ul>
<li>如果此位置上没有其他元素，则元素a添加成功。 —&gt; 情况1</li>
<li>如果此位置上有其他元素b（或以链表形式存在的多个元素），则比较元素a与元素b的hash值：<ul>
<li>如果hash值不相同，则元素a添加成功。 —&gt; 情况2</li>
<li>如果hash值相同，进而需要调用元素a所在类的equals()方法：<ul>
<li>equals()返回true，元素a添加失败</li>
<li>equals()返回false，则元素a添加成功。 —&gt; 情况3</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>对于添加成功的情况2和情况3而言：元素a与已经存在指定索引位置上数据以链表的方式存储。<ul>
<li>JDK 7：元素a放在数组中，指向原来的元素。</li>
<li>JDK 8：原来的元素在数组中，指向元素a</li>
<li>总结：七上八下</li>
</ul>
</li>
<li>HashSet底层：数组+链表的结构</li>
</ul>
<blockquote>
<p>要求：向Set中添加的数据，其所在的类一定要重写hashCode()和equals()。<br>要求：重写的hashCode()和equals()尽可能保持一致性：相等的对象必须具有相等的散列码。重写两个方法的小技巧：对象中用作equals()方法比较的Field，都应该用来计算hashCode值</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">HashSet set = <span class="keyword">new</span> HashSet();</span><br><span class="line"><span class="comment">// Person类中重写了hashCode()和equals()方法</span></span><br><span class="line">Person p1 = <span class="keyword">new</span> Person(<span class="number">1001</span>, <span class="string">&quot;AA&quot;</span>);</span><br><span class="line">Person p2 = <span class="keyword">new</span> Person(<span class="number">1002</span>, <span class="string">&quot;BB&quot;</span>);</span><br><span class="line"></span><br><span class="line">set.add(p1);</span><br><span class="line">set.add(p2);</span><br><span class="line">System.out.println(set); <span class="comment">// [Person&#123;id=1002, name=&#x27;BB&#x27;&#125;, Person&#123;id=1001, name=&#x27;AA&#x27;&#125;]</span></span><br><span class="line">p1.name = <span class="string">&quot;CC&quot;</span>;</span><br><span class="line">set.remove(p1);</span><br><span class="line">System.out.println(set); <span class="comment">// [Person&#123;id=1002, name=&#x27;BB&#x27;&#125;, Person&#123;id=1001, name=&#x27;CC&#x27;&#125;]</span></span><br><span class="line">set.add(<span class="keyword">new</span> Person(<span class="number">1001</span>, <span class="string">&quot;CC&quot;</span>));</span><br><span class="line">System.out.println(set); <span class="comment">// [Person&#123;id=1002, name=&#x27;BB&#x27;&#125;, Person&#123;id=1001, name=&#x27;CC&#x27;&#125;, Person&#123;id=1001, name=&#x27;CC&#x27;&#125;]</span></span><br><span class="line">set.add(<span class="keyword">new</span> Person(<span class="number">1001</span>, <span class="string">&quot;AA&quot;</span>));</span><br><span class="line">System.out.println(set); <span class="comment">// [Person&#123;id=1002, name=&#x27;BB&#x27;&#125;, Person&#123;id=1001, name=&#x27;CC&#x27;&#125;, Person&#123;id=1001, name=&#x27;CC&#x27;&#125;, Person&#123;id=1001, name=&#x27;AA&#x27;&#125;][Person&#123;id=1002, name=&#x27;BB&#x27;&#125;, Person&#123;id=1001, name=&#x27;CC&#x27;&#125;, Person&#123;id=1001, name=&#x27;CC&#x27;&#125;, Person&#123;id=1001, name=&#x27;AA&#x27;&#125;]</span></span><br></pre></td></tr></table></figure>

<h4 id="5-4、为什么用Eclipse-IDEA重写hashCode方法，有31这个数字？"><a href="#5-4、为什么用Eclipse-IDEA重写hashCode方法，有31这个数字？" class="headerlink" title="5.4、为什么用Eclipse/IDEA重写hashCode方法，有31这个数字？"></a>5.4、为什么用Eclipse/IDEA重写hashCode方法，有31这个数字？</h4><ul>
<li>选择系数的时候要选择尽量大的系数。因为如果计算出来的hash地址越大，所谓的“冲突”就越少，查找起来效率也会提高。（减少冲突）</li>
<li>并且31只占用了5bits，相乘造成数据溢出的概率较少。</li>
<li>31可以由i*31==(i&lt;&lt;5)-1表示，现在很多虚拟机里面都有做相关优化。（提高算法效率）</li>
<li>31是一个素数，素数作用就是如果我用一个数字来乘以这个素数，那么最终出来的结果只能被素数本身和被乘数还有1来整除！（减少冲突）</li>
</ul>
<h4 id="5-5、LinkedHashSet的使用"><a href="#5-5、LinkedHashSet的使用" class="headerlink" title="5.5、LinkedHashSet的使用"></a>5.5、LinkedHashSet的使用</h4><ul>
<li>LinkedHashSet作为HashSet的子类，在添加数据的同时，每个数据还维护了两个引用，记录此数据前一个数据和后一个数据</li>
<li>优点：对于频繁的遍历操作，LinkedHashSet效率高于HashSet</li>
</ul>
<h4 id="5-5、TreeSet的使用"><a href="#5-5、TreeSet的使用" class="headerlink" title="5.5、TreeSet的使用"></a>5.5、TreeSet的使用</h4><ul>
<li>向TreeSet中添加数据，要求是相同的类的对象</li>
<li>两种排列方法：自然排序（实现Comparable接口）和定制排序（Comparator）</li>
<li>自然排序中，比较两个对象是否相同的标准为：compareTo()返回0，不再是equals()</li>
<li>定制排序中，比较两个对象是否相同的标准为：compare()返回0，不再是equals()</li>
</ul>
<h3 id="6、Map接口"><a href="#6、Map接口" class="headerlink" title="6、Map接口"></a>6、Map接口</h3><h4 id="6-1、Map接口的框架"><a href="#6-1、Map接口的框架" class="headerlink" title="6.1、Map接口的框架"></a>6.1、Map接口的框架</h4><ul>
<li>Map：双列数据，存储key-value对的数据<ul>
<li>HashMap：作为Map的主要实现类；线程不安全的，效率高；可以存储null的key和value<ul>
<li>LinkedHashMap：保证在遍历map元素时，可以按照添加的顺序实现遍历。原因：在原有的HashMap底层结构基础上，添加了一对指针，指向前一个和后一个元素，对于频繁的遍历操作，此类执行效率高于HashMap</li>
</ul>
</li>
<li>TreeMap：保证按照添加的key-value对进行排序；实现排序遍历。此时考虑key的自然排序或定制排序。底层使用红黑树</li>
<li>Hashtable：作为古老的实现类；线程安全的，效率低；不能存储null的key和value<ul>
<li>Properties：常用来处理配置文件。key和value都是String类型</li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>HashMap的底层：数组+链表(JDK 7及之前)或数组+链表+红黑树(JDK 8)</p>
</blockquote>
<h4 id="6-2、Map结构的理解（以HashMap为例）"><a href="#6-2、Map结构的理解（以HashMap为例）" class="headerlink" title="6.2、Map结构的理解（以HashMap为例）"></a>6.2、Map结构的理解（以HashMap为例）</h4><ul>
<li>Map中的key：无序的、不可重复的，使用Set存储所有的key –&gt; key所在的类要重写equals()和hashCode()</li>
<li>Map中的value：无序的、可重复的，使用Collection存储所有的value –&gt; value所在的类型要重写equals()</li>
<li>一个键值对：key-value构成了一个Entry对象</li>
<li>Map中的entry：无序的、不可重复的，使用Set存储所有的entry</li>
</ul>
<h4 id="6-3、HashMap的底层实现原理？（以JDK-7为例）"><a href="#6-3、HashMap的底层实现原理？（以JDK-7为例）" class="headerlink" title="6.3、HashMap的底层实现原理？（以JDK 7为例）"></a>6.3、HashMap的底层实现原理？（以JDK 7为例）</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * HashMap map = new HashMap();</span></span><br><span class="line"><span class="comment"> * 在实例化以后，底层创建了长度是16的一对数组Entry[] table</span></span><br><span class="line"><span class="comment"> * ...可能已经执行过多次put...</span></span><br><span class="line"><span class="comment"> * map.put(key1, value1):</span></span><br><span class="line"><span class="comment"> *  首先，调用key1所在类的hashCode()计算key1哈希值，此哈希值经过某种算法计算以后，得到在Entry数组中的存放位置。</span></span><br><span class="line"><span class="comment"> *  如果此位置上的数据为空，此时的key1-value1添加成功。 ---&gt; 情况1</span></span><br><span class="line"><span class="comment"> *  如果此位置上的数据不为空，（意味着此位置上存在一个或多个数据（以链表形式）），比较key1和已经存在的一个或多个数据的哈希值：</span></span><br><span class="line"><span class="comment"> *      如果key1的哈希值与已经存在的数据的哈希值都不相同，此时key1-value1添加成功。 ---&gt; 情况2</span></span><br><span class="line"><span class="comment"> *      如果key1的哈希值和已经存在的某一个数据（key2-value2）的哈希值相同，继续比较：调用key1所在类的equals(key2)</span></span><br><span class="line"><span class="comment"> *          如果equals()返回false：此时key1-value1添加成功。---&gt; 情况3</span></span><br><span class="line"><span class="comment"> *          如果equals()返回true：使用value1替换value2</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  补充：关于情况2和情况3：此时key1-value1和原来的数据以链表的方法存储。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  在不断的添加过程中，会涉及到扩容问题，当超过临界值(且要存放的位置非空)时，扩容。默认的扩容方式：扩容为原来容量的2倍，并将原有的数据复制过来。</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<ul>
<li>JDK 8相较于JDK 7在底层实现方面的不同：<ul>
<li>1、new HashMap()：底层没有创建一个长度为16的数组</li>
<li>2、JDK 8底层的数组是：Node[]，而非Entry[]</li>
<li>3、首次调用put()方法时，底层创建长度为16的数组</li>
<li>4、JDK 7的底层结构只有：数组+链表。JDK 8中底层结构：数组+链表+红黑树。<ul>
<li>形成链表时，依旧符合“七上八下”(JDK 7：新的元素指向旧的元素。JDK 8：旧的元素指向新的元素)</li>
<li>当数组的某一个索引位置上的元素以链表形式存在的数据个数 &gt; 8 且当前数组的长度 &gt; 64时，此时此索引位置上的所有数据改为使用红黑树存储。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="6-4、HashMap源码中的重要常量"><a href="#6-4、HashMap源码中的重要常量" class="headerlink" title="6.4、HashMap源码中的重要常量"></a>6.4、HashMap源码中的重要常量</h4><ul>
<li>DEFAULT_INITIAL_CAPACITY：HashMap的默认值，16</li>
<li>DEFAULT_LOAD_FACTOR：HashMap的默认加载因子：0.75</li>
<li>threahold：扩容的临界值，=容器*填充因子：16 * 0.75 =&gt; 12</li>
<li>TREEIFY_THRESHOLD：Bucket中链表长度大于该默认值，转化为红黑树：8</li>
<li>MIN_TREEIFY_CAPACITY：桶中的Node被树化时最小的hash表容量：64</li>
</ul>
<blockquote>
<p>面试题：负载因子值的大小，对HashMap有什么影响？<br>1、负载因子的大小决定了HashMap的数据密度<br>2、负载因子越大密度越大，发生碰撞的几率越高，数组中的链表越容易长，造成查询或插入时的比较次数增多，性能会下降。<br>3、负载因子越小，就越容易触发扩容，数据密度也越小，意味着发生碰撞的几率越小，数组中的链表也就越短，查询和插入时比较的次数也越小，性能会更高。但是会浪费一定的内容空间。而且经常扩容也会影响性能，建议初始化预设大一点的空间<br>4、按照其他语言的参考及研究经验，会考虑将负载因子设置在0.7~0.75，此时平均检索长度接近于常数</p>
</blockquote>
<h4 id="6-5、LinkedHashMap的底层原理"><a href="#6-5、LinkedHashMap的底层原理" class="headerlink" title="6.5、LinkedHashMap的底层原理"></a>6.5、LinkedHashMap的底层原理</h4><ul>
<li>LinkedHashMap底层使用的结构与HashMap相同，因为LinkedHashMap继承于HashMap</li>
<li>区别就在于：LinkedHashMap内部提供了Entry，替换HashMap中的Node</li>
<li>HashMap中的内部类：Node<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">  <span class="keyword">final</span> K key;</span><br><span class="line">  V value;</span><br><span class="line">  Node&lt;K,V&gt; next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>LinkedHashMap中的内部类：Entry<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">HashMap</span>.<span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">  Entry&lt;K,V&gt; before, after;<span class="comment">// 能够记录添加的元素的先后顺序</span></span><br><span class="line">  Entry(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">      <span class="keyword">super</span>(hash, key, value, next);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="6-5、Map接口常用方法"><a href="#6-5、Map接口常用方法" class="headerlink" title="6.5、Map接口常用方法"></a>6.5、Map接口常用方法</h4><ul>
<li>添加、删除、修改操作：<ul>
<li>Object put(Object key, Object value)：指定key-value添加到(或修改)当前map对象中</li>
<li>void putAll(Map m)：将m中的所有key-value对存放到当前map中</li>
<li>Object remove(Object key)：移除指定key的key-value对，并返回value</li>
<li>void clear()：清空当前map中的所有数据</li>
</ul>
</li>
<li>元素查询的操作：<ul>
<li>Object get(Object key)：获取指定key对应的value</li>
<li>boolean containsKey(Object key)：是否包含指定的key</li>
<li>boolean containsValue(Object value)：是否包含指定的value</li>
<li>int size()：返回map中key-value对的个数</li>
<li>boolean isEmpty()：判断当前map是否为空</li>
<li>boolean equals(Object obj)：判断当前map和参数对象obj是否相等</li>
</ul>
</li>
<li>元视图操作的方法：<ul>
<li>Set keySet()：返回所有key构成的Set集合</li>
<li>Collection values()：返回所有value构成的Collection集合</li>
<li>Set entrySet()：返回所有key-value对构成的Set集合</li>
</ul>
</li>
</ul>
<h3 id="7、Collections工具类"><a href="#7、Collections工具类" class="headerlink" title="7、Collections工具类"></a>7、Collections工具类</h3><ul>
<li>Collections是一个操作Set、List和Map等集合的工具类</li>
<li>Collections中提供了一系列静态的方法对集合元素进行排序、查询和修改等操作，还提供了对集合对象设置不可变、对集合对象实现同步控制等方法</li>
<li>排序操作：(均为static方法)<ul>
<li>reverse(List)：反转List中元素的顺序</li>
<li>shuffle(List)：对List集合元素进行随机排序</li>
<li>sort(List)：根据元素的自然顺序对指定List集合元素按升序排序</li>
<li>sort(List, Comparator)：根据指定的Comparator产生的顺序对List集合元素进行排序</li>
<li>swap(List, int, int)：将指定list集合中的i处元素和j处元素进行交换</li>
</ul>
</li>
<li>查找、替换<ul>
<li>Object max(Collection)：根据元素的自然顺序，返回给定集合中的最大值</li>
<li>Object max(Collection, Comparator)：根据Comparator指定的顺序，返回给定集合中的最大元素</li>
<li>Object min(Collection)</li>
<li>Object min(Collection, Comparator)</li>
<li>int frequency(Collection, Object)：返回指定集合中指定元素的出现次数</li>
<li>void copy(List dest, List src)：将src中的内容复制到dest中</li>
<li>boolean replaceAll(List list, Object oldVal, Object newVal)：使用新值替换List对象的所有旧值</li>
</ul>
</li>
<li>同步控制<ul>
<li>synchronizedXxx()：将指定集合包装成线程同步的集合，从而可以解决多线程并发访问集合时的线程安全问题</li>
<li>synchronizedList(List list)</li>
<li>synchronizedMap(Map map)</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List list = <span class="keyword">new</span> ArrayList();</span><br><span class="line">list.add(<span class="number">123</span>);</span><br><span class="line">list.add(<span class="number">43</span>);</span><br><span class="line">list.add(<span class="number">765</span>);</span><br><span class="line">list.add(-<span class="number">97</span>);</span><br><span class="line">list.add(<span class="number">0</span>);</span><br><span class="line"><span class="comment">// 报异常：java.lang.IndexOutOfBoundsException: Source does not fit in dest</span></span><br><span class="line"><span class="comment">// List dest = new ArrayList();</span></span><br><span class="line"><span class="comment">// Collections.copy(dest, list);</span></span><br><span class="line"><span class="comment">// The destination list must be at least as long as the source list. </span></span><br><span class="line"><span class="comment">// If it is longer, the remaining elements in the destination list are unaffected.</span></span><br><span class="line">List dest = Arrays.asList(<span class="keyword">new</span> Object[list.size()]);</span><br><span class="line">System.out.println(dest.size()); <span class="comment">//list.size();</span></span><br><span class="line">Collections.copy(dest, list);</span><br><span class="line">System.out.println(dest);</span><br></pre></td></tr></table></figure>

<h2 id="五、泛型"><a href="#五、泛型" class="headerlink" title="五、泛型"></a>五、泛型</h2><h3 id="1、为什么要有泛型"><a href="#1、为什么要有泛型" class="headerlink" title="1、为什么要有泛型"></a>1、为什么要有泛型</h3><h4 id="1-1、泛型的概念"><a href="#1-1、泛型的概念" class="headerlink" title="1.1、泛型的概念"></a>1.1、泛型的概念</h4><ul>
<li>所谓泛型，就是允许在定义类、接口时通过一个标识表示类中某个属性的类型或者是某个方法的返回值及参数类型。这个类型参数将在使用时（例如，继承或实现这个接口，用这个类型声明变量、创建对象时）确定（即传入实际的类型参数，也称为类型实参）。</li>
</ul>
<h4 id="1-2、泛型的引入背景"><a href="#1-2、泛型的引入背景" class="headerlink" title="1.2、泛型的引入背景"></a>1.2、泛型的引入背景</h4><ul>
<li>集合容器类在设计阶段/声明阶段不能确定这个容器到底实际存的是什么类型的对象，所以在JDK1.5之前只能把元素类型设计为Object，JDK1.5之后使用泛型来解决。因为这个时候除了元素的类型不确定，其他的部分是确定的，例如关于这个元素如何保存，如何管理等是确定的，因此此时把元素的类型设计成一个参数，这个类型参数叫做泛型。</li>
</ul>
<h3 id="2、在集合中使用泛型"><a href="#2、在集合中使用泛型" class="headerlink" title="2、在集合中使用泛型"></a>2、在集合中使用泛型</h3><ul>
<li>集合接口或集合类在JDK5.0时都修改为带泛型的结构</li>
<li>在实例化集合类时，可以指明具体的泛型类型</li>
<li>指明完以后，在集合类或接口中凡是定义类或接口时，内部结构（比如：方法、构造器、属性等）使用到类的泛型的位置，都指定为实例化的泛型类型<ul>
<li>比如：add(E e) —&gt; 实例化以后：add(Integer e)</li>
</ul>
</li>
<li>注意点：泛型的类型必须是类，不能是基本数据类型。需要用到基本数据类型的位置，拿包装类替换</li>
<li>如果实例化时，没有指明泛型的类型，默认类型为java.lang.Object类型</li>
</ul>
<h3 id="3、自定义泛型结构"><a href="#3、自定义泛型结构" class="headerlink" title="3、自定义泛型结构"></a>3、自定义泛型结构</h3><ul>
<li>泛型类可能有多个参数，此时应将多个参数一起放在尖括号内。比如：&lt;E1,E2,E3&gt;</li>
<li>泛型类的构造器如下：public GenericClass(){}</li>
<li>实例化后，操作原来泛型位置的结构必须与指定的泛型类型一致。</li>
<li>泛型不同的引用不能相互赋值<ul>
<li>尽管在编译时<code>ArrayList&lt;String&gt;</code>和<code>ArrayList&lt;Interger&gt;</code>是两种类型，但是，在运行时只有一个ArrayList被加载到JVM中。</li>
</ul>
</li>
<li>泛型如果不指定，将被擦除，泛型对应的类型均按照Object处理，但不等价于Object。经验：泛型要使用一路都用。要不用，一路都不要用。</li>
<li>如果泛型结构是一个接口或抽象类，则不可以创建泛型类的对象</li>
<li>JDK1.7，泛型的简化操作：<code>ArrayList&lt;Fruit&gt; flist = new ArrayList&lt;&gt;();</code></li>
<li>泛型的指定中不能使用基本数据类型，可以使用包装类替换</li>
<li>在类/接口上声明的泛型，在本类或本接口中即代表某种类型，可以作为非静态属性的类型、非静态方法的参数类型、非静态方法的返回值类型。但在静态方法中不能使用类的泛型。</li>
<li>异常类不能是泛型的</li>
<li>不能使用<code>new E[]</code>。但是可以：<code>E[] elements = (E[])new Object[capacity];</code></li>
<li>父类有泛型，子类可以选择保留泛型也可以选择指定泛型类型：<ul>
<li>子类不保留父类的泛型：按需实现<ul>
<li>没有类型，擦除</li>
<li>具体类型</li>
</ul>
</li>
<li>子类保留父类的泛型：泛型子类<ul>
<li>全部保留</li>
<li>部分保留</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义泛型类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;T&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Order</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String orderName;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> orderId;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//类的内部结构就可以使用类的泛型</span></span><br><span class="line">    <span class="keyword">private</span> T orderT;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Order</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Order</span><span class="params">(String orderName, <span class="keyword">int</span> orderId, T orderT)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.orderName = orderName;</span><br><span class="line">        <span class="keyword">this</span>.orderId = orderId;</span><br><span class="line">        <span class="keyword">this</span>.orderT = orderT;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getOrderT</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> orderT;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setOrderT</span><span class="params">(T orderT)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.orderT = orderT;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 泛型方法：在方法中出现了泛型的结构，泛型参数与类的泛型参数没有任何关系</span></span><br><span class="line">    <span class="comment">// 换句话说，泛型方法所属的类是不是泛型类都没有关系</span></span><br><span class="line">    <span class="keyword">public</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">copyFormArrayToList</span><span class="params">(E[] arr)</span> </span>&#123;</span><br><span class="line">      ArrayList&lt;E&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span> (E e : arr) &#123;</span><br><span class="line">        list.add(e);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> list;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">// 泛型方法，可以声明为静态的。原因：泛型参数是在调用方法时确定的。并非在实例化类时确定的。</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">copyFormArrayToList1</span><span class="params">(E[] arr)</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fatherr</span>&lt;<span class="title">T1</span>, <span class="title">T2</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 子类不保留父类的泛型</span></span><br><span class="line"><span class="comment">// 1、没有类型，擦除</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son1</span>&lt;<span class="title">A</span>, <span class="title">B</span>&gt; <span class="keyword">extends</span> <span class="title">Father</span> </span>&#123;</span><br><span class="line">  <span class="comment">//等价于 class Son extends Father&lt;Object, Object&gt;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 2、具体类型</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son2</span>&lt;<span class="title">A</span>, <span class="title">B</span>&gt; <span class="keyword">extends</span> <span class="title">Father</span>&lt;<span class="title">Ineger</span>, <span class="title">String</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 子类保留父类的泛型</span></span><br><span class="line"><span class="comment">// 1、全部保留</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son3</span>&lt;<span class="title">T1</span>, <span class="title">T2</span>, <span class="title">A</span>, <span class="title">B</span>&gt; <span class="keyword">extends</span> <span class="title">Father</span>&lt;<span class="title">T1</span>, <span class="title">T2</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 2、部分保留</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son4</span>&lt;<span class="title">T2</span>, <span class="title">A</span>, <span class="title">B</span>&gt; <span class="keyword">extends</span> <span class="title">Father</span>&lt;<span class="title">T1</span>, <span class="title">T2</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="4、泛型在继承上的体现"><a href="#4、泛型在继承上的体现" class="headerlink" title="4、泛型在继承上的体现"></a>4、泛型在继承上的体现</h3><ul>
<li>虽然类A是类B的父类，但是<code>G&lt;A&gt;</code>和<code>G&lt;B&gt;</code>二者不具备子父类关系，二者是并列关系<ul>
<li>补充：类A是类B的父类，<code>A&lt;G&gt;</code>是<code>B&lt;G&gt;</code>的父类</li>
</ul>
</li>
</ul>
<h3 id="5、通配符的使用"><a href="#5、通配符的使用" class="headerlink" title="5、通配符的使用"></a>5、通配符的使用</h3><ul>
<li>使用类型通配符：<code>?</code><ul>
<li><code>List&lt;?&gt;</code>是<code>List&lt;String&gt;</code>、<code>List&lt;Object&gt;</code>等各种泛型List的父类</li>
</ul>
</li>
<li>读取<code>List&lt;?&gt;</code>的对象list中的元素时，永远是安全的，因为不管list的真实类型是什么，它包含的都是Object</li>
<li>写入list中的元素时，不行。因为我们不知道元素类型，不能向其中添加对象。<ul>
<li>唯一的例外是null，它是所有类型的成员</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    List&lt;?&gt; list = <span class="keyword">null</span>;</span><br><span class="line">    List&lt;String&gt; list1 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    list1.add(<span class="string">&quot;AA&quot;</span>);</span><br><span class="line">    list1.add(<span class="string">&quot;BB&quot;</span>);</span><br><span class="line">    list1.add(<span class="string">&quot;CC&quot;</span>);</span><br><span class="line">    print(list1);</span><br><span class="line">    </span><br><span class="line">    list = list1;</span><br><span class="line">    <span class="comment">// 添加：对于List&lt;?&gt;不能向其内部添加数据</span></span><br><span class="line">    <span class="comment">// list.add(&quot;AA&quot;);</span></span><br><span class="line">    <span class="comment">// list.add(&quot;?&quot;);</span></span><br><span class="line">    <span class="comment">// 除了添加null</span></span><br><span class="line">    list.add(<span class="keyword">null</span>);</span><br><span class="line">    <span class="comment">//获取（读取）：允许读取数据，读取的数据类型为Object</span></span><br><span class="line">    Object o = list.get(<span class="number">0</span>);</span><br><span class="line">    System.out.println(o);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(List&lt;?&gt; list)</span> </span>&#123;</span><br><span class="line">    Iterator&lt;?&gt; iterator = list.iterator();</span><br><span class="line">    <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">        Object obj = iterator.next();</span><br><span class="line">        System.out.println(obj);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>&lt;? extentds A&gt;</code> (无穷小, A]<ul>
<li>只允许泛型为A及A子类的引用调用</li>
</ul>
</li>
<li><code>&lt;? super A&gt;</code> [A, 无穷大)<ul>
<li>只允许泛型为A及A父类的引用调用</li>
</ul>
</li>
</ul>
<h2 id="六、IO流"><a href="#六、IO流" class="headerlink" title="六、IO流"></a>六、IO流</h2><h3 id="1、File类的使用"><a href="#1、File类的使用" class="headerlink" title="1、File类的使用"></a>1、File类的使用</h3><h4 id="1-1、File类的理解"><a href="#1-1、File类的理解" class="headerlink" title="1.1、File类的理解"></a>1.1、File类的理解</h4><ul>
<li>File类的一个对象，代表一个文件或一个文件目录(俗称：文件夹)</li>
<li>File类声明在java.io包下</li>
<li>File类中涉及到关于文件或文件目录的创建、删除、重命名、修改时间、文件大小等方法，并未涉及到写入或读取文件内容的操作。如果需要读取或写入文件内容，必须使用IO流来完成。</li>
<li>后续File类的对象常会作为参数传递到流的构造器中，指明读取或写入的“终点”</li>
</ul>
<h4 id="1-2、File的实例化"><a href="#1-2、File的实例化" class="headerlink" title="1.2、File的实例化"></a>1.2、File的实例化</h4><ul>
<li>常见构造器<ul>
<li>File(String filePath)</li>
<li>File(String parentPath, String childPath)</li>
<li>File(File parentFile, String childPath)</li>
</ul>
</li>
<li>路径的分类<ul>
<li>相对路径：相较于某个路径下，指明的路径</li>
<li>绝对路径：包含盘符在内的文件或文件目录的路径</li>
</ul>
</li>
<li>路径分隔符<ul>
<li>public static final String separator：根据操作系统，动态的提供分隔符</li>
</ul>
</li>
</ul>
<h4 id="1-3、常用方法"><a href="#1-3、常用方法" class="headerlink" title="1.3、常用方法"></a>1.3、常用方法</h4><ul>
<li>File类的获取功能<ul>
<li>public String getAbsolutePath()：获取绝对路径</li>
<li>public String getPath()：获取路径</li>
<li>public String getName()：获取名称</li>
<li>public String getParent()：获取上层文件目录。若无，返回null</li>
<li>public long length()：获取文件长度（即：字节数）。不能获取目录的长度。</li>
<li>public long lastModified()：获取最后一次的修改时间，毫秒值</li>
<li>public String[] list()：获取指定目录下的所有文件或文件目录的名称数组</li>
<li>public File[] listFiles()：获取指定目录下的所有文件或文件目录的File数组</li>
</ul>
</li>
<li>File类的重命名功能<ul>
<li>public boolean renameTo(File dest)：把文件重命名为指定的文件路径。要想保证返回true，需要源文件在硬盘中存在，且目标文件不能在硬盘中存在</li>
</ul>
</li>
<li>File类的判断功能<ul>
<li>public boolean isDirectory()：判断是否是文件目录</li>
<li>public boolean isFile()：判断是否是文件</li>
<li>public boolean exists()：判断是否存在</li>
<li>public boolean canRead()：判断是否可读</li>
<li>public boolean canWrite()：判断是否可写</li>
<li>public boolean isHidden()：判断是否隐藏</li>
</ul>
</li>
<li>File类的创建功能<ul>
<li>public boolean creatNewFile()：创建文件。若文件存在，则不创建，返回false</li>
<li>public boolean mkdir()：创建文件目录。如果文件目录存在，就不创建了。如果此文件目录的上层目录不存在，也不创建。</li>
<li>public boolean mkdirs()：创建文件目录。如果上层文件目录不存在，一并创建</li>
</ul>
</li>
<li>File类的删除功能<ul>
<li>public boolean delete()：删除文件或文件夹。要删除一个文件目录，请注意该文件目录内不能包含文件或文件目录</li>
</ul>
</li>
</ul>
<h3 id="2、IO原理及流的分类"><a href="#2、IO原理及流的分类" class="headerlink" title="2、IO原理及流的分类"></a>2、IO原理及流的分类</h3><h4 id="2-1、流的分类"><a href="#2-1、流的分类" class="headerlink" title="2.1、流的分类"></a>2.1、流的分类</h4><ul>
<li>按操作数据单位不同分为：字节流、字符流</li>
<li>按数据流的流向不同分为：输入流、输出流</li>
<li>按流的角色的不同分为：节点流、处理流</li>
</ul>
<h4 id="2-2、流的体系结构"><a href="#2-2、流的体系结构" class="headerlink" title="2.2、流的体系结构"></a>2.2、流的体系结构</h4><table>
<thead>
<tr>
<th align="left">分类</th>
<th align="left">字节输入流</th>
<th align="left">字节输出流</th>
<th align="left">字符输入流</th>
<th align="left">字符输出流</th>
</tr>
</thead>
<tbody><tr>
<td align="left">抽象基类</td>
<td align="left"><strong>InputStream</strong></td>
<td align="left"><strong>OutputStream</strong></td>
<td align="left"><strong>Reader</strong></td>
<td align="left"><strong>Writer</strong></td>
</tr>
<tr>
<td align="left">访问文件</td>
<td align="left"><strong>FileInputStream</strong></td>
<td align="left"><strong>FileOutputStream</strong></td>
<td align="left"><strong>FileReader</strong></td>
<td align="left"><strong>FileWriter</strong></td>
</tr>
<tr>
<td align="left">访问数组</td>
<td align="left">ByteArrayInputStream</td>
<td align="left">ByteArrayOutputStream</td>
<td align="left">CharArrayReader</td>
<td align="left">CharArrayWriter</td>
</tr>
<tr>
<td align="left">访问管道</td>
<td align="left">PipedInputStream</td>
<td align="left">PipedOutputStream</td>
<td align="left">PipedReader</td>
<td align="left">PipedWriter</td>
</tr>
<tr>
<td align="left">访问字符串</td>
<td align="left"></td>
<td align="left"></td>
<td align="left">StringReader</td>
<td align="left">StringWriter</td>
</tr>
<tr>
<td align="left">缓冲流</td>
<td align="left"><strong>BufferedInputStream</strong></td>
<td align="left"><strong>BufferedOutputStream</strong></td>
<td align="left"><strong>BufferedReader</strong></td>
<td align="left"><strong>BufferedWriter</strong></td>
</tr>
<tr>
<td align="left">转换流</td>
<td align="left"></td>
<td align="left"></td>
<td align="left"><strong>InputStreamReader</strong></td>
<td align="left"><strong>OutputStreamWriter</strong></td>
</tr>
<tr>
<td align="left">对象流</td>
<td align="left"><strong>ObjectInputStream</strong></td>
<td align="left"><strong>ObjectOutputStream</strong></td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"></td>
<td align="left">FilterInputStream</td>
<td align="left">FilterOutputStream</td>
<td align="left">FilterReader</td>
<td align="left">FilterWriter</td>
</tr>
<tr>
<td align="left">打印流</td>
<td align="left"></td>
<td align="left">PrintStream</td>
<td align="left"></td>
<td align="left">PrintWriter</td>
</tr>
<tr>
<td align="left">推回输入流</td>
<td align="left">PushbackInputStream</td>
<td align="left"></td>
<td align="left">PushbackReader</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">特殊流</td>
<td align="left">DataInputStream</td>
<td align="left">DataOutputStream</td>
<td align="left"></td>
<td align="left"></td>
</tr>
</tbody></table>
<h4 id="2-3、输入、输出的标准化过程"><a href="#2-3、输入、输出的标准化过程" class="headerlink" title="2.3、输入、输出的标准化过程"></a>2.3、输入、输出的标准化过程</h4><ul>
<li>输入过程<ul>
<li>创建File类的对象，指明读取的数据的来源。（要求此文件一定要存在）</li>
<li>创建相应的输入流，将File类的对象作为参数，传入流的构造器中</li>
<li>具体的读入过程</li>
<li>关闭流资源</li>
</ul>
</li>
<li>输出过程<ul>
<li>创建File类的对象，指明写出的数据的位置。（不要求此文件一定要存在）</li>
<li>创建相应的输出流，将File类的对象作为参数，传入流的构造器中</li>
<li>具体的写出过程</li>
<li>关闭流资源</li>
</ul>
</li>
</ul>
<blockquote>
<p>说明：程序中出现的异常需要使用try-catch-finally处理</p>
</blockquote>
<h3 id="3、节点流（或文件流）"><a href="#3、节点流（或文件流）" class="headerlink" title="3、节点流（或文件流）"></a>3、节点流（或文件流）</h3><h4 id="3-1、FileReader的使用"><a href="#3-1、FileReader的使用" class="headerlink" title="3.1、FileReader的使用"></a>3.1、FileReader的使用</h4><ul>
<li>read()的理解：返回读入的一个字符。如果达到文件末尾，返回-1</li>
<li>异常的处理：为了保证流资源一定可以执行关闭操作。需要使用try-catch-finally处理</li>
<li>读入的文件一定要存在，否则就会报FileNotFoundException</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testFileReader1</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    FileReader fr = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 1、File类的实例化</span></span><br><span class="line">        File file = <span class="keyword">new</span> File(<span class="string">&quot;hello.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2、FileReader流的实例化</span></span><br><span class="line">        fr = <span class="keyword">new</span> FileReader(file);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3、读入的操作</span></span><br><span class="line">        <span class="comment">// read(char[] cbuf)：返回每次读入cbuf数组中的字符的个数。如果达到文件末尾则返回-1</span></span><br><span class="line">        <span class="keyword">char</span>[] cbuf = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">5</span>];</span><br><span class="line">        <span class="keyword">int</span> len;</span><br><span class="line">        <span class="keyword">while</span> ((len = fr.read(cbuf)) != -<span class="number">1</span>) &#123;</span><br><span class="line">            String str = <span class="keyword">new</span> String(cbuf, <span class="number">0</span>, len);</span><br><span class="line">            System.out.println(str);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (fr != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 4、关闭资源</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                fr.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-2、FileWriter的使用"><a href="#3-2、FileWriter的使用" class="headerlink" title="3.2、FileWriter的使用"></a>3.2、FileWriter的使用</h4><ul>
<li>输出操作，对应的File可以不存在。并不会报异常</li>
<li>File对应的硬盘中的文件如果不存在，在输出的过程中，会自动创建此文件。</li>
<li>File对应的硬盘中的文件如果存在：<ul>
<li>如果流使用的构造器是：FileWriter(file, false) / FileWriter(file)：对原有文件的覆盖</li>
<li>如果流使用的构造器是：FileWriter(file, true)：不会对原有文件覆盖，而是在原有文件基础上追加内容</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testFileWriter</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    FileWriter fw = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 1、提供File类的对象，指明写出到的文件</span></span><br><span class="line">        File file = <span class="keyword">new</span> File(<span class="string">&quot;hello1.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2、提供FileWriter的对象，用于数据的写出</span></span><br><span class="line">        fw = <span class="keyword">new</span> FileWriter(file, <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3、写出的操作</span></span><br><span class="line">        fw.write(<span class="string">&quot;I have a dream!\n&quot;</span>);</span><br><span class="line">        fw.write(<span class="string">&quot;you need to have a dream!&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 4、流资源的关闭</span></span><br><span class="line">        <span class="keyword">if</span> (fw != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                fw.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-3、文本文件的复制"><a href="#3-3、文本文件的复制" class="headerlink" title="3.3、文本文件的复制"></a>3.3、文本文件的复制</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testFileReaderFileWriter</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    FileReader fr = <span class="keyword">null</span>;</span><br><span class="line">    FileWriter fw = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 1、创建File类的对象，指明读入和写出的文件</span></span><br><span class="line">        File srcFile = <span class="keyword">new</span> File(<span class="string">&quot;hello.txt&quot;</span>);</span><br><span class="line">        File destFile = <span class="keyword">new</span> File(<span class="string">&quot;hello2.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2、创建输入流和输出流的对象</span></span><br><span class="line">        fr = <span class="keyword">new</span> FileReader(srcFile);</span><br><span class="line">        fw = <span class="keyword">new</span> FileWriter(destFile);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3、数据的读入和写出操作</span></span><br><span class="line">        <span class="keyword">char</span>[] cbuf = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">5</span>];</span><br><span class="line">        <span class="keyword">int</span> len; <span class="comment">// 记录每次读入到cbuf数组中的字符的个数</span></span><br><span class="line">        <span class="keyword">while</span> ((len = fr.read(cbuf)) != -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 每次写出len个字符</span></span><br><span class="line">            fw.write(cbuf, <span class="number">0</span>, len);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 4、关闭流资源</span></span><br><span class="line">        <span class="keyword">if</span> (fw != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                fw.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (fr != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                fr.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-4、FileInputStream-FileOutputStream的使用"><a href="#3-4、FileInputStream-FileOutputStream的使用" class="headerlink" title="3.4、FileInputStream/FileOutputStream的使用"></a>3.4、FileInputStream/FileOutputStream的使用</h4><ul>
<li>对于文本文件(.txt, .java, .c, .cpp)，使用字符流处理</li>
<li>对于非文本文件(.jpg, .mp3, .mp4, .avi, .doc, .ppt,…)，使用字节流处理</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 实现对图片的复制操作</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testFileInputOutputStream</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    FileInputStream fis = <span class="keyword">null</span>;</span><br><span class="line">    FileOutputStream fos = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 1、造文件</span></span><br><span class="line">        File srcFile = <span class="keyword">new</span> File(<span class="string">&quot;爱情与友情.jpg&quot;</span>);</span><br><span class="line">        File destFile = <span class="keyword">new</span> File(<span class="string">&quot;爱情与友情2.jpg&quot;</span>);</span><br><span class="line">        <span class="comment">// 2、造流</span></span><br><span class="line">        fis = <span class="keyword">new</span> FileInputStream(srcFile);</span><br><span class="line">        fos = <span class="keyword">new</span> FileOutputStream(destFile);</span><br><span class="line">        <span class="comment">// 3、复制的过程</span></span><br><span class="line">        <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">5</span>];</span><br><span class="line">        <span class="keyword">int</span> len;</span><br><span class="line">        <span class="keyword">while</span> ((len = fis.read(buffer)) != -<span class="number">1</span>) &#123;</span><br><span class="line">            fos.write(buffer, <span class="number">0</span>, len);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 4、关闭流</span></span><br><span class="line">        <span class="keyword">if</span> (fis != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                fis.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (fos != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                fos.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>说明：<br>IDEA中：如果大家开发使用JUnit中的单元测试方法测试，相对路径即为当前Module下。如果使用main()测试，相对路径即为当前的Project下。<br>Eclipse中：不管使用单元测试方法还是使用main()测试，相对路径都是当前的Project下</p>
</blockquote>
<h3 id="4、缓冲流"><a href="#4、缓冲流" class="headerlink" title="4、缓冲流"></a>4、缓冲流</h3><h4 id="4-1、缓冲流涉及到的类"><a href="#4-1、缓冲流涉及到的类" class="headerlink" title="4.1、缓冲流涉及到的类"></a>4.1、缓冲流涉及到的类</h4><ul>
<li>BufferedInputStream</li>
<li>BufferedOutputSteam</li>
<li>BufferedReader</li>
<li>BufferedWriter</li>
</ul>
<h4 id="4-2、作用"><a href="#4-2、作用" class="headerlink" title="4.2、作用"></a>4.2、作用</h4><ul>
<li>提高流的读取、写入的速度。</li>
<li>提高读写速度的原因：内部提供了一个缓冲区。默认情况下是8kb</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BufferedInputStream</span> <span class="keyword">extends</span> <span class="title">FilterInputStream</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> DEFAULT_BUFFER_SIZE = <span class="number">8192</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-3、典型代码"><a href="#4-3、典型代码" class="headerlink" title="4.3、典型代码"></a>4.3、典型代码</h4><ul>
<li>使用BufferedInputStream和BufferedOutputStream：处理非文本文件<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">copyFileWithBuffered</span><span class="params">(String srcPath, String destPath)</span> </span>&#123;</span><br><span class="line">    BufferedInputStream bis = <span class="keyword">null</span>;</span><br><span class="line">    BufferedOutputStream bos = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 1、造文件</span></span><br><span class="line">        File srcFile = <span class="keyword">new</span> File(srcPath);</span><br><span class="line">        File destFile = <span class="keyword">new</span> File(destPath);</span><br><span class="line">        <span class="comment">// 2、造流</span></span><br><span class="line">        <span class="comment">// 2.1、造节点流</span></span><br><span class="line">        FileInputStream fis = <span class="keyword">new</span> FileInputStream(srcFile);</span><br><span class="line">        FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(destFile);</span><br><span class="line">        <span class="comment">// 2.2、造缓冲流</span></span><br><span class="line">        bis = <span class="keyword">new</span> BufferedInputStream(fis);</span><br><span class="line">        bos = <span class="keyword">new</span> BufferedOutputStream(fos);</span><br><span class="line">        <span class="comment">// 3、复制的细节：读取、写入</span></span><br><span class="line">        <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">10</span>];</span><br><span class="line">        <span class="keyword">int</span> len;</span><br><span class="line">        <span class="keyword">while</span> ((len = bis.read(buffer)) != -<span class="number">1</span>) &#123;</span><br><span class="line">            bos.write(buffer, <span class="number">0</span>, len);</span><br><span class="line">            <span class="comment">// bos.flush(); //刷新缓冲区</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 4、资源关闭</span></span><br><span class="line">        <span class="comment">// 要求：先关闭外层的流，再关闭内层的流</span></span><br><span class="line">        <span class="keyword">if</span> (bis != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                bis.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (bos != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                bos.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 说明：关闭外层流的同时，内层流也会自动的进行关闭。关于内层流的关闭，我们可以省略</span></span><br><span class="line">        <span class="comment">// fos.close();</span></span><br><span class="line">        <span class="comment">// fis.close();</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>使用BufferedReader和BufferedWriter:处理文本文件</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testBufferedReaderBufferedWriter</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    BufferedReader br = <span class="keyword">null</span>;</span><br><span class="line">    BufferedWriter bw = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 创建文件和相应的流</span></span><br><span class="line">        br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(<span class="keyword">new</span> File(<span class="string">&quot;dbcp.txt&quot;</span>)));</span><br><span class="line">        bw = <span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> FileWriter(<span class="keyword">new</span> File(<span class="string">&quot;dbcp1.txt&quot;</span>)));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 读写操作</span></span><br><span class="line">        <span class="comment">// 方式一：使用char[]数组</span></span><br><span class="line">        <span class="comment">// char[] cbuf = new char[1024];</span></span><br><span class="line">        <span class="comment">// int len;</span></span><br><span class="line">        <span class="comment">// while ((len = br.read(cbuf)) != -1) &#123;</span></span><br><span class="line">        <span class="comment">//     bw.write(cbuf, 0, len);</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="comment">// 方式二：使用String</span></span><br><span class="line">        String data;</span><br><span class="line">        <span class="keyword">while</span> ((data = br.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 方法一：</span></span><br><span class="line">            <span class="comment">// bw.write(data + &quot;\n&quot;); // data中不包含换行符</span></span><br><span class="line">            <span class="comment">// 方法二：</span></span><br><span class="line">            bw.write(data);</span><br><span class="line">            bw.newLine(); <span class="comment">// 提供换行的操作</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 关闭资源</span></span><br><span class="line">        <span class="keyword">if</span> (br != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                br.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (bw != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                bw.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5、转换流"><a href="#5、转换流" class="headerlink" title="5、转换流"></a>5、转换流</h3><h4 id="5-1、转换流涉及到的类：属于字符流"><a href="#5-1、转换流涉及到的类：属于字符流" class="headerlink" title="5.1、转换流涉及到的类：属于字符流"></a>5.1、转换流涉及到的类：属于字符流</h4><ul>
<li>InputStreamReader：将一个字节的输入流转换为字符的输入流<ul>
<li>解码：字节、字节数组 —&gt; 字符数组、字符串</li>
</ul>
</li>
<li>OutputStreamWriter：将一个字符的输出流转换为字节的输出流<ul>
<li>编码：字符数组、字符串 —&gt; 字节、字节数组</li>
</ul>
</li>
</ul>
<blockquote>
<p>说明：编码决定了解码的方式</p>
</blockquote>
<h4 id="5-2、作用"><a href="#5-2、作用" class="headerlink" title="5.2、作用"></a>5.2、作用</h4><ul>
<li>提供字节流与字符流之间的转换</li>
</ul>
<h4 id="5-3、典型实现"><a href="#5-3、典型实现" class="headerlink" title="5.3、典型实现"></a>5.3、典型实现</h4><ul>
<li>文件编码的方式（比如：GBK），决定了解析时使用的字符集（也只能是GBK）</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    InputStreamReader isr = <span class="keyword">null</span>;</span><br><span class="line">    OutputStreamWriter osw = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 1、造文件、造流</span></span><br><span class="line">        File file1 = <span class="keyword">new</span> File(<span class="string">&quot;dbcp.txt&quot;</span>);</span><br><span class="line">        File file2 = <span class="keyword">new</span> File(<span class="string">&quot;dbcp_gbk.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">        FileInputStream fis = <span class="keyword">new</span> FileInputStream(file1);</span><br><span class="line">        FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(file2);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// isr = new InputStreamReader(fis); // 使用系统默认的字符集</span></span><br><span class="line">        isr = <span class="keyword">new</span> InputStreamReader(fis, <span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">        osw = <span class="keyword">new</span> OutputStreamWriter(fos, <span class="string">&quot;gbk&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2、读写过程</span></span><br><span class="line">        <span class="keyword">char</span>[] cbuf = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">20</span>];</span><br><span class="line">        <span class="keyword">int</span> len;</span><br><span class="line">        <span class="keyword">while</span> ((len = isr.read(cbuf)) != -<span class="number">1</span>) &#123;</span><br><span class="line">            osw.write(cbuf, <span class="number">0</span>, len);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 3、关闭资源</span></span><br><span class="line">        <span class="keyword">if</span> (isr != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                isr.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (osw != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                osw.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="5-4、常见的编码表"><a href="#5-4、常见的编码表" class="headerlink" title="5.4、常见的编码表"></a>5.4、常见的编码表</h4><ul>
<li>ASCII：美国标准信息交换码。用一个字节的7位可以表示。</li>
<li>ISO8859-1：拉丁码、欧洲码表。用一个字节的8位表示</li>
<li>GB2312：中国的中文编码表。最多两个字节编码所有字符</li>
<li>GBK：中国的中文编码表升级，融合了更多的中文文字符号。最多两个字节编码</li>
<li>Unicode：国际标准码，融合了目前人类使用的所有字符。为每个字符分配唯一的字符码。所有的文字都用两个字节来表示。</li>
<li>UTF-8：变长的编码方法，可用1-4个字节来表示一个字符。</li>
</ul>
<h3 id="6、其它的流的使用"><a href="#6、其它的流的使用" class="headerlink" title="6、其它的流的使用"></a>6、其它的流的使用</h3><h4 id="6-1、标准输入、输出流"><a href="#6-1、标准输入、输出流" class="headerlink" title="6.1、标准输入、输出流"></a>6.1、标准输入、输出流</h4><ul>
<li>System.in：标准的输入流，默认从键盘输入</li>
<li>System.out：标准的输出流，默认从控制台输出</li>
<li>修改默认的输入和输出行为<ul>
<li>System类的setIn(InputStream is)/setOut(PrintStream ps)方式重新指定输入和输出的流</li>
</ul>
</li>
</ul>
<h4 id="6-2、打印流"><a href="#6-2、打印流" class="headerlink" title="6.2、打印流"></a>6.2、打印流</h4><ul>
<li>PrintStream和PrintWriter</li>
<li>提供了一些列重载的print()和println()方法，用于多种数据类型的输出</li>
<li>System.out返回的是PrintStream的实例</li>
</ul>
<h4 id="6-3、数据流"><a href="#6-3、数据流" class="headerlink" title="6.3、数据流"></a>6.3、数据流</h4><ul>
<li>DataInputStream和DataOutputStream</li>
<li>用于读取或写出基本数据类型的变量或字符串</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    DataOutputStream dos = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        dos = <span class="keyword">new</span> DataOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">&quot;data.txt&quot;</span>));</span><br><span class="line"></span><br><span class="line">        dos.writeUTF(<span class="string">&quot;刘建辰&quot;</span>);</span><br><span class="line">        dos.flush(); <span class="comment">// 刷新操作，将内存中的数据写入文件</span></span><br><span class="line">        dos.writeInt(<span class="number">23</span>);</span><br><span class="line">        dos.flush();</span><br><span class="line">        dos.writeBoolean(<span class="keyword">true</span>);</span><br><span class="line">        dos.flush();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (dos != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                dos.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 注意点：读取不同类型的数据的顺序要与当初写入文件时，保存的数据的顺序一致</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    DataInputStream dis = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        dis = <span class="keyword">new</span> DataInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">&quot;data.txt&quot;</span>));</span><br><span class="line"></span><br><span class="line">        String name = dis.readUTF();</span><br><span class="line">        <span class="keyword">int</span> age = dis.readInt();</span><br><span class="line">        <span class="keyword">boolean</span> isMale = dis.readBoolean();</span><br><span class="line"></span><br><span class="line">        System.out.println(name);</span><br><span class="line">        System.out.println(age);</span><br><span class="line">        System.out.println(isMale);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (dis != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                dis.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="7、对象流"><a href="#7、对象流" class="headerlink" title="7、对象流"></a>7、对象流</h3><h4 id="7-1、对象流"><a href="#7-1、对象流" class="headerlink" title="7.1、对象流"></a>7.1、对象流</h4><ul>
<li>ObjectInputStream：内存中的对象 —&gt; 存储中的文件、通过网络传输出去（序列化过程）</li>
<li>ObjectOutputSteam：存储中的文件、通过网络接受过来 —&gt; 内存中的对象（反序列化过程）</li>
</ul>
<h4 id="7-2、对象的序列化机制"><a href="#7-2、对象的序列化机制" class="headerlink" title="7.2、对象的序列化机制"></a>7.2、对象的序列化机制</h4><ul>
<li>对象序列化机制允许把内存中的Java对象转换成平台无关的二进制流，从而允许把这种二进制流持久地保存在磁盘上，或通过网络将这种二进制流传输到另一个网络节点。</li>
<li>当其它程序获取了这种二进制流，就可以恢复成原来的Java对象</li>
</ul>
<h4 id="7-3、序列化代码实现"><a href="#7-3、序列化代码实现" class="headerlink" title="7.3、序列化代码实现"></a>7.3、序列化代码实现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testObjectOutputSteam</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    ObjectOutputStream oos = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 1、造流</span></span><br><span class="line">        oos = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">&quot;object.dat&quot;</span>));</span><br><span class="line">        <span class="comment">// 2、读写过程</span></span><br><span class="line">        oos.writeObject(<span class="keyword">new</span> String(<span class="string">&quot;我爱北京天安门&quot;</span>));</span><br><span class="line">        oos.flush();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 3、关闭资源</span></span><br><span class="line">        <span class="keyword">if</span> (oos != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                oos.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="7-4、反序列化代码实现"><a href="#7-4、反序列化代码实现" class="headerlink" title="7.4、反序列化代码实现"></a>7.4、反序列化代码实现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testObjectInputSteam</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    ObjectInputStream ois = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ois = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">&quot;object.dat&quot;</span>));</span><br><span class="line"></span><br><span class="line">        Object obj = ois.readObject();</span><br><span class="line">        String str = (String) obj;</span><br><span class="line"></span><br><span class="line">        System.out.println(str);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (ois != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                ois.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="7-5、实现序列化的对象所属的类需要满足的条件"><a href="#7-5、实现序列化的对象所属的类需要满足的条件" class="headerlink" title="7.5、实现序列化的对象所属的类需要满足的条件"></a>7.5、实现序列化的对象所属的类需要满足的条件</h4><ul>
<li>需要实现接口：Serializable</li>
<li>当前类提供一个全局常量：serialVersionUID</li>
<li>除了当前类需要实现Serializable接口之外，还必须保证其内部所有属性也必须是可序列化的。（默认情况下，基本数据类型可序列化）</li>
</ul>
<blockquote>
<p>补充：ObjectOutputSteam和ObjectInputStream不能序列化static和transient修饰的成员变量</p>
</blockquote>
<h3 id="8、随机存取文件流"><a href="#8、随机存取文件流" class="headerlink" title="8、随机存取文件流"></a>8、随机存取文件流</h3><h4 id="8-1、随机存取文件流"><a href="#8-1、随机存取文件流" class="headerlink" title="8.1、随机存取文件流"></a>8.1、随机存取文件流</h4><ul>
<li>RandomAccessFile</li>
</ul>
<h4 id="8-2、使用说明"><a href="#8-2、使用说明" class="headerlink" title="8.2、使用说明"></a>8.2、使用说明</h4><ul>
<li>RandomAccessFile直接继承于java.lang.Object类，实现了DataInput和DataOutput接口</li>
<li>RandomAccessFile既可以作为一个输入流，又可以作为一个输出流</li>
<li>如果RandomAccessFile作为输出流时，写出到的文件如果不存在，则在执行过程中自动创建。如果写出到的文件存在，则会对原文件内容进行覆盖。（默认情况下，从头覆盖）</li>
<li>可以通过相关的操作，实现RandomAccessFile“插入”数据的效果。seek(int pos)</li>
</ul>
<h4 id="8-3、典型代码"><a href="#8-3、典型代码" class="headerlink" title="8.3、典型代码"></a>8.3、典型代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 实现复制功能</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    RandomAccessFile raf1 = <span class="keyword">null</span>;</span><br><span class="line">    RandomAccessFile raf2 = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 1、造流</span></span><br><span class="line">        raf1 = <span class="keyword">new</span> RandomAccessFile(<span class="keyword">new</span> File(<span class="string">&quot;爱情与友情.jpg&quot;</span>), <span class="string">&quot;r&quot;</span>);</span><br><span class="line">        raf2 = <span class="keyword">new</span> RandomAccessFile(<span class="keyword">new</span> File(<span class="string">&quot;爱情与友情1.jpg&quot;</span>), <span class="string">&quot;rw&quot;</span>);</span><br><span class="line">        <span class="comment">// 2、读写过程</span></span><br><span class="line">        <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">int</span> len;</span><br><span class="line">        <span class="keyword">while</span> ((len = raf1.read(buffer)) != -<span class="number">1</span>) &#123;</span><br><span class="line">            raf2.write(buffer, <span class="number">0</span>, len);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 3、关闭资源</span></span><br><span class="line">        <span class="keyword">if</span> (raf1 != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                raf1.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (raf2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                raf2.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用RandomAccessFile实现数据的插入效果</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    RandomAccessFile raf1 = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        raf1 = <span class="keyword">new</span> RandomAccessFile(<span class="string">&quot;hello.txt&quot;</span>, <span class="string">&quot;rw&quot;</span>);</span><br><span class="line"></span><br><span class="line">        raf1.seek(<span class="number">3</span>); <span class="comment">// 将指针调到角标为3的位置</span></span><br><span class="line">        <span class="comment">// 保存指针3后面的所有数据到StringBuilder中</span></span><br><span class="line">        StringBuilder buildr = <span class="keyword">new</span> StringBuilder((<span class="keyword">int</span>) <span class="keyword">new</span> File(<span class="string">&quot;hello.txt&quot;</span>).length());</span><br><span class="line">        <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">20</span>];</span><br><span class="line">        <span class="keyword">int</span> len;</span><br><span class="line">        <span class="keyword">while</span> ((len = raf1.read(buffer)) != -<span class="number">1</span>) &#123;</span><br><span class="line">            buildr.append(<span class="keyword">new</span> String(buffer, <span class="number">0</span>, len));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调回指针，写入“xyz”</span></span><br><span class="line">        raf1.seek(<span class="number">3</span>);</span><br><span class="line">        raf1.write(<span class="string">&quot;xyz&quot;</span>.getBytes());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将StringBuilder中的数据写入到文件中</span></span><br><span class="line">        raf1.write(buildr.toString().getBytes());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (raf1 != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                raf1.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="9、NIO-2中Path、Paths、Files类的使用"><a href="#9、NIO-2中Path、Paths、Files类的使用" class="headerlink" title="9、NIO.2中Path、Paths、Files类的使用"></a>9、NIO.2中Path、Paths、Files类的使用</h3><h4 id="9-1、NIO的使用说明"><a href="#9-1、NIO的使用说明" class="headerlink" title="9.1、NIO的使用说明"></a>9.1、NIO的使用说明</h4><ul>
<li>Java NIO(New IO, Non-Blocking IO)是从Java 1.4版本开始引入的一套新的IO API，可以替代标准的Java IO API。</li>
<li>NIO与原来的IO同样的作用和目的，但是使用的方式完全不同，NIO支持面向缓冲区的(IO是面向流的)、基于通道的IO操作</li>
<li>NIO将以更高效的方式进行文件的读写操作</li>
<li>随着JDK 7的发布，Java对NIO进行了极大的扩展，增强了对文件处理和文件系统特性的支持，以至于我们称他们为NIO.2</li>
</ul>
<h4 id="9-2、Path的使用"><a href="#9-2、Path的使用" class="headerlink" title="9.2、Path的使用"></a>9.2、Path的使用</h4><ul>
<li>Path替换原有的File类</li>
<li>Paths类提供了静态get()方法用来获取Path对象：<ul>
<li>static Path get(String first, String … more)：用于将多个字符串串连成路径</li>
<li>static Path get(URI uri)：返回指定uri对应的Parh路径</li>
</ul>
</li>
<li>常用方法：<ul>
<li>String toString()：返回调用Path对象的字符串表示形式</li>
<li>boolean startsWith(String path)：判断是否以path路径开始</li>
<li>boolean endsWith(String path)：判断是否以path路径结束</li>
<li>boolean isAbsolute()：判断是否是绝对路径</li>
<li>Path getParent()：返回path对象包含整个路径，不包含Path对象指定的文件路径</li>
<li>Path getRoot()：返回调用Path对象的根路径</li>
<li>Path getFileName()：返回与调用Path对象关联的文件名</li>
<li>int getNameCount()：返回Path根目录后面元素的数量</li>
<li>Path getName(int idx)：返回指定索引位置idx的路径名称</li>
<li>Path toAbsolutePath()：作为绝对路径返回调用Path对象</li>
<li>Path resolve(Path p)：合并两个路径，返回合并后的路径对应的Path对象</li>
<li>File toFile()：将Path转换为File类的对象</li>
</ul>
</li>
</ul>
<h4 id="9-3、Files工具类"><a href="#9-3、Files工具类" class="headerlink" title="9.3、Files工具类"></a>9.3、Files工具类</h4><ul>
<li>作用：操作文件或文件目录的工具类</li>
<li>常用方法：<ul>
<li>Path copy(Path src, Path dest, CopyOption … how)：文件的复制</li>
<li>Path createDirectory(Path path, FileAttribute&lt;?&gt; … attr)：创建一个目录</li>
<li>Path createFile(Path path, FileAttribute&lt;?&gt; … arr)：创建一个文件</li>
<li>void delete(Path path)：删除一个文件/目录，如果不存在，执行报错</li>
<li>void deleteIfExists(Path path)：Path对应的文件/目录如果存在，执行删除</li>
<li>Path move(Path src, Path dest, CopyOption … how)：将src移动到dest位置</li>
<li>long size(Path path)：返回指定文件的大小</li>
</ul>
</li>
<li>用于判断：<ul>
<li>boolean exists(Path path, LinkOption … opts)：判断文件是否存在</li>
<li>boolean isDirectory(Path path, LinkOption … opts)：判断是否是目录</li>
<li>boolean isRegularFile(Path path, LinkOption … opts)：判断是否是文件</li>
<li>boolean isHidden(Path path)：判断是否是隐藏文件</li>
<li>boolean isReadable(Path path)：判断文件是否可读</li>
<li>boolean isWritable(Path path)：判断文件是否可写</li>
<li>boolean notExists(Path path, LinkOption … opts)：判断文件是否不存在</li>
</ul>
</li>
<li>用于操作内存<ul>
<li>SeekableByteChannel newByteChannel(Path path, OpenOption … how)：获取与指定文件的连接，how指定打开方式</li>
<li><code>DirectoryStream&lt;Path&gt; newDirectoryStream(Path path)</code>：打开path指定的目录</li>
<li>InputStream newInputStream(Path path, OpenOption … how)：获取InputStream对象</li>
<li>OutputStream newOutputStream(Path path, OpenOption … how)：获取OutputStream对象</li>
</ul>
</li>
</ul>
<h2 id="七、网络编程"><a href="#七、网络编程" class="headerlink" title="七、网络编程"></a>七、网络编程</h2><h3 id="1、InetAddress类的使用"><a href="#1、InetAddress类的使用" class="headerlink" title="1、InetAddress类的使用"></a>1、InetAddress类的使用</h3><h4 id="1-1、实现网络通信需要解决的两个问题"><a href="#1-1、实现网络通信需要解决的两个问题" class="headerlink" title="1.1、实现网络通信需要解决的两个问题"></a>1.1、实现网络通信需要解决的两个问题</h4><ul>
<li>如何准确地定位网络上一台或多台主机；定位主机上的特定的应用</li>
<li>找到主机后如何可靠高效地进行数据传输</li>
</ul>
<h4 id="1-2、网络通信的两个要素"><a href="#1-2、网络通信的两个要素" class="headerlink" title="1.2、网络通信的两个要素"></a>1.2、网络通信的两个要素</h4><ul>
<li>对应问题一：IP和端口号</li>
<li>对应问题二：提供网络通信协议：TCP/IP参考模型（应用层、传输层、网络层、物理+数据链路层）</li>
</ul>
<h4 id="1-3、通信要素一：IP和端口号"><a href="#1-3、通信要素一：IP和端口号" class="headerlink" title="1.3、通信要素一：IP和端口号"></a>1.3、通信要素一：IP和端口号</h4><ul>
<li>IP的理解<ul>
<li>IP：唯一的标识Internet上的计算机（通信实体）</li>
<li>在Java中使用InetAddress类代表IP</li>
<li>IP分类：IPv4和IPv6；万维网和局域网</li>
<li>域名：<a href="http://www.baidu.com、www.mi.com/">www.baidu.com、www.mi.com</a><ul>
<li>域名解析：域名容易记忆，当在连接网络时输入一个主机的域名后，域名服务器（DNS）负责将域名转化成IP地址，这样才能和主机建立连接。</li>
</ul>
</li>
<li>本地回路地址：127.0.0.1 对应着：localhost</li>
</ul>
</li>
<li>InetAddress类：此类的一个对象就代表着一个具体的IP地址<ul>
<li>实例化：<ul>
<li>getByName(String host)</li>
<li>getLocalHost()</li>
</ul>
</li>
<li>常用方法：<ul>
<li>getHostName()</li>
<li>getHostAddress()</li>
</ul>
</li>
</ul>
</li>
<li>端口号：正在计算机上运行的进程<ul>
<li>要求：不同的进程不同的端口号</li>
<li>范围：被规定为一个16位的整数 0~65535</li>
</ul>
</li>
<li>端口号与IP地址的组合得出一个网络套接字：Socket</li>
</ul>
<h4 id="1-4、通信要素二：网络通信协议"><a href="#1-4、通信要素二：网络通信协议" class="headerlink" title="1.4、通信要素二：网络通信协议"></a>1.4、通信要素二：网络通信协议</h4><table>
<thead>
<tr>
<th align="center">OSI参考模型</th>
<th align="center">TCP/IP参考模型</th>
<th align="center">TCP/IP参考模型各层对应协议</th>
</tr>
</thead>
<tbody><tr>
<td align="center">应用层、表示层、会话层</td>
<td align="center">应用层</td>
<td align="center">HTTP、FTP、Telnet、DNS…</td>
</tr>
<tr>
<td align="center">传输层</td>
<td align="center">传输层</td>
<td align="center">TCP、UDP…</td>
</tr>
<tr>
<td align="center">网络层</td>
<td align="center">网络层</td>
<td align="center">IP、ICMP、ARP…</td>
</tr>
<tr>
<td align="center">数据链路层、物理层</td>
<td align="center">物理+数据链路层</td>
<td align="center">Link</td>
</tr>
</tbody></table>
<h4 id="1-5、TCP和UDP的区别"><a href="#1-5、TCP和UDP的区别" class="headerlink" title="1.5、TCP和UDP的区别"></a>1.5、TCP和UDP的区别</h4><ul>
<li>TCP协议：<ul>
<li>使用TCP协议前，须先建立TCP连接，形成传输数据通道</li>
<li>传输前，采用“三次握手”方式，点对点通信，是可靠的</li>
<li>TCP协议进行通信的两个应用进程：客户端、服务端</li>
<li>在连接中可进行大数据量的传输</li>
<li>传输完毕，需要释放已建立的连接，效率低</li>
</ul>
</li>
<li>UDP协议：<ul>
<li>将数据、源、目的封装成数据包，不需要建立连接</li>
<li>每个数据报的大小限制在64K内</li>
<li>发送不管对方是否准备好，接收方收到也不确认，故是不可靠的</li>
<li>可以广播发送</li>
<li>发送数据结束时无需释放资源，开销小，速度快</li>
</ul>
</li>
</ul>
<h4 id="1-6、TCP三次握手和四次挥手"><a href="#1-6、TCP三次握手和四次挥手" class="headerlink" title="1.6、TCP三次握手和四次挥手"></a>1.6、TCP三次握手和四次挥手</h4><ul>
<li>三次握手</li>
</ul>
<p><img src="https://rulerofterabithia-blog.oss-cn-hangzhou.aliyuncs.com/img/20221016214144.png"></p>
<ul>
<li>四次挥手</li>
</ul>
<p><img src="https://rulerofterabithia-blog.oss-cn-hangzhou.aliyuncs.com/img/20221016214231.png"></p>
<h3 id="2、TCP网络编程"><a href="#2、TCP网络编程" class="headerlink" title="2、TCP网络编程"></a>2、TCP网络编程</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 客户端发送信息给服务端，服务端将数据显示在控制台上</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TCPTest1</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 客户端</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">client</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Socket socket = <span class="keyword">null</span>;</span><br><span class="line">        OutputStream os = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 1、创建Socket对象，指明服务器端的IP和端口号</span></span><br><span class="line">            InetAddress inet = InetAddress.getByName(<span class="string">&quot;127.0.0.1&quot;</span>);</span><br><span class="line">            socket = <span class="keyword">new</span> Socket(inet, <span class="number">8899</span>);</span><br><span class="line">            <span class="comment">// 2、获取一个输出流，用于输出数据</span></span><br><span class="line">            os = socket.getOutputStream();</span><br><span class="line">            <span class="comment">// 3、写出数据的操作</span></span><br><span class="line">            os.write(<span class="string">&quot;你好，我是客户端mm&quot;</span>.getBytes());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 4、资源的关闭</span></span><br><span class="line">            <span class="keyword">if</span> (os != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    os.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (socket != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    socket.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//服务端</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">server</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">        ServerSocket ss = <span class="keyword">null</span>;</span><br><span class="line">        Socket socket = <span class="keyword">null</span>;</span><br><span class="line">        InputStream is = <span class="keyword">null</span>;</span><br><span class="line">        ByteArrayOutputStream baos = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 1、创建服务器端的ServerSocket，指明自己的端口号</span></span><br><span class="line">            ss = <span class="keyword">new</span> ServerSocket(<span class="number">8899</span>);</span><br><span class="line">            <span class="comment">// 2、调用accept()表示接收来自客户端的socket</span></span><br><span class="line">            socket = ss.accept();</span><br><span class="line">            <span class="comment">// 3、获取输入流</span></span><br><span class="line">            is = socket.getInputStream();</span><br><span class="line">            <span class="comment">// 4、读取输入流中的数据</span></span><br><span class="line">            baos = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">            <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">5</span>];</span><br><span class="line">            <span class="keyword">int</span> len;</span><br><span class="line">            <span class="keyword">while</span> ((len = is.read(buffer)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                baos.write(buffer, <span class="number">0</span>, len);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            System.out.println(socket.getInetAddress().getHostAddress() + <span class="string">&quot;：&quot;</span> + baos.toString());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 5、关闭资源</span></span><br><span class="line">            <span class="keyword">if</span> (baos != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    baos.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (is != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    is.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (socket != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    socket.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (ss != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    ss.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 客户端发送文件给服务端，服务端将文件保存在本地</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TCPTest2</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 客户端</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">client</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">        Socket socket = <span class="keyword">null</span>;</span><br><span class="line">        OutputStream os = <span class="keyword">null</span>;</span><br><span class="line">        FileInputStream fis = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            socket = <span class="keyword">new</span> Socket(InetAddress.getByName(<span class="string">&quot;127.0.0.1&quot;</span>), <span class="number">9090</span>);</span><br><span class="line">            os = socket.getOutputStream();</span><br><span class="line">            fis = <span class="keyword">new</span> FileInputStream(<span class="keyword">new</span> File(<span class="string">&quot;beauty.jpg&quot;</span>));</span><br><span class="line">            <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="keyword">int</span> len;</span><br><span class="line">            <span class="keyword">while</span> ((len = fis.read(buffer)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                os.write(buffer, <span class="number">0</span>, len);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (fis != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    fis.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (os != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    os.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (socket != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    socket.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//服务端</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">server</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">        ServerSocket ss = <span class="keyword">null</span>;</span><br><span class="line">        Socket socket = <span class="keyword">null</span>;</span><br><span class="line">        InputStream is = <span class="keyword">null</span>;</span><br><span class="line">        FileOutputStream fos = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ss = <span class="keyword">new</span> ServerSocket(<span class="number">9090</span>);</span><br><span class="line">            socket = ss.accept();</span><br><span class="line">            is = socket.getInputStream();</span><br><span class="line">            fos = <span class="keyword">new</span> FileOutputStream(<span class="keyword">new</span> File(<span class="string">&quot;beauty1.jpg&quot;</span>));</span><br><span class="line"></span><br><span class="line">            <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="keyword">int</span> len;</span><br><span class="line">            <span class="keyword">while</span> ((len = is.read(buffer)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                fos.write(buffer, <span class="number">0</span>, len);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (fos != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    fos.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (is != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    is.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (socket != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    socket.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (ss != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    ss.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 从客户端发送文件给服务器，服务端保存到本地。并返回“发送成功”给客户端</span></span><br><span class="line"><span class="comment"> * 并关闭相关的连接</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TCPTest3</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 客户端</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">client</span> <span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Socket socket = <span class="keyword">null</span>;</span><br><span class="line">        OutputStream os = <span class="keyword">null</span>;</span><br><span class="line">        FileInputStream fis = <span class="keyword">null</span>;</span><br><span class="line">        InputStream is = <span class="keyword">null</span>;</span><br><span class="line">        ByteArrayOutputStream baos = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            socket = <span class="keyword">new</span> Socket(InetAddress.getByName(<span class="string">&quot;127.0.0.1&quot;</span>), <span class="number">9090</span>);</span><br><span class="line">            os = socket.getOutputStream();</span><br><span class="line">            fis = <span class="keyword">new</span> FileInputStream(<span class="keyword">new</span> File(<span class="string">&quot;beauty.jpg&quot;</span>));</span><br><span class="line"></span><br><span class="line">            <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="keyword">int</span> len;</span><br><span class="line">            <span class="keyword">while</span> ((len = fis.read(buffer)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                os.write(buffer, <span class="number">0</span>, len);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 关闭数据的输出</span></span><br><span class="line">            socket.shutdownOutput();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 接收来自于服务器端的数据，并显示到控制台上</span></span><br><span class="line">            is = socket.getInputStream();</span><br><span class="line">            baos = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">            <span class="keyword">byte</span>[] buffer1 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">20</span>];</span><br><span class="line">            <span class="keyword">int</span> len1;</span><br><span class="line">            <span class="keyword">while</span> ((len1 = is.read(buffer1)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                baos.write(buffer1, <span class="number">0</span>, len1);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            System.out.println(baos.toString());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (baos != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    baos.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (is != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    is.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (fis != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    fis.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (os != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    os.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (socket != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    socket.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 服务端</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">server</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">        ServerSocket ss = <span class="keyword">null</span>;</span><br><span class="line">        Socket socket = <span class="keyword">null</span>;</span><br><span class="line">        InputStream is = <span class="keyword">null</span>;</span><br><span class="line">        FileOutputStream fos = <span class="keyword">null</span>;</span><br><span class="line">        OutputStream os = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ss = <span class="keyword">new</span> ServerSocket(<span class="number">9090</span>);</span><br><span class="line">            socket = ss.accept();</span><br><span class="line">            is = socket.getInputStream();</span><br><span class="line">            fos = <span class="keyword">new</span> FileOutputStream(<span class="keyword">new</span> File(<span class="string">&quot;beauty2.jpg&quot;</span>));</span><br><span class="line"></span><br><span class="line">            <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="keyword">int</span> len;</span><br><span class="line">            <span class="keyword">while</span> ((len = is.read(buffer)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                fos.write(buffer, <span class="number">0</span>, len);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot;图片传输完成&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 服务器端给予客户单反馈</span></span><br><span class="line">            os = socket.getOutputStream();</span><br><span class="line">            os.write(<span class="string">&quot;你好，美女，照片我已收到，非常漂亮！&quot;</span>.getBytes());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (os != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    os.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (fos != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    fos.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (is != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    is.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (socket != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    socket.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (ss != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    ss.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3、UDP网络编程"><a href="#3、UDP网络编程" class="headerlink" title="3、UDP网络编程"></a>3、UDP网络编程</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UDPTest</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 发送端</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sender</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">        DatagramSocket socket = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            socket = <span class="keyword">new</span> DatagramSocket();</span><br><span class="line"></span><br><span class="line">            String str = <span class="string">&quot;我是UDP方式发送的导弹&quot;</span>;</span><br><span class="line">            <span class="keyword">byte</span>[] data = str.getBytes();</span><br><span class="line">            InetAddress inet = InetAddress.getLocalHost();</span><br><span class="line">            DatagramPacket packet = <span class="keyword">new</span> DatagramPacket(data, <span class="number">0</span>, data.length, inet, <span class="number">9090</span>);</span><br><span class="line"></span><br><span class="line">            socket.send(packet);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (socket != <span class="keyword">null</span>) &#123;</span><br><span class="line">                socket.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 接收端</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receiver</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">        DatagramSocket socket = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            socket = <span class="keyword">new</span> DatagramSocket(<span class="number">9090</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">100</span>];</span><br><span class="line">            DatagramPacket packet = <span class="keyword">new</span> DatagramPacket(buffer, <span class="number">0</span>, buffer.length);</span><br><span class="line"></span><br><span class="line">            socket.receive(packet);</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="keyword">new</span> String(packet.getData(), <span class="number">0</span>, packet.getLength()));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            socket.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4、URL编程"><a href="#4、URL编程" class="headerlink" title="4、URL编程"></a>4、URL编程</h3><h4 id="4-1、URL-Uniform-Resource-Locator-的理解"><a href="#4-1、URL-Uniform-Resource-Locator-的理解" class="headerlink" title="4.1、URL(Uniform Resource Locator)的理解"></a>4.1、URL(Uniform Resource Locator)的理解</h4><ul>
<li>统一资源定位符，对应着互联网的某一资源地址</li>
</ul>
<h4 id="4-2、URL的5个基本结构"><a href="#4-2、URL的5个基本结构" class="headerlink" title="4.2、URL的5个基本结构"></a>4.2、URL的5个基本结构</h4><ul>
<li>协议</li>
<li>主机名</li>
<li>端口号</li>
<li>资源地址</li>
<li>参数列表</li>
</ul>
<h4 id="4-3、如何实例化"><a href="#4-3、如何实例化" class="headerlink" title="4.3、如何实例化"></a>4.3、如何实例化</h4><ul>
<li><code>URL url = new URL(&quot;http://localhost:8080/examples/beauty.jpg?username=Tom&quot;)</code></li>
</ul>
<h4 id="4-4、常用方法"><a href="#4-4、常用方法" class="headerlink" title="4.4、常用方法"></a>4.4、常用方法</h4><ul>
<li>public String getProtocol()：获取该URL的协议名</li>
<li>public String getHost()：获取该URL的主机名</li>
<li>public String getPort()：获取该URL的端口号</li>
<li>public String getPath()：获取该URL的文件路径</li>
<li>public String getFile()：获取该URL的文件名</li>
<li>public String getQuery()：获取该URL的查询名</li>
</ul>
<h4 id="4-5、可以读取、下载对应的url资源"><a href="#4-5、可以读取、下载对应的url资源" class="headerlink" title="4.5、可以读取、下载对应的url资源"></a>4.5、可以读取、下载对应的url资源</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    HttpURLConnection urlConnection = <span class="keyword">null</span>;</span><br><span class="line">    InputStream is = <span class="keyword">null</span>;</span><br><span class="line">    FileOutputStream fos = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        URL url = <span class="keyword">new</span> URL(<span class="string">&quot;http://localhost:8080/examples/beauty.jpg&quot;</span>);</span><br><span class="line">        urlConnection = (HttpURLConnection) url.openConnection();</span><br><span class="line">        urlConnection.connect();</span><br><span class="line"></span><br><span class="line">        is = urlConnection.getInputStream();</span><br><span class="line">        fos = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;day10\\beauty3.jpg&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">int</span> len;</span><br><span class="line">        <span class="keyword">while</span> ((len = is.read(buffer)) != -<span class="number">1</span>) &#123;</span><br><span class="line">            fos.write(buffer, <span class="number">0</span>, len);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;下载完成&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (fos != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                fos.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (is != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                is.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (urlConnection != <span class="keyword">null</span>) &#123;</span><br><span class="line">            urlConnection.disconnect();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="八、Java反射机制"><a href="#八、Java反射机制" class="headerlink" title="八、Java反射机制"></a>八、Java反射机制</h2><h3 id="1、反射的概述"><a href="#1、反射的概述" class="headerlink" title="1、反射的概述"></a>1、反射的概述</h3><h4 id="1-1、本章的主要内容"><a href="#1-1、本章的主要内容" class="headerlink" title="1.1、本章的主要内容"></a>1.1、本章的主要内容</h4><ul>
<li>Java反射机制概述</li>
<li>理解Class类并获取Class实例</li>
<li>类的加载与ClassLoader的理解</li>
<li>创建运行时类的对象</li>
<li>获取运行时类的完成结构</li>
<li>调用运行时类的指定结构</li>
<li>反射的应用：动态代理</li>
</ul>
<h4 id="1-2、关于反射的理解"><a href="#1-2、关于反射的理解" class="headerlink" title="1.2、关于反射的理解"></a>1.2、关于反射的理解</h4><ul>
<li>Reflection（反射）是被视为动态语言的关键，反射机制允许程序在执行期借助于Reflection API取得任何类的内部信息，并能直接操作任意对象的内容属性及方法。</li>
</ul>
<blockquote>
<p>框架 = 反射 + 注解 + 设计模式</p>
</blockquote>
<h4 id="1-3、体会反射机制的“动态性”"><a href="#1-3、体会反射机制的“动态性”" class="headerlink" title="1.3、体会反射机制的“动态性”"></a>1.3、体会反射机制的“动态性”</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 体会反射的动态性</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> num = <span class="keyword">new</span> Random().nextInt(<span class="number">3</span>);</span><br><span class="line">        String classPath = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">switch</span> (num) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                classPath = <span class="string">&quot;java.util.Date&quot;</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                classPath = <span class="string">&quot;java.lang.Object&quot;</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                classPath = <span class="string">&quot;com.atguigu.java.Person&quot;</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Object obj = getInstance(classPath);</span><br><span class="line">            System.out.println(obj);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建一个指定类的对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> classPath 指定类的全类名</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getInstance</span><span class="params">(String classPath)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">Class clazz = Class.forName(classPath);</span><br><span class="line"><span class="keyword">return</span>  clazz.newInstance();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="1-4、反射机制能提供的功能"><a href="#1-4、反射机制能提供的功能" class="headerlink" title="1.4、反射机制能提供的功能"></a>1.4、反射机制能提供的功能</h4><ul>
<li>在运行时判断任意一个对象所属的类</li>
<li>在运行时构造任意一个类的对象</li>
<li>在运行时判断任意一个类所具有的成员变量和方法</li>
<li>在运行时获取泛型信息</li>
<li>在运行时调用任意一个对象的成员变量和方法</li>
<li>在运行时处理注解</li>
<li>生成动态代理</li>
</ul>
<h4 id="1-5、相关API"><a href="#1-5、相关API" class="headerlink" title="1.5、相关API"></a>1.5、相关API</h4><ul>
<li>java.lang.Class：反射的源头</li>
<li>java.lang.reflect.Method</li>
<li>java.lang.reflect.Field</li>
<li>java.lang.reflect.Constructor</li>
</ul>
<h3 id="2、Class类的理解与获取Class的实例"><a href="#2、Class类的理解与获取Class的实例" class="headerlink" title="2、Class类的理解与获取Class的实例"></a>2、Class类的理解与获取Class的实例</h3><h4 id="2-1、Class类的理解"><a href="#2-1、Class类的理解" class="headerlink" title="2.1、Class类的理解"></a>2.1、Class类的理解</h4><ul>
<li>类的加载过程<ul>
<li>程序经过javac.exe命令以后，会生成一个或多个字节码文件(.class结尾)。接着我们使用java.exe命令对某个字节码文件进行解释运行。相当于将某个字节码文件加载到内存中。此过程就称为类的加载。加载到内存中的类，我们就称为运行时类，此运行时类，就作为Class的一个实例。</li>
</ul>
</li>
<li>换句话说，Class的实例就对应着一个运行时类</li>
<li>加载到内存中的运行时类，会缓存一定的时间。在此时间之内，我们可以通过不同的方式来获取此运行时类。</li>
</ul>
<h4 id="2-2、获取Class实例的几种方式"><a href="#2-2、获取Class实例的几种方式" class="headerlink" title="2.2、获取Class实例的几种方式"></a>2.2、获取Class实例的几种方式</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span> <span class="keyword">throws</span> ClassNotFoundException </span>&#123;</span><br><span class="line">    <span class="comment">// 方式一：调用运行时类的属性：.class</span></span><br><span class="line">    Class clazz1 = Person.class;</span><br><span class="line">    System.out.println(clazz1);</span><br><span class="line">    <span class="comment">// 方式二：通过运行时类的对象，调用getClass()</span></span><br><span class="line">    Person p1 = <span class="keyword">new</span> Person();</span><br><span class="line">    Class clazz2 = p1.getClass();</span><br><span class="line">    System.out.println(clazz2);</span><br><span class="line">    <span class="comment">// 方式三：调用Class的静态方法：forName(String classPath)</span></span><br><span class="line">    Class clazz3 = Class.forName(<span class="string">&quot;com.atguigu.java.Person&quot;</span>);</span><br><span class="line">    System.out.println(clazz3);</span><br><span class="line">    <span class="comment">// 方式四：使用类的加载器：ClassLoader(了解)</span></span><br><span class="line">    ClassLoader classLoader = ReflectionTest.class.getClassLoader();</span><br><span class="line">    Class clazz4 = classLoader.loadClass(<span class="string">&quot;com.atguigu.java.Person&quot;</span>);</span><br><span class="line">    System.out.println(clazz4);</span><br><span class="line"></span><br><span class="line">    System.out.println(clazz1 == clazz2);<span class="comment">// true</span></span><br><span class="line">    System.out.println(clazz1 == clazz3);<span class="comment">// true</span></span><br><span class="line">    System.out.println(clazz1 == clazz4);<span class="comment">// true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-3、总结：创建类的对象的方式"><a href="#2-3、总结：创建类的对象的方式" class="headerlink" title="2.3、总结：创建类的对象的方式"></a>2.3、总结：创建类的对象的方式</h4><ul>
<li>方式一：new + 构造器</li>
<li>方式二：要创建Xxx类的对象，可以考虑：Xxx、Xxxs、XxxFactory、XxxBuilder类中查看是否有静态方法的存在。可以调用其静态方法，创建Xxx对象</li>
<li>方式三：通过反射</li>
</ul>
<h4 id="2-4、Class实例可以是哪些结构的说明"><a href="#2-4、Class实例可以是哪些结构的说明" class="headerlink" title="2.4、Class实例可以是哪些结构的说明"></a>2.4、Class实例可以是哪些结构的说明</h4><ul>
<li>class：外部类，成员（成员内部类，静态内部类），局部内部类，匿名内部类</li>
<li>interface：接口</li>
<li>[]：数组</li>
<li>enum：枚举</li>
<li>annotation：注解@interface</li>
<li>primitive type：基本数据类型</li>
<li>void</li>
</ul>
<h3 id="3、了解ClassLoader"><a href="#3、了解ClassLoader" class="headerlink" title="3、了解ClassLoader"></a>3、了解ClassLoader</h3><h4 id="3-1、类的加载过程（了解）"><a href="#3-1、类的加载过程（了解）" class="headerlink" title="3.1、类的加载过程（了解）"></a>3.1、类的加载过程（了解）</h4><ul>
<li>当程序主动使用某个类时，如果该类还未被加载到内存中，则系统会通过如下三个步骤来对该类进行初始化。<ul>
<li>类的加载：将类的class文件读入内存，并为之创建一个java.lang.Class对象。此过程由类加载器完成</li>
<li>类的链接：将类的二进制数据合并到JRE中</li>
<li>类的初始化：JVM负责对类进行初始化</li>
</ul>
</li>
</ul>
<h4 id="3-2、类的加载器的作用"><a href="#3-2、类的加载器的作用" class="headerlink" title="3.2、类的加载器的作用"></a>3.2、类的加载器的作用</h4><ul>
<li>类加载的作用：将class文件字节码内容加载到内存中，并将这些静态数据转换成方法区的运行时数据结构，然后在堆中生成一个代表这个类的java.lang.Class对象，作为方法区中类数据的访问入口。</li>
<li>类缓存：标准的JavaSE类加载器可以按要求查找类，但一旦某个类被加载到类加载器中，它将维持加载（缓存）一段时间。不过JVM垃圾回收机制可以回收这些Class对象。</li>
</ul>
<h4 id="3-3、类的加载器的分类"><a href="#3-3、类的加载器的分类" class="headerlink" title="3.3、类的加载器的分类"></a>3.3、类的加载器的分类</h4><ul>
<li>引导类加载器：用C++编写的，是JVM自带的类加载器，<strong>负责Java平台核心库</strong>，用来装载核心类库。该加载器无法直接获取</li>
<li>扩展类加载器：负责jre/lib/ext目录下的jar包或-D java.ext.dirs指定目录下的jar包装入工作库</li>
<li>系统类加载器：负责java -classpath 或 -D java.class.path所指的目录下的类与jar包装入工作，是最常用的加载器</li>
</ul>
<h4 id="3-4、Java类编译、运行的执行过程"><a href="#3-4、Java类编译、运行的执行过程" class="headerlink" title="3.4、Java类编译、运行的执行过程"></a>3.4、Java类编译、运行的执行过程</h4><p><img src="https://rulerofterabithia-blog.oss-cn-hangzhou.aliyuncs.com/img/20221016214340.png"></p>
<h4 id="3-5、使用Classloader加载src目录下的配置文件"><a href="#3-5、使用Classloader加载src目录下的配置文件" class="headerlink" title="3.5、使用Classloader加载src目录下的配置文件"></a>3.5、使用Classloader加载src目录下的配置文件</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    Properties pros = <span class="keyword">new</span> Properties();</span><br><span class="line">    <span class="comment">// 读取配置文件的方式一：</span></span><br><span class="line">    <span class="comment">// FileInputStream fis = new FileInputStream(&quot;src\\jdbc1.properties&quot;);</span></span><br><span class="line">    <span class="comment">// pros.load(fis);</span></span><br><span class="line">    <span class="comment">// 读取配置文件的方式二：</span></span><br><span class="line">    ClassLoader classLoader = ClassLoaderTest.class.getClassLoader();</span><br><span class="line">    InputStream is = classLoader.getResourceAsStream(<span class="string">&quot;jdbc1.properties&quot;</span>);</span><br><span class="line">    pros.load(is);</span><br><span class="line"></span><br><span class="line">    String user = pros.getProperty(<span class="string">&quot;user&quot;</span>);</span><br><span class="line">    String password = pros.getProperty(<span class="string">&quot;password&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;user = &quot;</span> + user + <span class="string">&quot;,password = &quot;</span> + password);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4、反射应用一：创建运行时类的对象"><a href="#4、反射应用一：创建运行时类的对象" class="headerlink" title="4、反射应用一：创建运行时类的对象"></a>4、反射应用一：创建运行时类的对象</h3><ul>
<li>newInstance()：调用此方法，创建对应的运行时类的对象。内部调用了运行时类的空参的构造器</li>
<li>要想此方法正常的创建运行时类的对象，要求：<ul>
<li>1、运行时类必须提供空参的构造器</li>
<li>2、空参的构造器的访问权限得够。通常，设置为public</li>
</ul>
</li>
<li>在JavaBean中要求提供一个public的空参构造器。原因：<ul>
<li>1、便于通过反射，创建运行时类的对象</li>
<li>2、便于子类继承此运行时类时，默认调用super()时，保证父类有此构造器</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> <span class="keyword">throws</span> InstantiationException, IllegalAccessException </span>&#123;</span><br><span class="line">    Class&lt;Person&gt; clazz = Person.class;</span><br><span class="line"></span><br><span class="line">    Person person = clazz.newInstance();</span><br><span class="line">    System.out.println(person);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5、反射应用二：获取运行时类的完整结构"><a href="#5、反射应用二：获取运行时类的完整结构" class="headerlink" title="5、反射应用二：获取运行时类的完整结构"></a>5、反射应用二：获取运行时类的完整结构</h3><h4 id="5-1、获取属性"><a href="#5-1、获取属性" class="headerlink" title="5.1、获取属性"></a>5.1、获取属性</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Class clazz = Person.class;</span><br><span class="line">    <span class="comment">// 获取属性结构</span></span><br><span class="line">    <span class="comment">// getFields()：获取当前运行时类及其父类中声明为public访问权限的属性</span></span><br><span class="line">    Field[] fields = clazz.getFields();</span><br><span class="line">    <span class="keyword">for</span> (Field f : fields) &#123;</span><br><span class="line">        System.out.println(f);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println();</span><br><span class="line">    <span class="comment">// getDeclaredFields()：获取当前运行时类中声明的所有属性。（不包含父类中声明的属性）</span></span><br><span class="line">    Field[] declaredFields = clazz.getDeclaredFields();</span><br><span class="line">    <span class="keyword">for</span> (Field f : declaredFields) &#123;</span><br><span class="line">        System.out.println(f);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="5-2、获取方法"><a href="#5-2、获取方法" class="headerlink" title="5.2、获取方法"></a>5.2、获取方法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    Class clazz = Person.class;</span><br><span class="line">    <span class="comment">// getMethods()：获取当前运行时类及其所有父类中声明为public权限的方法</span></span><br><span class="line">    Method[] methods = clazz.getMethods();</span><br><span class="line">    <span class="keyword">for</span> (Method m : methods) &#123;</span><br><span class="line">        System.out.println(m);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println();</span><br><span class="line">    <span class="comment">// getDeclaredMethods()：获取当前运行时类中声明的所有方法。（不包含父类中声明的方法）</span></span><br><span class="line">    Method[] declaredMethods = clazz.getDeclaredMethods();</span><br><span class="line">    <span class="keyword">for</span> (Method m : declaredMethods) &#123;</span><br><span class="line">        System.out.println(m);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="5-3、获取其他结构"><a href="#5-3、获取其他结构" class="headerlink" title="5.3、获取其他结构"></a>5.3、获取其他结构</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取构造器结构</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    Class clazz = Person.class;</span><br><span class="line">    <span class="comment">// getConstructors()：获取当前运行时类中声明为public的构造器</span></span><br><span class="line">    Constructor[] constructors = clazz.getConstructors();</span><br><span class="line">    <span class="keyword">for</span> (Constructor c : constructors) &#123;</span><br><span class="line">        System.out.println(c);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println();</span><br><span class="line">    <span class="comment">// getDeclaredConstructors()：获取当前运行时类中声明的所有构造器</span></span><br><span class="line">    Constructor[] declaredConstructors = clazz.getDeclaredConstructors();</span><br><span class="line">    <span class="keyword">for</span> (Constructor c : declaredConstructors) &#123;</span><br><span class="line">        System.out.println(c);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取运行时类的父类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    Class clazz = Person.class;</span><br><span class="line">    Class superclass = clazz.getSuperclass();</span><br><span class="line">    System.out.println(superclass);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取运行时类的带泛型的父类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    Class clazz = Person.class;</span><br><span class="line">    Type genericSuperclass = clazz.getGenericSuperclass();</span><br><span class="line">    System.out.println(genericSuperclass);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取运行时类的带泛型的父类的泛型</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test4</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    Class clazz = Person.class;</span><br><span class="line">    Type genericSuperclass = clazz.getGenericSuperclass();</span><br><span class="line">    ParameterizedType paramType = (ParameterizedType) genericSuperclass;</span><br><span class="line">    <span class="comment">// 获取泛型类型</span></span><br><span class="line">    Type[] actualTypeArguments = paramType.getActualTypeArguments();</span><br><span class="line">    <span class="keyword">for</span> (Type type : actualTypeArguments) &#123;</span><br><span class="line">        System.out.println(type.getTypeName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取运行时类实现的接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test5</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    Class clazz = Person.class;</span><br><span class="line">    Class[] interfaces = clazz.getInterfaces();</span><br><span class="line">    <span class="keyword">for</span> (Class c : interfaces) &#123;</span><br><span class="line">        System.out.println(c);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println();</span><br><span class="line">    <span class="comment">//获取运行时类的父类实现的接口</span></span><br><span class="line">    Class[] interfaces1 = clazz.getSuperclass().getInterfaces();</span><br><span class="line">    <span class="keyword">for</span> (Class c : interfaces1) &#123;</span><br><span class="line">        System.out.println(c);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取运行时类所在的包</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test6</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    Class clazz = Person.class;</span><br><span class="line">    Package pack = clazz.getPackage();</span><br><span class="line">    System.out.println(pack);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取运行时类声明的注解</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test7</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    Class clazz = Person.class;</span><br><span class="line">    Annotation[] annotations = clazz.getAnnotations();</span><br><span class="line">    <span class="keyword">for</span> (Annotation annos : annotations) &#123;</span><br><span class="line">        System.out.println(annos);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6、反射应用三：调用运行时类的指定结构"><a href="#6、反射应用三：调用运行时类的指定结构" class="headerlink" title="6、反射应用三：调用运行时类的指定结构"></a>6、反射应用三：调用运行时类的指定结构</h3><h4 id="6-1、调用指定的属性"><a href="#6-1、调用指定的属性" class="headerlink" title="6.1、调用指定的属性"></a>6.1、调用指定的属性</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testField1</span> <span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Class clazz = Person.class;</span><br><span class="line">        <span class="comment">// 创建运行时类的对象</span></span><br><span class="line">        Person p = (Person) clazz.newInstance();</span><br><span class="line">        <span class="comment">// 1、getDeclaredField(String fieldName)：获取运行时类中指定变量名的属性</span></span><br><span class="line">        Field name = clazz.getDeclaredField(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        <span class="comment">// 2、保证当前属性时可访问的</span></span><br><span class="line">        name.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        <span class="comment">// 3、获取、设置指定对象的此属性值</span></span><br><span class="line">        name.set(p, <span class="string">&quot;Tom&quot;</span>);</span><br><span class="line">        System.out.println(name.get(p));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="6-2、调用指定的方法"><a href="#6-2、调用指定的方法" class="headerlink" title="6.2、调用指定的方法"></a>6.2、调用指定的方法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testMethod</span> <span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    Class clazz = Person.class;</span><br><span class="line">    <span class="comment">// 创建运行时类的对象</span></span><br><span class="line">    Person p = (Person) clazz.newInstance();</span><br><span class="line">    <span class="comment">// 1、获取指定的某个方法</span></span><br><span class="line">    <span class="comment">// getDeclaredMethod()：参数1指明获取的方法的名称 参数2指明获取的方法的形参类型</span></span><br><span class="line">    Method show = clazz.getDeclaredMethod(<span class="string">&quot;show&quot;</span>, String.class);</span><br><span class="line">    <span class="comment">// 2、保证当前方法是可访问的</span></span><br><span class="line">    show.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">    <span class="comment">// 3、调用方法的invoke()：参数1方法的调用者 参数2给方法形参赋值的实参</span></span><br><span class="line">    <span class="comment">// invoke()的返回值即为对应类中调用的方法的返回值</span></span><br><span class="line">    Object returnValue = show.invoke(p, <span class="string">&quot;CHN&quot;</span>);</span><br><span class="line">    System.out.println(returnValue);</span><br><span class="line">    <span class="comment">// 如何调用静态方法</span></span><br><span class="line">    Method showDesc = clazz.getDeclaredMethod(<span class="string">&quot;showDesc&quot;</span>);</span><br><span class="line">    showDesc.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">    <span class="comment">// 如果调用的运行时类中的方法没有返回值，则此invoke()返回null</span></span><br><span class="line">    <span class="comment">// Object returnVal = showDesc.invoke(null);</span></span><br><span class="line">    Object returnVal = showDesc.invoke(Person.class);</span><br><span class="line">    System.out.println(returnVal);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="6-3、调用指定的构造器"><a href="#6-3、调用指定的构造器" class="headerlink" title="6.3、调用指定的构造器"></a>6.3、调用指定的构造器</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testConstructor</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    Class clazz = Person.class;</span><br><span class="line">    <span class="comment">// 1、获取指定的构造器</span></span><br><span class="line">    <span class="comment">// getDeclaredConstructor()：参数指明构造器的参数列表</span></span><br><span class="line">    Constructor constructor = clazz.getDeclaredConstructor(String.class);</span><br><span class="line">    <span class="comment">// 2、保证此构造器是可访问的</span></span><br><span class="line">    constructor.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">    <span class="comment">// 3、调用此构造器创建运行时类的对象</span></span><br><span class="line">    Person per = (Person) constructor.newInstance(<span class="string">&quot;Tom&quot;</span>);</span><br><span class="line">    System.out.println(per);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="7、反射应用四：动态代理"><a href="#7、反射应用四：动态代理" class="headerlink" title="7、反射应用四：动态代理"></a>7、反射应用四：动态代理</h3><h4 id="7-1、代理模式的原理"><a href="#7-1、代理模式的原理" class="headerlink" title="7.1、代理模式的原理"></a>7.1、代理模式的原理</h4><ul>
<li>使用一个代理将对象包装起来，然后用该代理对象取代原始对象。任何对原始对象的调用都要通过代理。代理对象决定是否以及何时将方法调用转到原始对象上。</li>
</ul>
<h4 id="7-2、静态代理"><a href="#7-2、静态代理" class="headerlink" title="7.2、静态代理"></a>7.2、静态代理</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 被代理类</span></span><br><span class="line"><span class="function">Class MyThread implements <span class="title">Runnable</span> <span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"><span class="comment">// 代理类</span></span><br><span class="line"><span class="function">Class Thread implements <span class="title">Runnable</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"><span class="comment">// 代理操作</span></span><br><span class="line">main () &#123;</span><br><span class="line">    MyThread t = <span class="keyword">new</span> MyThread();</span><br><span class="line">    Thread thread = <span class="keyword">new</span> Thread(t);</span><br><span class="line">    thread.start();<span class="comment">// 启动线程；调用线程的run()</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>静态代理的缺点<ul>
<li>代理类和目标对象的类都是在编译期间确定下来，不利于程序的扩展。</li>
<li>每一个代理类只能为一个接口服务，这样一来程序开发中必然产生过多的代理。</li>
</ul>
</li>
</ul>
<h4 id="7-3、动态代理的特点"><a href="#7-3、动态代理的特点" class="headerlink" title="7.3、动态代理的特点"></a>7.3、动态代理的特点</h4><ul>
<li>动态代理是指客户通过代理类来调用其它对象的方法，并且是在程序<strong>运行时根据需要动态创建</strong>目标类的代理对象。</li>
</ul>
<h4 id="7-4、动态代理的实现"><a href="#7-4、动态代理的实现" class="headerlink" title="7.4、动态代理的实现"></a>7.4、动态代理的实现</h4><ul>
<li>需要解决的两个主要问题：<ul>
<li>问题一：如何根据加载到内存中的被代理类，动态创建一个代理类及其对象 –&gt; 通过Proxy.newProxyInstance()实现</li>
<li>问题二：当通过代理类的对象调用方法a时，如何动态的去调用被代理类中的同名方法a –&gt; 通过InvocationHandler接口的实现类及其方法invoke()</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 动态代理体会：反射的动态性</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Human</span> </span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">getBelief</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">eat</span><span class="params">(String food)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 被代理类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SuperMan</span> <span class="keyword">implements</span> <span class="title">Human</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getBelief</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;I believe I can fly!&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">(String food)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我喜欢吃&quot;</span> + food);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HumanUtil</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method1</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;=======通用方法一=======&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method2</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;=======通用方法二=======&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProxyFactory</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 调用此方法，返回一个代理类的对象。解决问题一</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">getProxyInstance</span><span class="params">(Object obj)</span> </span>&#123;<span class="comment">// obj：被代理类的对象</span></span><br><span class="line">        MyInvocationHandler handler = <span class="keyword">new</span> MyInvocationHandler();</span><br><span class="line">        handler.bind(obj);</span><br><span class="line">        <span class="keyword">return</span> Proxy.newProxyInstance(obj.getClass().getClassLoader(), obj.getClass().getInterfaces(), handler);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyInvocationHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object obj;<span class="comment">// 需要使用被代理类的对象进行赋值</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bind</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.obj = obj;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 当我们通过代理类的对象，调用方法a时，就会自动的调用如下的方法：invoke()</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        HumanUtil util = <span class="keyword">new</span> HumanUtil();</span><br><span class="line">        util.method1();</span><br><span class="line">        <span class="comment">// method：即为代理类对象调用的方法，此方法也就作为了被代理类对象要调用的方法</span></span><br><span class="line">        <span class="comment">// obj：被代理类的对象</span></span><br><span class="line">        Object returnValue = method.invoke(obj, args);</span><br><span class="line">        util.method2();</span><br><span class="line">        <span class="comment">// 上述方法的返回值就作为当前类中的invoke()返回值</span></span><br><span class="line">        <span class="keyword">return</span> returnValue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SuperMan superMan = <span class="keyword">new</span> SuperMan();</span><br><span class="line">        <span class="comment">// proxyInstance：代理类的对象</span></span><br><span class="line">        Human proxyInstance = (Human) ProxyFactory.getProxyInstance(superMan);</span><br><span class="line">        <span class="comment">// 当通过代理类对象调用方法时，会自动的调用被代理类中同名的方法</span></span><br><span class="line">        String belief = proxyInstance.getBelief();</span><br><span class="line">        System.out.println(belief);</span><br><span class="line">        proxyInstance.eat(<span class="string">&quot;四川麻辣烫&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="九、Java8的其它新特性"><a href="#九、Java8的其它新特性" class="headerlink" title="九、Java8的其它新特性"></a>九、Java8的其它新特性</h2><h3 id="1、Java8的新特性概述"><a href="#1、Java8的新特性概述" class="headerlink" title="1、Java8的新特性概述"></a>1、Java8的新特性概述</h3><ul>
<li>函数式接口</li>
<li>Lambda表达式</li>
<li>方法引用/构造器引用</li>
<li>Stream API<ul>
<li>并行流</li>
<li>串行流</li>
</ul>
</li>
<li>接口的增强<ul>
<li>静态方法</li>
<li>默认方法</li>
</ul>
</li>
<li>Optional类</li>
<li>新的时间和日期API</li>
<li>其它新特性<ul>
<li>重复注解</li>
<li>类型注解</li>
<li>通用目标类型推断</li>
<li>JDK的更新<ul>
<li>集合的流式操作</li>
<li>并发</li>
<li>Arrays</li>
<li>Number和Math</li>
<li>IO/NIO的改进</li>
<li>Reflection获取形参名</li>
<li>String:join()</li>
<li>Files</li>
</ul>
</li>
<li>新编译工具：jjs、jdeps</li>
<li>JVM中Metaspace取代PermGen空间<h3 id="2、Lambda表达式"><a href="#2、Lambda表达式" class="headerlink" title="2、Lambda表达式"></a>2、Lambda表达式</h3><h4 id="2-1、Lambda表达式使用前后的对比"><a href="#2-1、Lambda表达式使用前后的对比" class="headerlink" title="2.1、Lambda表达式使用前后的对比"></a>2.1、Lambda表达式使用前后的对比</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    Runnable r1 = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;我爱北京天安门&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    r1.run();</span><br><span class="line">    <span class="comment">// 使用lambda表达式</span></span><br><span class="line">    Runnable r2 = () -&gt; System.out.println(<span class="string">&quot;我爱北京天安门&quot;</span>);</span><br><span class="line">    r2.run();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    Comparator&lt;Integer&gt; com1 = <span class="keyword">new</span> Comparator&lt;Integer&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Integer o1, Integer o2)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> Integer.compare(o1, o2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    System.out.println(com1.compare(<span class="number">12</span>, <span class="number">21</span>));</span><br><span class="line">    <span class="comment">// Lambda表达式的写法</span></span><br><span class="line">    Comparator&lt;Integer&gt; com2 = (o1, o2) -&gt; Integer.compare(o1, o2);</span><br><span class="line">    System.out.println(com2.compare(<span class="number">32</span>, <span class="number">21</span>));</span><br><span class="line">    <span class="comment">// 方法引用</span></span><br><span class="line">    Comparator&lt;Integer&gt; com3 = Integer :: compare;</span><br><span class="line">    System.out.println(com3.compare(<span class="number">32</span>, <span class="number">21</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h4 id="2-2、Lambda表达式的基本语法"><a href="#2-2、Lambda表达式的基本语法" class="headerlink" title="2.2、Lambda表达式的基本语法"></a>2.2、Lambda表达式的基本语法</h4><ul>
<li>举例：(o1, o2) -&gt; Integer.compare(o1, o2);</li>
<li>格式：<ul>
<li>-&gt;：lambda操作符或箭头操作符</li>
<li>-&gt;左边：lambda形参列表（其实就是接口中的抽象方法的形参列表）</li>
<li>-&gt;右边：lambda体（其实就是重写的抽象方法的方法体）</li>
</ul>
</li>
</ul>
<h4 id="2-3、如何使用：分为六种情况"><a href="#2-3、如何使用：分为六种情况" class="headerlink" title="2.3、如何使用：分为六种情况"></a>2.3、如何使用：分为六种情况</h4><ul>
<li>语法格式一：无参，无返回值<ul>
<li><code>Runnable r1 = () -&gt; &#123;System.out.println(&quot;Hello Lambda!&quot;);&#125;;</code></li>
</ul>
</li>
<li>语法格式二：Lambda需要一个参数，但是没有返回值<ul>
<li><code>Consumer&lt;String&gt; con = (String str) -&gt; &#123;System.out.println(str);&#125;;</code></li>
</ul>
</li>
<li>语法格式三：数据类型可以省略，因为可由编译器推断得出，称为“类型推断”<ul>
<li><code>Consumer&lt;String&gt; con = (str) -&gt; &#123;System.out.println(str);&#125;;</code></li>
</ul>
</li>
<li>语法格式四：Lambda若只需要一个参数时，参数的小括号可以省略<ul>
<li><code>Consumer&lt;String&gt; con = str -&gt; &#123;System.out.println(str);&#125;;</code></li>
</ul>
</li>
<li>语法格式五：Lambda需要两个或以上的参数，多条执行语句，并且可以有返回值<ul>
<li><code>Comparator&lt;Integer&gt; com = (x, y) -&gt; &#123;System.out.println(&quot;实现函数式接口方法！&quot;); return Integer.compare(x, y);&#125;;</code></li>
</ul>
</li>
<li>语法格式六：当Lambda体只有一条语句时，return与大括号若有，都可以省略<ul>
<li><code>Comparator&lt;Integer&gt; com = (x, y) -&gt; Integer.compare(x, y);</code></li>
</ul>
</li>
</ul>
<blockquote>
<p>总结六种情况：<br>-&gt;左边：lambda形参列表的参数类型可以省略（类型推断）；如果lambda形参列表只有一个参数，其一对()也可以省略<br>-&gt;右边：lambda体应该使用一对{}包裹；如果lambda体只有一条执行语句（可能是return语句，省略这一对{}和return关键字）</p>
</blockquote>
<h3 id="3、函数式接口"><a href="#3、函数式接口" class="headerlink" title="3、函数式接口"></a>3、函数式接口</h3><h4 id="3-1、函数式接口的使用说明"><a href="#3-1、函数式接口的使用说明" class="headerlink" title="3.1、函数式接口的使用说明"></a>3.1、函数式接口的使用说明</h4><ul>
<li>如果一个接口中，只声明了一个抽象方法，则此接口就称为函数式接口</li>
<li>我们可以在一个接口上使用@FunctionalInterface注解，这样做可以检查它是否是一个函数式接口</li>
<li>Lambda表达式的本质：作为函数式接口的实例</li>
</ul>
<h4 id="3-2、Java8中关于Lambda表达式提供的4个基本的函数式接口"><a href="#3-2、Java8中关于Lambda表达式提供的4个基本的函数式接口" class="headerlink" title="3.2、Java8中关于Lambda表达式提供的4个基本的函数式接口"></a>3.2、Java8中关于Lambda表达式提供的4个基本的函数式接口</h4><table>
<thead>
<tr>
<th align="center">函数式接口</th>
<th align="center">参数类型</th>
<th align="center">返回类型</th>
<th align="center">用途</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>Consumer&lt;T&gt;</code>消费型接口</td>
<td align="center">T</td>
<td align="center">void</td>
<td align="center">对类型为T的对象应用操作，包含方法：void accept(T t)</td>
</tr>
<tr>
<td align="center"><code>Supplier&lt;T&gt;</code>供给型接口</td>
<td align="center">无</td>
<td align="center">T</td>
<td align="center">返回类型为T的对象，包含方法：T get()</td>
</tr>
<tr>
<td align="center"><code>Function&lt;T, R&gt;</code>函数型接口</td>
<td align="center">T</td>
<td align="center">R</td>
<td align="center">对类型为T的对象应用操作，并返回结果。结果是R类型的对象。包含方法：R apply(T t)</td>
</tr>
<tr>
<td align="center"><code>Predicate&lt;T&gt;</code>断定型接口</td>
<td align="center">T</td>
<td align="center">boolean</td>
<td align="center">确定类型为T的对象是否满足某约束，并返回boolean值。包含方法：boolean test(T t)</td>
</tr>
</tbody></table>
<h4 id="3-3、总结"><a href="#3-3、总结" class="headerlink" title="3.3、总结"></a>3.3、总结</h4><ul>
<li>何时使用lambda表达式？<ul>
<li>当需要对一个函数式接口实例化的时候，可以使用lambda表达式</li>
</ul>
</li>
<li>何时使用给定的函数式接口？<ul>
<li>如果我们开发中需要定义一个函数式接口，首先看看在已有的JDK提供的函数式接口是否提供了能满足需求的函数式接口。如果有，则直接调用即可，不需要自己再自定义了。</li>
</ul>
</li>
</ul>
<h3 id="4、方法引用"><a href="#4、方法引用" class="headerlink" title="4、方法引用"></a>4、方法引用</h3><h4 id="4-1、理解"><a href="#4-1、理解" class="headerlink" title="4.1、理解"></a>4.1、理解</h4><ul>
<li>方法引用可以看做是Lambda表达式深层次的表达。换句话说，方法引用就是Lambda表达式，也就是函数式接口的一个实例，通过方法的名字来指向一个方法。</li>
</ul>
<h4 id="4-2、使用情境"><a href="#4-2、使用情境" class="headerlink" title="4.2、使用情境"></a>4.2、使用情境</h4><ul>
<li>当要传递给Lambda体的操作，已经有实现的方法了，可以使用方法引用</li>
</ul>
<h4 id="4-3、格式"><a href="#4-3、格式" class="headerlink" title="4.3、格式"></a>4.3、格式</h4><ul>
<li>类(或对象) :: 方法名</li>
</ul>
<h4 id="4-4、分为如下的三种情况"><a href="#4-4、分为如下的三种情况" class="headerlink" title="4.4、分为如下的三种情况"></a>4.4、分为如下的三种情况</h4><ul>
<li>对象 :: 非静态方法 –&gt; 情况1</li>
<li>类 :: 静态方法 –&gt; 情况2</li>
<li>类 :: 非静态方法 –&gt; 情况3</li>
</ul>
<h4 id="4-5、要求"><a href="#4-5、要求" class="headerlink" title="4.5、要求"></a>4.5、要求</h4><ul>
<li>要求接口中的抽象方法的形参列表和返回值类型与方法引用的方法的形参列表和返回值类型相同！（针对于情况1和情况2）</li>
<li>当函数式接口方法的第一个参数是需要引用方法的调用者，并且第二个参数是需要引用方法的参数（或无参数）时：ClassName :: methodName（针对于情况3）</li>
</ul>
<h4 id="4-6、使用建议"><a href="#4-6、使用建议" class="headerlink" title="4.6、使用建议"></a>4.6、使用建议</h4><ul>
<li>如果给函数式接口提供实例，恰好满足方法引用的使用情境，大家就可以考虑使用方法引用给函数式接口提供实例。如果大家不熟悉方法引用，那么还可以使用lambda表达式。</li>
</ul>
<h4 id="4-7、使用举例"><a href="#4-7、使用举例" class="headerlink" title="4.7、使用举例"></a>4.7、使用举例</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 情况一：对象 :: 实例方法</span></span><br><span class="line"><span class="comment">// Consumer中的void accept(T t)</span></span><br><span class="line"><span class="comment">// PrintStream中的void println(T t)</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    Consumer&lt;String&gt; con1 = str -&gt; System.out.println(str);</span><br><span class="line">    con1.accept(<span class="string">&quot;北京&quot;</span>);</span><br><span class="line">    <span class="comment">// 方法引用</span></span><br><span class="line">    PrintStream ps = System.out;</span><br><span class="line">    Consumer&lt;String&gt; con2 = ps::println;</span><br><span class="line">    con2.accept(<span class="string">&quot;beijing&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 情况二：类 :: 静态方法</span></span><br><span class="line"><span class="comment">// Comparator中int compare(T t1, T t2)</span></span><br><span class="line"><span class="comment">// Integer中的int compare(T t1, T t2)</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    Comparator&lt;Integer&gt; com1 = (t1, t2) -&gt; Integer.compare(t1, t2);</span><br><span class="line">    System.out.println(com1.compare(<span class="number">12</span>,<span class="number">21</span>));</span><br><span class="line">    <span class="comment">// 方法引用</span></span><br><span class="line">    Comparator&lt;Integer&gt; com2 = Integer::compare;</span><br><span class="line">    System.out.println(com2.compare(<span class="number">12</span>, <span class="number">3</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 情况三：类 :: 实例方法</span></span><br><span class="line"><span class="comment">// Comparator中的int compare(T t1, T t2)</span></span><br><span class="line"><span class="comment">// String中的int t1.compareTo(t2)</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test5</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    Comparator&lt;String&gt; com1 = (s1, s2) -&gt; s1.compareTo(s2);</span><br><span class="line">    System.out.println(com1.compare(<span class="string">&quot;abc&quot;</span>, <span class="string">&quot;abd&quot;</span>));</span><br><span class="line">    <span class="comment">// 方法引用</span></span><br><span class="line">    Comparator&lt;String&gt; com2 = String :: compareTo;</span><br><span class="line">    System.out.println(com2.compare(<span class="string">&quot;adb&quot;</span>, <span class="string">&quot;abm&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5、构造器引用与数组引用"><a href="#5、构造器引用与数组引用" class="headerlink" title="5、构造器引用与数组引用"></a>5、构造器引用与数组引用</h3><h4 id="5-1、构造器引用格式"><a href="#5-1、构造器引用格式" class="headerlink" title="5.1、构造器引用格式"></a>5.1、构造器引用格式</h4><ul>
<li>类名::new</li>
</ul>
<h4 id="5-2、构造器引用使用要求"><a href="#5-2、构造器引用使用要求" class="headerlink" title="5.2、构造器引用使用要求"></a>5.2、构造器引用使用要求</h4><ul>
<li>和方法引用类似，函数式接口的抽象方法的形参列表和构造器的形参列表一致。抽象方法的返回值类型即为构造器所属的类的类型</li>
</ul>
<h4 id="5-3、构造器引用举例"><a href="#5-3、构造器引用举例" class="headerlink" title="5.3、构造器引用举例"></a>5.3、构造器引用举例</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 构造器引用</span></span><br><span class="line"><span class="comment">// Supplier的T get()</span></span><br><span class="line"><span class="comment">// Employee的空参构造器：Employee()</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    Supplier&lt;Employee&gt; sup = <span class="keyword">new</span> Supplier&lt;Employee&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Employee <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Employee();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// lambda表达式</span></span><br><span class="line">    Supplier&lt;Employee&gt; sup1 = () -&gt; <span class="keyword">new</span> Employee();</span><br><span class="line">    System.out.println(sup1.get());</span><br><span class="line">    <span class="comment">// 构造器引用</span></span><br><span class="line">    Supplier&lt;Employee&gt; sup2 = Employee :: <span class="keyword">new</span>;</span><br><span class="line">    System.out.println(sup2.get());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Function中的R apply(T t)</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    Function&lt;Integer, Employee&gt; func1 = id -&gt; <span class="keyword">new</span> Employee(id);</span><br><span class="line">    System.out.println(func1.apply(<span class="number">1001</span>));</span><br><span class="line">    <span class="comment">// 构造器引用</span></span><br><span class="line">    Function&lt;Integer, Employee&gt; func2 = Employee :: <span class="keyword">new</span>;</span><br><span class="line">    System.out.println(func2.apply(<span class="number">1002</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="5-4、数组引用格式"><a href="#5-4、数组引用格式" class="headerlink" title="5.4、数组引用格式"></a>5.4、数组引用格式</h4><ul>
<li>数组类型[]::new</li>
</ul>
<h4 id="5-5、数组引用举例"><a href="#5-5、数组引用举例" class="headerlink" title="5.5、数组引用举例"></a>5.5、数组引用举例</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 数组引用</span></span><br><span class="line"><span class="comment">// Function中的R apply(T t)</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test4</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    Function&lt;Integer, String[]&gt; func1 = length -&gt; <span class="keyword">new</span> String[length];</span><br><span class="line">    System.out.println(Arrays.toString(func1.apply(<span class="number">5</span>)));</span><br><span class="line">    <span class="comment">// 数组引用</span></span><br><span class="line">    Function&lt;Integer, String[]&gt; func2 = String[] :: <span class="keyword">new</span>;</span><br><span class="line">    System.out.println(Arrays.toString(func2.apply(<span class="number">10</span>)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6、Stream-API"><a href="#6、Stream-API" class="headerlink" title="6、Stream API"></a>6、Stream API</h3><h4 id="6-1、Stream-API的理解"><a href="#6-1、Stream-API的理解" class="headerlink" title="6.1、Stream API的理解"></a>6.1、Stream API的理解</h4><ul>
<li>Stream关注的是对数据的运算，与CPU打交道；集合关注的是数据的存储，与内存打交道</li>
<li>Java 8提供了一套API，使用这套API可以对内存中的数据进行过滤、排序、映射、归约等操作。类似SQL对数据库中表的相关操作。</li>
</ul>
<h4 id="6-2、注意点"><a href="#6-2、注意点" class="headerlink" title="6.2、注意点"></a>6.2、注意点</h4><ul>
<li>Stream自己不会存储元素</li>
<li>Stream不会改变源对象。相反，他们会返回一个持有结果的新的Stream</li>
<li>Stream操作是延迟执行的。这意味着他们会等到需要结果的时候才执行</li>
</ul>
<h4 id="6-3、Stream的使用流程"><a href="#6-3、Stream的使用流程" class="headerlink" title="6.3、Stream的使用流程"></a>6.3、Stream的使用流程</h4><ul>
<li>Stream的实例化</li>
<li>一系列的中间操作（过滤、映射、…）</li>
<li>终止操作</li>
</ul>
<h4 id="6-4、使用流程的注意点"><a href="#6-4、使用流程的注意点" class="headerlink" title="6.4、使用流程的注意点"></a>6.4、使用流程的注意点</h4><ul>
<li>一个中间操作链，对数据源的数据进行处理</li>
<li>一旦执行终止操作，就执行中间操作链，并产生结果。之后，不会再被使用。</li>
</ul>
<h4 id="6-5、步骤一：Stream实例化"><a href="#6-5、步骤一：Stream实例化" class="headerlink" title="6.5、步骤一：Stream实例化"></a>6.5、步骤一：Stream实例化</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建Stream方式一：通过集合</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    List&lt;Employee&gt; employees = EmployeeData.getEmployees();</span><br><span class="line">    <span class="comment">// default Stream&lt;E&gt; stream()：返回一个顺序流</span></span><br><span class="line">    Stream&lt;Employee&gt; stream = employees.stream();</span><br><span class="line">    <span class="comment">// default Stream&lt;E&gt; parallelStream()：返回一个并行流</span></span><br><span class="line">    Stream&lt;Employee&gt; parallelStream = employees.parallelStream();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 创建Stream方式二：通过数组</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line">    <span class="comment">// 调用Arrays类的static &lt;T&gt; Stream&lt;T&gt; stream(T[] array)：返回一个流</span></span><br><span class="line">    IntStream stream = Arrays.stream(arr);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 创建Stream方式三：通过Stream的of()</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    Stream&lt;Integer&gt; stream = Stream.of(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 创建Stream方式四：创建无限流</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test4</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 迭代</span></span><br><span class="line">    <span class="comment">// public static &lt;T&gt; Stream&lt;T&gt; iterate(final T seed, final UnaryOperator&lt;T&gt; f)</span></span><br><span class="line">    <span class="comment">// 遍历前10个偶数</span></span><br><span class="line">    Stream.iterate(<span class="number">0</span>, t -&gt; t + <span class="number">2</span>).limit(<span class="number">10</span>).forEach(System.out::println);</span><br><span class="line">    <span class="comment">// 生成</span></span><br><span class="line">    <span class="comment">// public static &lt;T&gt; Stream&lt;T&gt; generate(Supplier&lt;T&gt; s)</span></span><br><span class="line">    Stream.generate(Math::random).limit(<span class="number">10</span>).forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="6-6、步骤二：中间操作"><a href="#6-6、步骤二：中间操作" class="headerlink" title="6.6、步骤二：中间操作"></a>6.6、步骤二：中间操作</h4><ul>
<li>筛选与切片<ul>
<li>filter(Predicate p)：接收Lambda，从流中排除某些元素</li>
<li>distinct()：筛选，通过流所生成元素的hashCode()和equals()去除重复元素</li>
<li>limit(long maxSize)：截断流，使其元素不超过给定数量</li>
<li>skip(long n)：跳过元素，返回一个扔掉了前n个元素的流。若流中元素不足n个，则返回一个空流。与limit(n)互补</li>
</ul>
</li>
<li>映射<ul>
<li>map(Function f)：接收一个函数作为参数，该函数会被应用到每个元素上，并将其映射成一个新的元素</li>
<li>mapToDouble(ToDoubleFunction f)：接收一个函数作为参数，该函数会被应用到每个元素上，产生一个新的DoubleStream</li>
<li>mapToInt(ToIntFunction f)：接收一个函数作为参数，该函数会被应用到每个元素上，产生一个新的IntStream</li>
<li>mapToLong(ToLongFunction f)：接收一个函数作为参数，该函数会被应用到每个元素上，产生一个新的LongStream</li>
<li>flatMap(Function f)：接收一个函数作为参数，将流中的每个值都换成另一个流，然后把所有流连接成一个流</li>
</ul>
</li>
<li>排序<ul>
<li>sorted()：产生一个新流，其中按自然顺序排序</li>
<li>sorted(Comparator com)：产生一个新流，其中按比较器顺序排序</li>
</ul>
</li>
</ul>
<h4 id="6-7、步骤三：终止操作"><a href="#6-7、步骤三：终止操作" class="headerlink" title="6.7、步骤三：终止操作"></a>6.7、步骤三：终止操作</h4><ul>
<li>匹配与查找<ul>
<li>allMatch(Predicate p)：检查是否匹配所有元素</li>
<li>anyMatch(Predicate p)：检查是否至少匹配一个元素</li>
<li>noneMatch(Predicate p)：检查是否没有匹配所有元素</li>
<li>findFirst()：返回第一个元素</li>
<li>findAny()：返回当前流中的任意元素</li>
<li>count()：返回流中元素总数</li>
<li>max(Comparator c)：返回流中最大值</li>
<li>min(Comparator c)：返回流中最小值</li>
<li>forEach(Consumer c)：内部迭代（使用Collection接口需要用户去做迭代，称为外部迭代。相反，Stream API使用内部迭代——它帮你把迭代做了）</li>
</ul>
</li>
<li>归约<ul>
<li>reduce(T iden, BinaryOperator b)：可以将流中元素反复结合起来，得到一个值。返回T</li>
<li>reduce(BinaryOperator b)：可以将流中元素反复结合起来，得到一个值。返回<code>Optional&lt;T&gt;</code></li>
</ul>
</li>
<li>收集<ul>
<li>collect(Collector c)：将流转换为其他形式。接收一个Collector接口的实现，用于给Stream中元素做汇总的方法(Collector通过Collectors提供实例)<ul>
<li>toList()</li>
<li>toSet()</li>
<li>toCollection()</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="7、Optional类的使用"><a href="#7、Optional类的使用" class="headerlink" title="7、Optional类的使用"></a>7、Optional类的使用</h3><h4 id="7-1、理解"><a href="#7-1、理解" class="headerlink" title="7.1、理解"></a>7.1、理解</h4><ul>
<li>为了解决Java中的空指针问题而生！</li>
<li><code>Optional&lt;T&gt;</code>类(java.util.Optional)是一个容器类，它可以保存类型T的值，代表这个值存在。或者仅仅保存null，表示这个值不存在。原来用null表示一个值不存在，现在Optional可以更好的表达这个概念。并且可以避免空指针异常。</li>
</ul>
<h4 id="7-2、常用方法"><a href="#7-2、常用方法" class="headerlink" title="7.2、常用方法"></a>7.2、常用方法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// empty()：创建的Optional对象内部的value = null</span></span><br><span class="line">    Optional&lt;Object&gt; op1 = Optional.empty();</span><br><span class="line">    <span class="keyword">if</span> (!op1.isPresent()) &#123;</span><br><span class="line">        <span class="comment">// Optional封装的数据是否包含数据</span></span><br><span class="line">        System.out.println(<span class="string">&quot;数据为空&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果Optional封装的数据value为空，则get()报错。否则，value不为空时，返回value</span></span><br><span class="line">    <span class="comment">// System.out.println(op1.get());</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    String str = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    <span class="comment">// of(T t)：封装数据t生成Optional对象，要求t非空，否则报错</span></span><br><span class="line">    Optional&lt;String&gt; op1 = Optional.of(str);</span><br><span class="line">    <span class="comment">// get()通常与of()方法搭配使用。用于获取内部的封装的数据value</span></span><br><span class="line">    String str1 = op1.get();</span><br><span class="line">    System.out.println(str1);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    String str = <span class="string">&quot;beijing&quot;</span>;</span><br><span class="line">    str = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// ofNullable(T t)：封装数据t赋给Optional内部的value。不要求t非空</span></span><br><span class="line">    Optional&lt;String&gt; op1 = Optional.ofNullable(str);</span><br><span class="line">    <span class="comment">// orElse(T t1)：如果Optional内部的value非空，则返回此value值。如果value为空，则返回t1</span></span><br><span class="line">    String str2 = op1.orElse(<span class="string">&quot;shanghai&quot;</span>);</span><br><span class="line">    System.out.println(str2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构与算法（一）稀疏数组和队列</title>
    <url>/hexo-blog/2021/11/26/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E4%B8%80%EF%BC%89%E7%A8%80%E7%96%8F%E6%95%B0%E7%BB%84%E5%92%8C%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<h5 id="1、数据结构与算法的关系"><a href="#1、数据结构与算法的关系" class="headerlink" title="1、数据结构与算法的关系"></a>1、数据结构与算法的关系</h5><p>（1）数据（data）结构（structure）是一门研究组织数据方式的学科，有了编程语言也就有了数据结构，学好数据结构可以编写出更加漂亮的、更加有效率的代码</p>
<p>（2）要学好数据结构就要多考虑如何将生活中遇到的问题，用程序去实现解决</p>
<p>（3）程序 = 数据结构 + 算法</p>
<p>（4）数据结构是算法的基础</p>
<h5 id="2、线性结构"><a href="#2、线性结构" class="headerlink" title="2、线性结构"></a>2、线性结构</h5><p>（1）线性结构作为最常用的数据结构，其特点是数据元素之间存在一对一的线性关系</p>
<p>（2）线性结构有两种不同的存储结构，即顺序存储结构（数组）和链式存储结构（链表）。顺序存储的线性表称为顺序表，顺序表中的存储元素是连续的</p>
<p>（3）链式存储的线性表称为链表，链表中的存储元素不一定是连续的，元素节点中存放数据元素以及相邻的元素的地址信息</p>
<p>（4）线性结构常见的有：数组、队列、链表和栈</p>
<h5 id="3、非线性结构"><a href="#3、非线性结构" class="headerlink" title="3、非线性结构"></a>3、非线性结构</h5><p>非线性结构包括：二维数组，多维数组，广义表，树结构，图结构</p>
<h5 id="4、稀疏数组"><a href="#4、稀疏数组" class="headerlink" title="4、稀疏数组"></a>4、稀疏数组</h5><p><strong>4.1</strong> <strong>先看一个实际的需求</strong></p>
<p>在五子棋游戏中，有存盘和接上盘的功能</p>
<p><img src="https://rulerofterabithia-blog.oss-cn-hangzhou.aliyuncs.com/img/20221017100800.png"></p>
<p>因为该二维数组有很多的默认数据都为0，因此记录了很多没有意义的数据</p>
<p>当一个数组中大部分元素为0时，或者为同一个值时，可以使用稀疏数组来保存该数组</p>
<p><strong>4.2</strong> <strong>稀疏数组的处理方法是：</strong></p>
<p>（1）记录数组一共有几行几列，有多少个不同的值</p>
<p>（2）把具有不同值的元素的行和列以及值记录在一个小规模的数组中，从而缩小数据的规模</p>
<p><img src="https://rulerofterabithia-blog.oss-cn-hangzhou.aliyuncs.com/img/20221017100947.png"></p>
<p><strong>4.3</strong> 思路</p>
<p>二维数组 转 稀疏数组的思路</p>
<p>（1） 遍历 原始的二维数组，得到有效数据的个数 sum</p>
<p>（2）根据sum 就可以创建 稀疏数组 sparseArr  int[sum + 1] [3]</p>
<p>（3）将二维数组的有效数据数据存入到 稀疏数组</p>
<p>稀疏数组转原始的二维数组的思路</p>
<p>（1）先读取稀疏数组的第一行，根据第一行的数据，创建原始的二维数组，比如上面的 chessArr2 = int [11][11]</p>
<p>（2） 在读取稀疏数组后几行的数据，并赋给 原始的二维数组 即可.</p>
<p>代码实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.cyk.sparsearray;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SparseArray</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建一个原始的二维数组11*11</span></span><br><span class="line">        <span class="comment">// 0：表示没有棋子，1：表示黑子，2：表示蓝子</span></span><br><span class="line">        <span class="keyword">int</span> chessArr1[][] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">11</span>][<span class="number">11</span>];</span><br><span class="line">        chessArr1[<span class="number">1</span>][<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">        chessArr1[<span class="number">2</span>][<span class="number">3</span>] = <span class="number">2</span>;</span><br><span class="line">        chessArr1[<span class="number">4</span>][<span class="number">5</span>] = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 输出原始的二维数组</span></span><br><span class="line">        System.out.println(<span class="string">&quot;原始的二维数组为：&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] row : chessArr1) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> data : row) &#123;</span><br><span class="line">                System.out.printf(<span class="string">&quot;%d\t&quot;</span>, data);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将二维数组转为稀疏数组</span></span><br><span class="line">        <span class="comment">//1、先遍历二维数组，得到非零数据的个数</span></span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">11</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">11</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (chessArr1[i][j] != <span class="number">0</span>) &#123;</span><br><span class="line">                    sum++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建对应的稀疏数组</span></span><br><span class="line">        <span class="keyword">int</span> sparseArr[][] = <span class="keyword">new</span> <span class="keyword">int</span>[sum + <span class="number">1</span>][<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//给稀疏数组赋值</span></span><br><span class="line">        sparseArr[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">11</span>;</span><br><span class="line">        sparseArr[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">11</span>;</span><br><span class="line">        sparseArr[<span class="number">0</span>][<span class="number">2</span>] = sum;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//遍历二维数组，将非零的数据放到稀疏数组中</span></span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;<span class="comment">//count用于记录是第几个非零元素</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">11</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">11</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (chessArr1[i][j] != <span class="number">0</span>) &#123;</span><br><span class="line">                    count++;</span><br><span class="line">                    sparseArr[count][<span class="number">0</span>] = i;</span><br><span class="line">                    sparseArr[count][<span class="number">1</span>] = j;</span><br><span class="line">                    sparseArr[count][<span class="number">2</span>] = chessArr1[i][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//输出稀疏数组的形式</span></span><br><span class="line">        System.out.println();</span><br><span class="line">        System.out.println(<span class="string">&quot;得到的稀疏数组为：&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sparseArr.length; i++) &#123;</span><br><span class="line">            System.out.printf(<span class="string">&quot;%d\t%d\t%d\t\n&quot;</span>, sparseArr[i][<span class="number">0</span>], sparseArr[i][<span class="number">1</span>], sparseArr[i][<span class="number">2</span>]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//TODO 将稀疏数组保存到文件中</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//TODO 读取稀疏数组</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//将稀疏数组恢复成原始的二维数组</span></span><br><span class="line">        <span class="comment">//1、先读取稀疏数组的第一行，根据第一行的数据，创建原始的二维数组</span></span><br><span class="line">        <span class="keyword">int</span> chessArr2[][] = <span class="keyword">new</span> <span class="keyword">int</span>[sparseArr[<span class="number">0</span>][<span class="number">0</span>]][sparseArr[<span class="number">0</span>][<span class="number">1</span>]];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2、再读取稀疏数组的后几行数据，并赋值给原始的二维数组即可</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; sparseArr.length; i++) &#123;</span><br><span class="line">            chessArr2[sparseArr[i][<span class="number">0</span>]][sparseArr[i][<span class="number">1</span>]] = sparseArr[i][<span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3、输出恢复后的二维数组</span></span><br><span class="line">        System.out.println();</span><br><span class="line">        System.out.println(<span class="string">&quot;恢复后的二维数组为：&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] row : chessArr2) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> data : row) &#123;</span><br><span class="line">                System.out.printf(<span class="string">&quot;%d\t&quot;</span>, data);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="5、队列"><a href="#5、队列" class="headerlink" title="5、队列"></a>5、队列</h5><p><strong>5.1</strong> <strong>队列介绍</strong></p>
<p>（1）队列是一个有序列表，可以用数组或是链表来实现</p>
<p>（2）遵循先入先出的原则。即：先存入队列的数据，要先取出。后存入的要后取出</p>
<p>（3）示意图：（使用数组模拟队列示意图）</p>
<p><img src="https://rulerofterabithia-blog.oss-cn-hangzhou.aliyuncs.com/img/20221017101017.png"></p>
<p><strong>5.2 数组模拟队列的思路</strong></p>
<p>（1）队列本身是有序列表，若使用数组的结构来存储队列的数据，则队列数组的声明如下图，其中maxSize是该                     队列的最大容量</p>
<p>（2）因为队列的输出、输入是分别从前后端来处理因此需要两个变量front及rear分别记录队列前后端的下标，            front会随着数据输出而改变，而rear则是随着数据输入而改变，如图所示：</p>
<p><img src="https://rulerofterabithia-blog.oss-cn-hangzhou.aliyuncs.com/img/20221017101042.png"></p>
<p>（3）当我们将数据存入队列时称为”addQueue”，addQueue的处理需要有两个步骤，思路分析：</p>
<p>​          ①将尾指针往后移：rear+1，当front==rear时，队列为空</p>
<p>​          ②若尾指针rear小于队列的最大下标maxSize-1，则将数据存入rear所指的数据元素中，否则无法存入数据</p>
<p>​              当rear==maxSize-1时，队列满</p>
<p>（4）代码实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.cyk.queue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayQueueDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建一个队列</span></span><br><span class="line">        ArrayQueue queue = <span class="keyword">new</span> ArrayQueue(<span class="number">3</span>);</span><br><span class="line">        <span class="keyword">char</span> key = <span class="string">&#x27; &#x27;</span>;<span class="comment">//接收用户的输入</span></span><br><span class="line">        Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">while</span> (flag) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;s(show)：显示队列的所有数据&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;e(exit)：退出&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;a(add)：添加数据到队列&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;g(get)：获取队列的数据&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;h(head)：显示队列的头数据&quot;</span>);</span><br><span class="line">            key = scanner.next().charAt(<span class="number">0</span>);<span class="comment">//接收一个字符</span></span><br><span class="line">            <span class="keyword">switch</span> (key) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;s&#x27;</span>:</span><br><span class="line">                    queue.showQueue();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;e&#x27;</span>:</span><br><span class="line">                    scanner.close();</span><br><span class="line">                    flag = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;a&#x27;</span>:</span><br><span class="line">                    System.out.println(<span class="string">&quot;输入一个数字：&quot;</span>);</span><br><span class="line">                    <span class="keyword">int</span> value = scanner.nextInt();</span><br><span class="line">                    queue.addQueue(value);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;g&#x27;</span>:</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">int</span> res = queue.getQueue();</span><br><span class="line">                        System.out.printf(<span class="string">&quot;取出的数据是：%d\n&quot;</span>, res);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                        System.out.println(e.getMessage());</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;h&#x27;</span>:</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">int</span> res = queue.headQueue();</span><br><span class="line">                        System.out.printf(<span class="string">&quot;队列头的数据是：%d\n&quot;</span>, res);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                        System.out.println(e.getMessage());</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;程序退出&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用数组模拟队列</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ArrayQueue</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> maxSize;<span class="comment">//表示数组的最大容量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> front;<span class="comment">//队列头</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> rear;<span class="comment">//队列尾</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] arr;<span class="comment">//该数组用于存放数据，模拟队列</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建队列</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ArrayQueue</span><span class="params">(<span class="keyword">int</span> arrMaxSize)</span> </span>&#123;</span><br><span class="line">        maxSize = arrMaxSize;</span><br><span class="line">        arr = <span class="keyword">new</span> <span class="keyword">int</span>[maxSize];</span><br><span class="line">        front = -<span class="number">1</span>;<span class="comment">//指向队列头部，front是指向队列头的前一个位置</span></span><br><span class="line">        rear = -<span class="number">1</span>;<span class="comment">//指向队列尾部，指向队列尾的数据（就是队列的最后一个数据）</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断队列是否满</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isFull</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> rear == maxSize - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断队列是否为空</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> rear == front;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加数据到队列</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addQueue</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//判断队列是否满</span></span><br><span class="line">        <span class="keyword">if</span> (isFull()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;队列满，无法添加数据&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        rear++;<span class="comment">//让rear后移</span></span><br><span class="line">        arr[rear] = n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取队列的数据，出队列</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//判断队列是否为空</span></span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">            <span class="comment">//通过抛出异常处理</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;队列空，不能取数据&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        front++;<span class="comment">//front后移</span></span><br><span class="line">        <span class="keyword">return</span> arr[front];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//显示队列的所有数据</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//遍历</span></span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;队列为空&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            System.out.printf(<span class="string">&quot;arr[%d]=%d\n&quot;</span>, i, arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//显示队列的头数据，不是取出数据</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">headQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//判断是否为空</span></span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;队列为空&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr[front + <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>5.3 问题分析并优化</strong></p>
<p>（1）目前数组使用一次就不能再继续使用，没有达到服用的效果</p>
<p>（2）将这个数组使用算法，改进成一个环形队列（取模：%）</p>
<p><strong>5.4 数组模拟环形队列</strong></p>
<p>（1）对前面的数组模拟队列的优化，充分利用数组，因此将数组看作是一个环形的。（通过取模的方式来实现）</p>
<p>（2）分析说明：</p>
<p>​          ①尾索引的下一个为头索引时表示队列满，即：将队列容量空出一个作为约定，这个在做判断队列满的时候                需要注意 (rear+1) % maxSize == front（队列满）</p>
<p>​          ②rear == front（队列为空）</p>
<p>​          ③分析示意图：</p>
<p><img src="https://rulerofterabithia-blog.oss-cn-hangzhou.aliyuncs.com/img/20221017101115.png"></p>
<p>（3）思路如下：</p>
<p>​          ①front 变量的含义做一个调整：front 就指向队列的第一个元素，也就是说 arr[front] 就是队列的第一个元                   素，front 的初始值 = 0</p>
<p>​          ② rear 变量的含义做一个调整：rear 指向队列的最后一个元素的后一个位置， 因为希望空出一个空间做为                  约定，rear 的初始值 = 0</p>
<p>​          ③当队列满时，条件是 (rear + 1) % maxSize == front （队列满）</p>
<p>​          ④对队列为空的条件，rear == front （队列为空）</p>
<p>​          ⑤当我们这样分析，队列中有效的数据的个数  (rear + maxSize - front) % maxSize  // rear = 1 front = 0 </p>
<p>​          ⑥我们就可以在原来的队列上修改得到一个环形队列</p>
<p>（4）代码实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.cyk.queue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CircleArrayQueue</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建一个环形队列</span></span><br><span class="line">        CircleArray queue = <span class="keyword">new</span> CircleArray(<span class="number">4</span>);<span class="comment">//队列的有效数据最大是3</span></span><br><span class="line">        <span class="keyword">char</span> key = <span class="string">&#x27; &#x27;</span>;<span class="comment">//接收用户的输入</span></span><br><span class="line">        Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">while</span> (flag) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;s(show)：显示队列的所有数据&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;e(exit)：退出&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;a(add)：添加数据到队列&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;g(get)：获取队列的数据&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;h(head)：显示队列的头数据&quot;</span>);</span><br><span class="line">            key = scanner.next().charAt(<span class="number">0</span>);<span class="comment">//接收一个字符</span></span><br><span class="line">            <span class="keyword">switch</span> (key) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;s&#x27;</span>:</span><br><span class="line">                    queue.showQueue();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;e&#x27;</span>:</span><br><span class="line">                    scanner.close();</span><br><span class="line">                    flag = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;a&#x27;</span>:</span><br><span class="line">                    System.out.println(<span class="string">&quot;输入一个数字：&quot;</span>);</span><br><span class="line">                    <span class="keyword">int</span> value = scanner.nextInt();</span><br><span class="line">                    queue.addQueue(value);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;g&#x27;</span>:</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">int</span> res = queue.getQueue();</span><br><span class="line">                        System.out.printf(<span class="string">&quot;取出的数据是：%d\n&quot;</span>, res);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                        System.out.println(e.getMessage());</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;h&#x27;</span>:</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">int</span> res = queue.headQueue();</span><br><span class="line">                        System.out.printf(<span class="string">&quot;队列头的数据是：%d\n&quot;</span>, res);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                        System.out.println(e.getMessage());</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;程序退出&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用环形数组模拟队列</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CircleArray</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> maxSize;<span class="comment">//表示数组的最大容量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> front;<span class="comment">//队列头，front指向队列的第一个元素，也就是arr[front]，front的初始值 = 0</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> rear;<span class="comment">//队列尾，rear指向队列的最后一个元素的后一个位置，因为希望空出一个空间作为约定，rear的初始值 = 0</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] arr;<span class="comment">//该数组用于存放数据，模拟队列</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建队列</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CircleArray</span><span class="params">(<span class="keyword">int</span> arrMaxSize)</span> </span>&#123;</span><br><span class="line">        maxSize = arrMaxSize;</span><br><span class="line">        arr = <span class="keyword">new</span> <span class="keyword">int</span>[maxSize];</span><br><span class="line">        front = <span class="number">0</span>;</span><br><span class="line">        rear = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断队列是否满</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isFull</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (rear + <span class="number">1</span>) % maxSize == front;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断队列是否为空</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> rear == front;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加数据到队列</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addQueue</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//判断队列是否满</span></span><br><span class="line">        <span class="keyword">if</span> (isFull()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;队列满，无法添加数据&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//直接将数据加入</span></span><br><span class="line">        arr[rear] = n;</span><br><span class="line">        <span class="comment">//将rear后移，这里必须考虑取模</span></span><br><span class="line">        rear = (rear + <span class="number">1</span>) % maxSize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取队列的数据，出队列</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//判断队列是否为空</span></span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">            <span class="comment">//通过抛出异常处理</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;队列空，不能取数据&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//1、先把front对应的值保存到一个临时变量，直接返回的话front就没有后移的机会了</span></span><br><span class="line">        <span class="keyword">int</span> value = arr[front];</span><br><span class="line">        <span class="comment">//2、将front后移，要考虑取模</span></span><br><span class="line">        front = (front + <span class="number">1</span>) % maxSize;</span><br><span class="line">        <span class="comment">//3、将临时保存的变量返回</span></span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//显示队列的所有数据</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//遍历</span></span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;队列为空&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = front; i &lt; front + size(); i++) &#123;</span><br><span class="line">            System.out.printf(<span class="string">&quot;arr[%d]=%d\n&quot;</span>, i % maxSize, arr[i % maxSize]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//求当前队列有效数据的个数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (rear + maxSize - front) % maxSize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//显示队列的头数据，不是取出数据</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">headQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//判断是否为空</span></span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;队列为空&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr[front];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构与算法（二）链表</title>
    <url>/hexo-blog/2021/11/29/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E4%BA%8C%EF%BC%89%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h5 id="1、链表介绍"><a href="#1、链表介绍" class="headerlink" title="1、链表介绍"></a>1、链表介绍</h5><p>链表是有序的列表，它在内存中的存储结构如下：</p>
<p><img src="https://rulerofterabithia-blog.oss-cn-hangzhou.aliyuncs.com/img/20221017101213.png"></p>
<p>(1)链表是以结点的方式存储的，<strong>是链式存储</strong></p>
<p>(2)每个节点包含data域，next域：指向下一个节点</p>
<p>(3)如图：<strong>链表的每一个节点不一定是连续存储的</strong></p>
<p>(4)链表分<strong>带头结点的链表</strong>和<strong>没有头结点的链表</strong>，根据实际的需求来确定</p>
<p>单链表（带头结点）逻辑结构示意图如下：</p>
<p><img src="https://rulerofterabithia-blog.oss-cn-hangzhou.aliyuncs.com/img/20221017101245.png"></p>
<h5 id="2、单链表的应用实例"><a href="#2、单链表的应用实例" class="headerlink" title="2、单链表的应用实例"></a>2、单链表的应用实例</h5><p>使用带head头的单向链表实现水浒传英雄排行榜管理，完成对英雄人物的增删改查操作</p>
<p>(1)第一种方法在添加英雄时，直接添加到链表的尾部</p>
<p>思路分析示意图：</p>
<p><img src="https://rulerofterabithia-blog.oss-cn-hangzhou.aliyuncs.com/img/20221017101310.png"></p>
<p>(2)第二种方式在添加英雄时，根据排名将英雄插入到指定位置（如果这个排名已经存在，则添加失败，并给出提示）</p>
<p>思路分析示意图：</p>
<p><img src="https://rulerofterabithia-blog.oss-cn-hangzhou.aliyuncs.com/img/20221017101606.png"></p>
<p>(3)修改节点功能</p>
<p>思路分析：</p>
<p>①通过遍历先找到该节点</p>
<p>②temp.name = newHeroNode.name;temp.nickname = newHeroNode.nickname</p>
<p>(4)删除节点</p>
<p><img src="https://rulerofterabithia-blog.oss-cn-hangzhou.aliyuncs.com/img/20221017101637.png"></p>
<p>(5)代码实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.cyk.linkedlist;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleLinkedListDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//测试</span></span><br><span class="line">        HeroNode hero1 = <span class="keyword">new</span> HeroNode(<span class="number">1</span>, <span class="string">&quot;宋江&quot;</span>, <span class="string">&quot;及时雨&quot;</span>);</span><br><span class="line">        HeroNode hero2 = <span class="keyword">new</span> HeroNode(<span class="number">2</span>, <span class="string">&quot;卢俊义&quot;</span>, <span class="string">&quot;玉麒麟&quot;</span>);</span><br><span class="line">        HeroNode hero3 = <span class="keyword">new</span> HeroNode(<span class="number">3</span>, <span class="string">&quot;吴用&quot;</span>, <span class="string">&quot;智多星&quot;</span>);</span><br><span class="line">        HeroNode hero4 = <span class="keyword">new</span> HeroNode(<span class="number">4</span>, <span class="string">&quot;林冲&quot;</span>, <span class="string">&quot;豹子头&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建单链表</span></span><br><span class="line">        SingleLinkedList singleLinkedList = <span class="keyword">new</span> SingleLinkedList();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//向单链表中添加数据</span></span><br><span class="line">        singleLinkedList.add(hero1);</span><br><span class="line">        singleLinkedList.add(hero2);</span><br><span class="line">        singleLinkedList.add(hero3);</span><br><span class="line">        singleLinkedList.add(hero4);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//测试逆序打印单链表</span></span><br><span class="line">        System.out.println(<span class="string">&quot;逆序打印前：&quot;</span>);</span><br><span class="line">        singleLinkedList.list();</span><br><span class="line">        System.out.println(<span class="string">&quot;逆序打印后：&quot;</span>);</span><br><span class="line">        reversePrint(singleLinkedList.getHead());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//测试单链表的反转</span></span><br><span class="line"><span class="comment">//        System.out.println(&quot;反转前：&quot;);</span></span><br><span class="line"><span class="comment">//        singleLinkedList.list();</span></span><br><span class="line"><span class="comment">//        System.out.println(&quot;反转后：&quot;);</span></span><br><span class="line"><span class="comment">//        reverseList(singleLinkedList.getHead());</span></span><br><span class="line"><span class="comment">//        singleLinkedList.list();</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        //测试顺序插入</span></span><br><span class="line"><span class="comment">        singleLinkedList.addByOrder(hero3);</span></span><br><span class="line"><span class="comment">        singleLinkedList.addByOrder(hero1);</span></span><br><span class="line"><span class="comment">        singleLinkedList.addByOrder(hero4);</span></span><br><span class="line"><span class="comment">        singleLinkedList.addByOrder(hero2);</span></span><br><span class="line"><span class="comment">        singleLinkedList.addByOrder(hero3);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        //测试修改节点的代码</span></span><br><span class="line"><span class="comment">        System.out.println(&quot;修改前&quot;);</span></span><br><span class="line"><span class="comment">        singleLinkedList.list();</span></span><br><span class="line"><span class="comment">        HeroNode newHeroNode = new HeroNode(2, &quot;小卢&quot;, &quot;小麒麟&quot;);</span></span><br><span class="line"><span class="comment">        singleLinkedList.update(newHeroNode);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        //显示</span></span><br><span class="line"><span class="comment">        System.out.println(&quot;修改后&quot;);</span></span><br><span class="line"><span class="comment">        singleLinkedList.list();</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        //测试删除节点</span></span><br><span class="line"><span class="comment">        singleLinkedList.delete(1);</span></span><br><span class="line"><span class="comment">        singleLinkedList.delete(4);</span></span><br><span class="line"><span class="comment">        System.out.println(&quot;删除后&quot;);</span></span><br><span class="line"><span class="comment">        singleLinkedList.list();</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        //求单链表有效结点的个数</span></span><br><span class="line"><span class="comment">        System.out.println(&quot;有效的节点个数是：&quot; + getLength(singleLinkedList.getHead()));</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        //查找单链表中的倒数第k个节点</span></span><br><span class="line"><span class="comment">        HeroNode lastHeroNode = findLastHeroNode(singleLinkedList.getHead(), 1);</span></span><br><span class="line"><span class="comment">        System.out.println(lastHeroNode);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义SingleLinkedList管理我们的英雄</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SingleLinkedList</span> </span>&#123;</span><br><span class="line">    <span class="comment">//先初始化一个头节点，头节点不要动，不存放具体的数据</span></span><br><span class="line">    <span class="keyword">private</span> HeroNode head = <span class="keyword">new</span> HeroNode(<span class="number">0</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回头节点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> HeroNode <span class="title">getHead</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加节点到单向链表</span></span><br><span class="line">    <span class="comment">//思路，当不考虑编号的顺序时</span></span><br><span class="line">    <span class="comment">//1、找到当前链表的最后一个节点</span></span><br><span class="line">    <span class="comment">//2、将当前列表的最后一个节点的next指向新添加进来的节点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(HeroNode heroNode)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//因为head节点不能动，所以我们需要一个辅助变量temp</span></span><br><span class="line">        HeroNode temp = head;</span><br><span class="line">        <span class="comment">//遍历链表，找到最后一个节点</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="comment">//找到链表的最后</span></span><br><span class="line">            <span class="keyword">if</span> (temp.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//没有找到最后一个节点，将temp后移</span></span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//当退出while循环时，就找到了最后一个节点</span></span><br><span class="line">        <span class="comment">//将最后一个节点的next指向新的节点</span></span><br><span class="line">        temp.next = heroNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//第二种添加方式，在添加英雄时，根据英雄的编号将英雄插入到指定的位置</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addByOrder</span><span class="params">(HeroNode heroNode)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//因为头节点不能动，所以我们仍然需要一个辅助指针（临时变量temp）来帮助我们找到添加的位置</span></span><br><span class="line">        <span class="comment">//在单链表中，我们要找的temp要位于添加位置的前一个结点，否则插入不了</span></span><br><span class="line">        HeroNode temp = head;</span><br><span class="line">        <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;<span class="comment">//flag标志添加的位置是否存在，默认为false</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (temp.next == <span class="keyword">null</span>) &#123;<span class="comment">//说明temp已经在链表的最后</span></span><br><span class="line">                <span class="keyword">break</span>;<span class="comment">//可以添加</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (temp.next.no &gt; heroNode.no) &#123;<span class="comment">//位置找到，就在temp后面插入</span></span><br><span class="line">                <span class="keyword">break</span>;<span class="comment">//可以添加</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (temp.next.no == heroNode.no) &#123;<span class="comment">//编号已经存在</span></span><br><span class="line">                flag = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;<span class="comment">//不能添加</span></span><br><span class="line">            &#125;</span><br><span class="line">            temp = temp.next;<span class="comment">//将temp后移，遍历当前链表</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断flag的值，flag=false可以添加，flag=true不能添加</span></span><br><span class="line">        <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">            System.out.printf(<span class="string">&quot;准备插入的英雄的编号%d已经存在了，不能添加\n&quot;</span>, heroNode.no);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            heroNode.next = temp.next;<span class="comment">//将temp的下一个节点变为要插入的节点的下一个节点</span></span><br><span class="line">            temp.next = heroNode;<span class="comment">//从temp的后面插入到链表中</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//修改节点的信息，根据编号修改信息，编号不能改（否则相当于添加）</span></span><br><span class="line">    <span class="comment">//说明：</span></span><br><span class="line">    <span class="comment">//1、根据newHeroNode的no修改即可</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(HeroNode newHeroNode)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//判断链表是否为空</span></span><br><span class="line">        <span class="keyword">if</span> (head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;链表为空！&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//不为空，找到需要修改的节点</span></span><br><span class="line">        <span class="comment">//先定义一个辅助变量</span></span><br><span class="line">        HeroNode temp = head.next;</span><br><span class="line">        <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;<span class="comment">//表示是否找到该节点</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (temp == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;<span class="comment">//已经遍历完链表</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (temp.no == newHeroNode.no) &#123;</span><br><span class="line">                <span class="comment">//找到</span></span><br><span class="line">                flag = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//根据flag判断是否找到需要修改的节点</span></span><br><span class="line">        <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">            temp.name = newHeroNode.name;</span><br><span class="line">            temp.nickname = newHeroNode.nickname;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;<span class="comment">//没有找到</span></span><br><span class="line">            System.out.printf(<span class="string">&quot;没有找到编号为：%d的节点，不能修改&quot;</span>, newHeroNode.no);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//删除节点</span></span><br><span class="line">    <span class="comment">//思路：1、head不能动，因此我们需要一个temp辅助节点的前一个节点</span></span><br><span class="line">    <span class="comment">//2、说明我们在比较时，是temp.next.no和需要删除的节点的no比较</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(<span class="keyword">int</span> no)</span> </span>&#123;</span><br><span class="line">        HeroNode temp = head;</span><br><span class="line">        <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;<span class="comment">//标志是否找到待删除的节点</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (temp.next == <span class="keyword">null</span>) &#123;<span class="comment">//已经到链表的最后</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (temp.next.no == no) &#123;</span><br><span class="line">                <span class="comment">//找到待删除结点的前一个结点temp</span></span><br><span class="line">                flag = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            temp = temp.next;<span class="comment">//temp后移，遍历</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">            <span class="comment">//找到</span></span><br><span class="line">            temp.next = temp.next.next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.printf(<span class="string">&quot;要删除的节点：%d不存在，无法删除&quot;</span>, no);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//显示链表（通过遍历的方式）</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">list</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//判断链表是否为空</span></span><br><span class="line">        <span class="keyword">if</span> (head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;链表为空&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//链表不为空，因为头节点不能动，所以我们需要一个辅助变量temp来遍历</span></span><br><span class="line">        HeroNode temp = head.next;</span><br><span class="line">        <span class="comment">//循环遍历</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="comment">//判断是否是最后一个节点</span></span><br><span class="line">            <span class="keyword">if</span> (temp == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//不是最后一个节点，输出节点的信息</span></span><br><span class="line">            System.out.println(temp);</span><br><span class="line">            <span class="comment">//将temp后移</span></span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义HeroNode，每个HeroNode对象就是一个节点</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HeroNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> no;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> String nickname;</span><br><span class="line">    <span class="keyword">public</span> HeroNode next;<span class="comment">//指向下一个节点</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HeroNode</span><span class="params">(<span class="keyword">int</span> no, String name, String nickName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.no = no;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.nickname = nickName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//为了显示方便，重写一下toString方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;HeroNode [no=&quot;</span> + no + <span class="string">&quot;,name=&quot;</span> + name + <span class="string">&quot;,nickname = &quot;</span> + nickname + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="3、单链表面试题"><a href="#3、单链表面试题" class="headerlink" title="3、单链表面试题"></a>3、单链表面试题</h5><p>(1)求单链表中节点的个数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 获取到单链表的节点的个数（如果是带头结点的链表，需求不统计头节点）</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> head 链表的头节点</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span> 返回的就是有效节点的个数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getLength</span><span class="params">(HeroNode head)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (head.next == <span class="keyword">null</span>) &#123;<span class="comment">//空链表</span></span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> length = <span class="number">0</span>;</span><br><span class="line">	<span class="comment">//定义一个辅助变量，没有统计头节点</span></span><br><span class="line">	HeroNode current = head.next;</span><br><span class="line">	<span class="keyword">while</span> (current != <span class="keyword">null</span>) &#123;</span><br><span class="line">		length++;</span><br><span class="line">		current = current.next;<span class="comment">//遍历</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>(2)新浪面试题：查找单链表中的倒数第k个节点</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//查找单链表中的倒数第k个节点（新浪面试题）</span></span><br><span class="line"><span class="comment">//思路：</span></span><br><span class="line"><span class="comment">//1、编写一个方法，接收head节点，同时接收一个index</span></span><br><span class="line"><span class="comment">//2、index表示是倒数第index个节点</span></span><br><span class="line"><span class="comment">//3、先把链表从头到尾遍历，得到链表的总长度getLength</span></span><br><span class="line"><span class="comment">//4、得到size后，我们从链表的第一个开始遍历(size-index)个，就可以得到</span></span><br><span class="line"><span class="comment">//5、如果找到了，则返回该节点，否则返回null</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> HeroNode <span class="title">findLastHeroNode</span><span class="params">(HeroNode head, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//如果链表为空，返回null</span></span><br><span class="line">	<span class="keyword">if</span> (head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">null</span>;<span class="comment">//没有找到</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//第一次遍历得到链表的长度（节点个数）</span></span><br><span class="line">	<span class="keyword">int</span> size = getLength(head);</span><br><span class="line">	<span class="comment">//第二次遍历(size-index)位置，就是我们倒数的第k个节点</span></span><br><span class="line">	<span class="comment">//先做一个index的校验</span></span><br><span class="line">	<span class="keyword">if</span> (index &lt;= <span class="number">0</span> || index &gt; size) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//定义辅助变量，for循环定位到倒数的index</span></span><br><span class="line">	HeroNode current = head.next;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size - index; i++) &#123;</span><br><span class="line">		current = current.next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> current;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>(3)腾讯面试题：单链表的反转</p>
<p>思路分析图：</p>
<p><img src="https://rulerofterabithia-blog.oss-cn-hangzhou.aliyuncs.com/img/20221017101730.png"></p>
<p><img src="https://rulerofterabithia-blog.oss-cn-hangzhou.aliyuncs.com/img/20221017101756.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//单链表反转（腾讯面试题）</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">reverseList</span><span class="params">(HeroNode head)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//如果当前链表为空，或只有一个节点，就无需反转，直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (head.next == <span class="keyword">null</span> || head.next.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">    	<span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义一个辅助指针（变量），帮助我们遍历原来的链表</span></span><br><span class="line">    HeroNode current = head.next;</span><br><span class="line">    HeroNode next = <span class="keyword">null</span>;<span class="comment">//指向当前节点（current）的下一个节点</span></span><br><span class="line">    HeroNode reverseHead = <span class="keyword">new</span> HeroNode(<span class="number">0</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="comment">//遍历原来的链表，每遍历一个节点，就将其取出，放到新的链表reverseHead的最前端</span></span><br><span class="line">    <span class="keyword">while</span> (current != <span class="keyword">null</span>) &#123;</span><br><span class="line">    	next = current.next;<span class="comment">//先暂时保存当前节点的下一个节点，后面需要使用到</span></span><br><span class="line">    	current.next = reverseHead.next;<span class="comment">//将current的下一个节点指向reverseHead的最前端</span></span><br><span class="line">    	reverseHead.next = current;<span class="comment">//将current连接到新的链表上</span></span><br><span class="line">    	current = next;<span class="comment">//current后移</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将head.next指向reverseHead.next，实现单链表的反转</span></span><br><span class="line">    head.next = reverseHead.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>(4)百度面试题：从尾到头打印面试题</p>
<p>思路分析示意图：</p>
<p><img src="https://rulerofterabithia-blog.oss-cn-hangzhou.aliyuncs.com/img/20221017101848.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//可以利用栈这个数据结构，将各个节点压入到栈中，然后利用栈的先进后出的特点，就实现了逆序打印的效果（百度面试题）</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">reversePrint</span><span class="params">(HeroNode head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">    	<span class="keyword">return</span>;<span class="comment">//空链表，不打印</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//创建一个栈，将各个节点压入栈</span></span><br><span class="line">    Stack&lt;HeroNode&gt; stack = <span class="keyword">new</span> Stack&lt;HeroNode&gt;();</span><br><span class="line">    HeroNode current = head.next;</span><br><span class="line">    <span class="keyword">while</span> (current != <span class="keyword">null</span>) &#123;</span><br><span class="line">    	stack.push(current);</span><br><span class="line">    	current = current.next;<span class="comment">//后移</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将栈中的数据取出</span></span><br><span class="line">    <span class="keyword">while</span> (stack.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    	System.out.println(stack.pop());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="4、双向链表的操作分析和实现"><a href="#4、双向链表的操作分析和实现" class="headerlink" title="4、双向链表的操作分析和实现"></a>4、双向链表的操作分析和实现</h5><p>使用带head头的双向链表实现水浒英雄排行榜</p>
<p>一、管理单向链表的缺点分析：</p>
<p>(1)单向链表，查找的方向只能是一个方向，而双向链表可以向前或者向后查找</p>
<p>(2)单向链表不能实现自我删除，需要靠辅助节点，而双向链表，则可以实现自我删除，所以前面我们单链表删除节点时，总是找到temp，temp是待删除结点的前一个结点</p>
<p>二、双向链表如何完成遍历，添加，修改和删除：</p>
<p><img src="https://rulerofterabithia-blog.oss-cn-hangzhou.aliyuncs.com/img/20221017101920.png"></p>
<p>(1)遍历：方法和单链表一样，不同的是双链表可以向前，也可以向后查找</p>
<p>(2)添加(默认添加到双向链表的最后)：</p>
<p>①先找到双向链表的最后这个节点</p>
<p>②temp.next=newHeroNode</p>
<p>③newHeroNode.pre=temp</p>
<p>(3)修改：思路和原来的单向链表一样</p>
<p>(4)删除</p>
<p>①因为是双向链表，因此可以实现自我删除某个节点</p>
<p>②直接找到要删除的这个节点，比如temp</p>
<p>③temp.pre.next = temp.next</p>
<p>④temp.next.pre = temp.pre</p>
<p>(5)代码实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.cyk.linkedlist;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DoubleLinkedListDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//测试</span></span><br><span class="line">        HeroNode2 hero1 = <span class="keyword">new</span> HeroNode2(<span class="number">1</span>, <span class="string">&quot;宋江&quot;</span>, <span class="string">&quot;及时雨&quot;</span>);</span><br><span class="line">        HeroNode2 hero2 = <span class="keyword">new</span> HeroNode2(<span class="number">2</span>, <span class="string">&quot;卢俊义&quot;</span>, <span class="string">&quot;玉麒麟&quot;</span>);</span><br><span class="line">        HeroNode2 hero3 = <span class="keyword">new</span> HeroNode2(<span class="number">3</span>, <span class="string">&quot;吴用&quot;</span>, <span class="string">&quot;智多星&quot;</span>);</span><br><span class="line">        HeroNode2 hero4 = <span class="keyword">new</span> HeroNode2(<span class="number">4</span>, <span class="string">&quot;林冲&quot;</span>, <span class="string">&quot;豹子头&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建一个双向链表对象</span></span><br><span class="line">        DoubleLinkedList doubleLinkedList = <span class="keyword">new</span> DoubleLinkedList();</span><br><span class="line"><span class="comment">//        doubleLinkedList.add(hero1);</span></span><br><span class="line"><span class="comment">//        doubleLinkedList.add(hero2);</span></span><br><span class="line"><span class="comment">//        doubleLinkedList.add(hero3);</span></span><br><span class="line"><span class="comment">//        doubleLinkedList.add(hero4);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//测试顺序插入</span></span><br><span class="line">        doubleLinkedList.addByOrder(hero4);</span><br><span class="line">        doubleLinkedList.addByOrder(hero2);</span><br><span class="line">        doubleLinkedList.addByOrder(hero3);</span><br><span class="line">        doubleLinkedList.addByOrder(hero1);</span><br><span class="line"></span><br><span class="line">        doubleLinkedList.list();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//测试修改</span></span><br><span class="line"><span class="comment">//        HeroNode2 newHeroNode = new HeroNode2(4, &quot;公孙胜&quot;, &quot;入云龙&quot;);</span></span><br><span class="line"><span class="comment">//        doubleLinkedList.update(newHeroNode);</span></span><br><span class="line"><span class="comment">//        System.out.println(&quot;修改后：&quot;);</span></span><br><span class="line"><span class="comment">//        doubleLinkedList.list();</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//测试删除</span></span><br><span class="line"><span class="comment">//        doubleLinkedList.delete(3);</span></span><br><span class="line"><span class="comment">//        System.out.println(&quot;删除后：&quot;);</span></span><br><span class="line"><span class="comment">//        doubleLinkedList.list();</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建一个双向链表的类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DoubleLinkedList</span> </span>&#123;</span><br><span class="line">    <span class="comment">//先初始化一个头节点，头节点不要动，不存放具体的数据</span></span><br><span class="line">    <span class="keyword">private</span> HeroNode2 head = <span class="keyword">new</span> HeroNode2(<span class="number">0</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回头节点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> HeroNode2 <span class="title">getHead</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//遍历双向链表的方法</span></span><br><span class="line">    <span class="comment">//显示链表（遍历）</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">list</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//判断链表是否为空</span></span><br><span class="line">        <span class="keyword">if</span> (head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;链表为空！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//因为头节点不能动，所以我们需要一个辅助变量来遍历</span></span><br><span class="line">        HeroNode2 temp = head.next;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="comment">//判断链表是否为空</span></span><br><span class="line">            <span class="keyword">if</span> (temp == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(temp);</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加一个节点到双向链表的最后</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(HeroNode2 heroNode)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//辅助变量temp</span></span><br><span class="line">        HeroNode2 temp = head;</span><br><span class="line">        <span class="comment">//遍历链表</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (temp.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//找到了链表的最后</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//没有找到，将temp后移</span></span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//当退出while循环时，temp就指向了链表的最后</span></span><br><span class="line">        <span class="comment">//形成一个双向链表</span></span><br><span class="line">        temp.next = heroNode;</span><br><span class="line">        heroNode.pre = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//按照编号顺序添加</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addByOrder</span><span class="params">(HeroNode2 heroNode)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//因为头节点不能动，所以我们仍然需要一个辅助指针（临时变量temp）来帮助我们找到添加的位置</span></span><br><span class="line">        <span class="comment">//在单链表中，我们要找的temp要位于添加位置的前一个结点，否则插入不了</span></span><br><span class="line">        HeroNode2 temp = head;</span><br><span class="line">        <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;<span class="comment">//flag标志添加的位置是否存在，默认为false</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (temp.next == <span class="keyword">null</span>) &#123;<span class="comment">//说明temp已经在链表的最后</span></span><br><span class="line">                <span class="keyword">break</span>;<span class="comment">//可以添加</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (temp.next.no &gt; heroNode.no) &#123;<span class="comment">//位置找到，就在temp后面插入</span></span><br><span class="line">                <span class="keyword">break</span>;<span class="comment">//可以添加</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (temp.next.no == heroNode.no) &#123;<span class="comment">//编号已经存在</span></span><br><span class="line">                flag = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;<span class="comment">//不能添加</span></span><br><span class="line">            &#125;</span><br><span class="line">            temp = temp.next;<span class="comment">//将temp后移，遍历当前链表</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断flag的值，flag=false可以添加，flag=true不能添加</span></span><br><span class="line">        <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">            System.out.printf(<span class="string">&quot;准备插入的英雄的编号%d已经存在了，不能添加\n&quot;</span>, heroNode.no);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (temp.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">                temp.next = heroNode;</span><br><span class="line">                heroNode.pre = temp;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                heroNode.next = temp.next;<span class="comment">//将temp的下一个节点变为要插入的节点的下一个节点</span></span><br><span class="line">                heroNode.pre = temp;</span><br><span class="line">                temp.next = heroNode;<span class="comment">//从temp的后面插入到链表中</span></span><br><span class="line">                <span class="keyword">if</span> (heroNode.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">//避免空指针</span></span><br><span class="line">                    heroNode.next.pre = heroNode;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//修改一个结点的内容（双向链表的修改和单向链表一样）</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(HeroNode2 newHeroNode)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//判断是否为空</span></span><br><span class="line">        <span class="keyword">if</span> (head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//找到需要修改的节点，根据no编号</span></span><br><span class="line">        HeroNode2 temp = head.next;<span class="comment">//辅助变量</span></span><br><span class="line">        <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;<span class="comment">//表示是否找到</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (temp == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;<span class="comment">//遍历完</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (temp.no == newHeroNode.no) &#123;</span><br><span class="line">                flag = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//根据flag判断是否找到</span></span><br><span class="line">        <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">            temp.name = newHeroNode.name;</span><br><span class="line">            temp.nickname = newHeroNode.nickname;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.printf(<span class="string">&quot;没有找到编号为：%d的节点，不能修改&quot;</span>, newHeroNode.no);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//从双向链表中删除一个节点</span></span><br><span class="line">    <span class="comment">//说明</span></span><br><span class="line">    <span class="comment">//1、对于双向链表，我们可以直接找到要删除的这个节点</span></span><br><span class="line">    <span class="comment">//2、找到后，自我删除即可</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(<span class="keyword">int</span> no)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//判断链表是否为空</span></span><br><span class="line">        <span class="keyword">if</span> (head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;链表为空！&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        HeroNode2 temp = head.next;</span><br><span class="line">        <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;<span class="comment">//标志是否找到</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (temp == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//找到最后</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (temp.no == no) &#123;</span><br><span class="line">                flag = <span class="keyword">true</span>;<span class="comment">//找到</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//根据flag判断是否找到</span></span><br><span class="line">        <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">            temp.pre.next = temp.next;</span><br><span class="line">            <span class="comment">//如果是最后一个节点，就不需要执行下面这句话，否则出现空指针</span></span><br><span class="line">            <span class="keyword">if</span> (temp.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">                temp.next.pre = temp.pre;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.printf(<span class="string">&quot;要删除的节点%d不存在，无法删除！&quot;</span>, no);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HeroNode2</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> no;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> String nickname;</span><br><span class="line">    <span class="keyword">public</span> HeroNode2 next;<span class="comment">//指向下一个节点，默认为null</span></span><br><span class="line">    <span class="keyword">public</span> HeroNode2 pre;<span class="comment">//指向前一个结点，默认为null</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HeroNode2</span><span class="params">(<span class="keyword">int</span> no, String name, String nickName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.no = no;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.nickname = nickName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//为了显示方便，重写一下toString方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;HeroNode [no=&quot;</span> + no + <span class="string">&quot;,name=&quot;</span> + name + <span class="string">&quot;,nickname = &quot;</span> + nickname + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="5、单向环形链表应用场景"><a href="#5、单向环形链表应用场景" class="headerlink" title="5、单向环形链表应用场景"></a>5、单向环形链表应用场景</h5><p>约瑟夫环问题：</p>
<p>(1)问题描述：设编号为1，2，···，n的n个人围坐一圈，约定编号为k(1&lt;=k&lt;=n)的人从1开始报数，数到m的那个人出列，他的下一位又从1开始数，数到m的那个人又出列，依此类推，直到所有人出列为止，由此产生一个出队编号序列</p>
<p>提示：用一个不带头结点的循环链表来处理约瑟夫环问题：先构成一个有n个节点的单循环链表，然后由k节点起从1开始数，计到m时，对应节点从链表中删除，然后被删除节点的下一个节点又从1开始计数，直到最后一个节点从链表中删除算法结束</p>
<p>(2)约瑟夫环问题的示意图</p>
<p>n = 5 , 即有5个人 </p>
<p>k = 1, 从第1个人开始报数</p>
<p>m = 2, 数2下</p>
<p><img src="https://rulerofterabithia-blog.oss-cn-hangzhou.aliyuncs.com/img/20221017102002.png"></p>
<p>(3)创建环形链表的思路分析</p>
<p>构建一个单向的环形链表思路：</p>
<p>①先创建第一个节点, 让 first 指向该节点，并形成环形</p>
<p>②后面当我们每创建一个新的节点，就把该节点，加入到已有的环形链表中即可.</p>
<p>遍历环形链表：</p>
<p>①先让一个辅助指针(变量) curBoy，指向first节点</p>
<p>②然后通过一个while循环遍历 该环形链表即可 curBoy.next == first 结束</p>
<p><img src="https://rulerofterabithia-blog.oss-cn-hangzhou.aliyuncs.com/img/20221017102032.png"></p>
<p>(4)出圈的思路分析</p>
<p>①根据用户的输入，生成一个小孩出圈的顺序</p>
<p>n = 5 , 即有5个小孩</p>
<p>k = 1, 从第1个人开始报数</p>
<p>m = 2, 数2下</p>
<p>②需求创建一个辅助指针(变量) helper , 事先应该指向环形链表的最后这个节点.</p>
<p>补充： 小孩报数前，先让 first 和 helper 移动 k - 1次</p>
<p>③当小孩报数时，让first 和 helper 指针同时的移动 m - 1 次</p>
<p>④这时就可以将first 指向的小孩节点出圈</p>
<p>first = first .next </p>
<p>helper.next = first </p>
<p>原来first 指向的节点就没有任何引用，就会被回收</p>
<p>⑤出圈的顺序：2-&gt;4-&gt;1-&gt;5-&gt;3</p>
<p><img src="https://rulerofterabithia-blog.oss-cn-hangzhou.aliyuncs.com/img/20221017102101.png"></p>
<p>(5)代码实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.cyk.linkedlist;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Josephus</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//测试构建环形链表和遍历</span></span><br><span class="line">        CircleSingleLinkedList circleSingleLinkedList = <span class="keyword">new</span> CircleSingleLinkedList();</span><br><span class="line">        circleSingleLinkedList.addBoy(<span class="number">5</span>);<span class="comment">//加入5个节点</span></span><br><span class="line">        circleSingleLinkedList.showBoy();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//测试出圈</span></span><br><span class="line">        circleSingleLinkedList.countBoy(<span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建一个环形的单向链表</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CircleSingleLinkedList</span> </span>&#123;</span><br><span class="line">    <span class="comment">//创建一个first节点，当前没有编号</span></span><br><span class="line">    <span class="keyword">private</span> Boy first = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加小孩节点，构建成一个环形链表</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addBoy</span><span class="params">(<span class="keyword">int</span> nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums &lt; <span class="number">1</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;输入的数据不正确！&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Boy currentBoy = <span class="keyword">null</span>;<span class="comment">//辅助指针，帮助构建环形链表</span></span><br><span class="line">        <span class="comment">//使用for循环创建环形链表</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= nums; i++) &#123;</span><br><span class="line">            <span class="comment">//根据编号，创建小孩节点</span></span><br><span class="line">            Boy boy = <span class="keyword">new</span> Boy(i);</span><br><span class="line">            <span class="comment">//如果是第一个小孩</span></span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">1</span>) &#123;</span><br><span class="line">                first = boy;</span><br><span class="line">                first.setNext(first);<span class="comment">//构成环</span></span><br><span class="line">                currentBoy = first;<span class="comment">//让currentBoy指向第一个小孩</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                currentBoy.setNext(boy);</span><br><span class="line">                boy.setNext(first);</span><br><span class="line">                currentBoy = boy;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//遍历当前的环形链表</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showBoy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//判断链表是否为空</span></span><br><span class="line">        <span class="keyword">if</span> (first == <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;链表为空！&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//因为first不能动，所以我们仍然需要一个辅助指针来遍历</span></span><br><span class="line">        Boy currentBoy = first;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            System.out.printf(<span class="string">&quot;小孩的编号为：%d\n&quot;</span>, currentBoy.getNo());</span><br><span class="line">            <span class="keyword">if</span> (currentBoy.getNext() == first) &#123;</span><br><span class="line">                <span class="comment">//说明已经遍历完</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            currentBoy = currentBoy.getNext();<span class="comment">//后移</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据用户的输入，计算小孩出圈的顺序</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> startNo  表示从第几个小孩开始数数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> countNum 表示数几下</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> nums     表示最初有多少个小孩在圈中</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">countBoy</span><span class="params">(<span class="keyword">int</span> startNo, <span class="keyword">int</span> countNum, <span class="keyword">int</span> nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//先对数据进行校验</span></span><br><span class="line">        <span class="keyword">if</span> (startNo &lt; <span class="number">1</span> || first == <span class="keyword">null</span> || startNo &gt; nums) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;输入的数据有误！&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//创建一个辅助指针，帮助完成小孩出拳</span></span><br><span class="line">        Boy helper = first;</span><br><span class="line">        <span class="comment">//helper事先应该指向环形链表的最后一个节点</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (helper.getNext() == first) &#123;<span class="comment">//说明helper指向最后的节点</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            helper = helper.getNext();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//小孩报数前，先让first和helper移动 startNo-1 次</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; startNo - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            first = first.getNext();</span><br><span class="line">            helper = helper.getNext();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//当小孩报数时，让first和helper同时移动 countNum-1 次，然后出圈</span></span><br><span class="line">        <span class="comment">//循环操作，直到圈中只有一个节点</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (helper == first) &#123;</span><br><span class="line">                <span class="comment">//说明圈中只有一个节点</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//让first和helper同时移动 countNum-1 次</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; countNum - <span class="number">1</span>; i++) &#123;</span><br><span class="line">                first = first.getNext();</span><br><span class="line">                helper = helper.getNext();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//这时first指向的节点，就是要出圈的节点</span></span><br><span class="line">            System.out.printf(<span class="string">&quot;小孩%d出圈\n&quot;</span>, first.getNo());</span><br><span class="line">            <span class="comment">//将first指向的节点出圈</span></span><br><span class="line">            first = first.getNext();</span><br><span class="line">            helper.setNext(first);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.printf(<span class="string">&quot;最后留在圈中的小孩编号为%d&quot;</span>, helper.getNo());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建一个Boy类，表示一个节点</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Boy</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> no;<span class="comment">//编号</span></span><br><span class="line">    <span class="keyword">private</span> Boy next;<span class="comment">//指向下一个节点，默认为null</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Boy</span><span class="params">(<span class="keyword">int</span> no)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.no = no;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> no;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNo</span><span class="params">(<span class="keyword">int</span> no)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.no = no;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Boy <span class="title">getNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNext</span><span class="params">(Boy next)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构与算法（三）栈</title>
    <url>/hexo-blog/2021/12/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E4%B8%89%EF%BC%89%E6%A0%88/</url>
    <content><![CDATA[<h5 id="1、栈的介绍"><a href="#1、栈的介绍" class="headerlink" title="1、栈的介绍"></a>1、栈的介绍</h5><p>(1)栈(stack)是一个先入后出(FILO-First In Last Out)的有序列表</p>
<p>(2)栈是限制线性表中元素的插入和删除只能在线性表的同一端进行的一种特殊线性表，允许插入和删除的一端为变化的一端，称为栈顶(Top)，另一端为固定的一端，称为栈底(bottom)                   </p>
<p>(3)根据栈的定义可知，最先放入栈中的元素在栈底，最后放入的元素在栈顶，而删除元素正好相反，最后放入的元素最先删除，最先放入的元素最后删除</p>
<p>(4)图解的方式说明入栈(push)和出栈(pop)</p>
<p><img src="https://rulerofterabithia-blog.oss-cn-hangzhou.aliyuncs.com/img/20221017102452.png"></p>
<p><img src="https://rulerofterabithia-blog.oss-cn-hangzhou.aliyuncs.com/img/20221017102619.png"></p>
<h5 id="2、栈的出栈和入栈"><a href="#2、栈的出栈和入栈" class="headerlink" title="2、栈的出栈和入栈"></a>2、栈的出栈和入栈</h5><p>(1)用数组模拟栈的使用，由于栈是一种有序列表，当然可以使用数组的结构来存储栈的数据内容，下面我们就用数组模拟栈的出栈，入栈等操作</p>
<p>(2)思路分析</p>
<p>①定义一个 top 来表示栈顶，初始化 为 -1</p>
<p>②入栈的操作，当有数据加入到栈时， top++; stack[top] = data;</p>
<p>③出栈的操作， int value = stack[top]; top–, return value</p>
<p><img src="https://rulerofterabithia-blog.oss-cn-hangzhou.aliyuncs.com/img/20221017102804.png"></p>
<p>(3)代码实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.cyk.stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayStackDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//测试</span></span><br><span class="line">        ArrayStack stack = <span class="keyword">new</span> ArrayStack(<span class="number">4</span>);</span><br><span class="line">        String key = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">boolean</span> loop = <span class="keyword">true</span>;<span class="comment">//控制是否退出菜单</span></span><br><span class="line">        Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">while</span> (loop) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;show：表示显示栈&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;exit：退出程序&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;push：表示添加数据到栈（入栈）&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;pop：表示从栈取出数据（出栈）&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;请输入你的选择：&quot;</span>);</span><br><span class="line">            key = scanner.next();</span><br><span class="line">            <span class="keyword">switch</span> (key) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;show&quot;</span>:</span><br><span class="line">                    stack.list();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;push&quot;</span>:</span><br><span class="line">                    System.out.println(<span class="string">&quot;请输入一个数：&quot;</span>);</span><br><span class="line">                    <span class="keyword">int</span> value = scanner.nextInt();</span><br><span class="line">                    stack.push(value);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;pop&quot;</span>:</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">int</span> result = stack.pop();</span><br><span class="line">                        System.out.printf(<span class="string">&quot;出栈的数据：%d\n&quot;</span>, result);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                        System.out.println(e.getMessage());</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;exit&quot;</span>:</span><br><span class="line">                    scanner.close();</span><br><span class="line">                    loop = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;程序退出！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义一个ArrayStack类表示栈结构</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ArrayStack</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> maxSize;<span class="comment">//栈的大小</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] stack;<span class="comment">//数组模拟栈，栈的数据存放在数组中</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> top = -<span class="number">1</span>;<span class="comment">//表示栈顶，初始化为-1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ArrayStack</span><span class="params">(<span class="keyword">int</span> maxSize)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.maxSize = maxSize;</span><br><span class="line">        stack = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="keyword">this</span>.maxSize];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断栈满</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Boolean <span class="title">isFull</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> top == maxSize - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断栈空</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Boolean <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> top == -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//入栈</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isFull()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;栈满！&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        top++;</span><br><span class="line">        stack[top] = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//出栈</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;栈空！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> value = stack[top];</span><br><span class="line">        top--;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//遍历栈，遍历时，需要从栈顶开始显示</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">list</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;栈空，没有数据！&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//需要从栈顶开始显示</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = top; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            System.out.printf(<span class="string">&quot;stack[%d]=%d\n&quot;</span>, i, stack[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="3、栈实现综合计算器-中缀表达式"><a href="#3、栈实现综合计算器-中缀表达式" class="headerlink" title="3、栈实现综合计算器(中缀表达式)"></a>3、栈实现综合计算器(中缀表达式)</h5><p>(1)使用栈来实现综合计算器</p>
<p><img src="https://rulerofterabithia-blog.oss-cn-hangzhou.aliyuncs.com/img/20221017102938.png"></p>
<p>(2)思路分析</p>
<p>使用栈完成表达式的计算思路</p>
<p>①通过一个 index 值(索引)，来遍历我们的表达式</p>
<p>②如果我们发现是一个数字，就直接入数栈</p>
<p>③如果发现扫描到是一个符号,  就分如下情况</p>
<p>​    3.1 如果发现当前的符号栈为空，就直接入栈</p>
<p>​    3.2 如果符号栈有操作符，就进行比较，如果当前的操作符的优先级小于或者等于栈中的操作符， 就需要从数栈中pop出两个数，再从符号栈中pop出一个符号，进行运算，将得到结果入数栈，然后将当前的操作符入符号栈， 如果当前的操作符的优先级大于栈中的操作符， 就直接入符号栈</p>
<p>④当表达式扫描完毕，就顺序的从数栈和符号栈中pop出相应的数和符号，并运行</p>
<p>⑤最后在数栈只有一个数字，就是表达式的结果</p>
<p><img src="https://rulerofterabithia-blog.oss-cn-hangzhou.aliyuncs.com/img/20221017103005.png"></p>
<p>(3)代码实现：先实现一位数的运算，再扩展到多位数的运算</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.cyk.stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Calculator</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//测试</span></span><br><span class="line">        String exp = <span class="string">&quot;7*2*2-5+1-5+3-4&quot;</span>;</span><br><span class="line">        <span class="comment">//创建两个栈，一个是数字栈，一个是符号栈</span></span><br><span class="line">        ArrayStack2 numStack = <span class="keyword">new</span> ArrayStack2(<span class="number">10</span>);</span><br><span class="line">        ArrayStack2 operationStack = <span class="keyword">new</span> ArrayStack2(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//定义需要的相关变量</span></span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;<span class="comment">//用于扫描</span></span><br><span class="line">        <span class="keyword">int</span> num1 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> num2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> operation = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">char</span> ch = <span class="string">&#x27; &#x27;</span>;<span class="comment">//将每次扫描得到的char保存到ch中</span></span><br><span class="line">        String keepNum = <span class="string">&quot;&quot;</span>;<span class="comment">//用于拼接多位数</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//循环扫描exp</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            ch = exp.substring(index, index + <span class="number">1</span>).charAt(<span class="number">0</span>);</span><br><span class="line">            <span class="comment">//判断ch是什么，然后做相应的处理</span></span><br><span class="line">            <span class="keyword">if</span> (operationStack.isOperation(ch)) &#123;<span class="comment">//是运算符</span></span><br><span class="line">                <span class="comment">//判断当前的符号栈是否为空</span></span><br><span class="line">                <span class="keyword">if</span> (!operationStack.isEmpty()) &#123;</span><br><span class="line">                    <span class="comment">//如果符号栈有操作符，就进行比较，如果当前的操作符的优先级小于或者等于栈中的操作符，就需要从数栈中pop出两个数</span></span><br><span class="line">                    <span class="comment">//再从符号栈中pop出一个符号，进行运算，将得到的结果入数字栈，然后将当前的操作入符号栈</span></span><br><span class="line">                    <span class="keyword">if</span> (operationStack.priority(ch) &lt;= operationStack.priority(operationStack.peek())) &#123;</span><br><span class="line">                        num1 = numStack.pop();</span><br><span class="line">                        num2 = numStack.pop();</span><br><span class="line">                        operation = operationStack.pop();</span><br><span class="line">                        result = numStack.calculate(num1, num2, operation);</span><br><span class="line">                        <span class="comment">//把运算的结果入数字栈</span></span><br><span class="line">                        numStack.push(result);</span><br><span class="line">                        <span class="comment">//把当前的运算符入符号栈</span></span><br><span class="line">                        operationStack.push(ch);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">//如果当前运算符的优先级大于战中的操作符，直接入栈</span></span><br><span class="line">                        operationStack.push(ch);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//如果为空，直接入符号栈</span></span><br><span class="line">                    operationStack.push(ch);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;<span class="comment">//是数字，直接入数字栈</span></span><br><span class="line">                <span class="comment">//numStack.push(ch - 48);</span></span><br><span class="line">                <span class="comment">//分析思路</span></span><br><span class="line">                <span class="comment">//1.当处理多位数时，不能发现是一个数就立即入栈，因为它可能时多位数</span></span><br><span class="line">                <span class="comment">//2.在处理数时，需要向exp的表达式的index后再看一位，如果是数就进行扫描，如果是符号才入栈</span></span><br><span class="line">                <span class="comment">//3.因此我们需要定义一个变量字符串，用于拼接</span></span><br><span class="line">                keepNum += ch;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//如果ch是exp的最后一位，则直接入栈</span></span><br><span class="line">                <span class="keyword">if</span> (index == exp.length() - <span class="number">1</span>) &#123;</span><br><span class="line">                    numStack.push(Integer.parseInt(keepNum));</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//判断下一个字符是不是数字，如果是数字，则继续扫描</span></span><br><span class="line">                    <span class="keyword">if</span> (operationStack.isOperation(exp.substring(index + <span class="number">1</span>, index + <span class="number">2</span>).charAt(<span class="number">0</span>))) &#123;</span><br><span class="line">                        <span class="comment">//后一位是运算符，入栈</span></span><br><span class="line">                        numStack.push(Integer.parseInt(keepNum));</span><br><span class="line">                        <span class="comment">//将keepNum清空，非常重要！！！！！！</span></span><br><span class="line">                        keepNum = <span class="string">&quot;&quot;</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//让index + 1 ，判断是否扫描到exp的最后</span></span><br><span class="line">            index++;</span><br><span class="line">            <span class="keyword">if</span> (index &gt;= exp.length()) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//当表达式扫描完毕，就顺序地从数字栈和符号栈中pop出相应的数和符号，并运行</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="comment">//如果符号栈为空，则计算到最后的结果，数栈中只有一个数字（就是结果）</span></span><br><span class="line">            <span class="keyword">if</span> (operationStack.isEmpty()) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            num1 = numStack.pop();</span><br><span class="line">            num2 = numStack.pop();</span><br><span class="line">            operation = operationStack.pop();</span><br><span class="line">            result = numStack.calculate(num1, num2, operation);</span><br><span class="line">            <span class="comment">//把运算的结果入数字栈</span></span><br><span class="line">            numStack.push(result);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将数栈的最后一个数pop</span></span><br><span class="line">        System.out.printf(<span class="string">&quot;表达式为：%s = %d&quot;</span>, exp, numStack.pop());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义一个ArrayStack2类表示栈结构，需要扩展功能</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ArrayStack2</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> maxSize;<span class="comment">//栈的大小</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] stack;<span class="comment">//数组模拟栈，栈的数据存放在数组中</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> top = -<span class="number">1</span>;<span class="comment">//表示栈顶，初始化为-1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ArrayStack2</span><span class="params">(<span class="keyword">int</span> maxSize)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.maxSize = maxSize;</span><br><span class="line">        stack = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="keyword">this</span>.maxSize];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断栈满</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Boolean <span class="title">isFull</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> top == maxSize - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断栈空</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Boolean <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> top == -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//入栈</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isFull()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;栈满！&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        top++;</span><br><span class="line">        stack[top] = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//出栈</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;栈空！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> value = stack[top];</span><br><span class="line">        top--;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//遍历栈，遍历时，需要从栈顶开始显示</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">list</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;栈空，没有数据！&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//需要从栈顶开始显示</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = top; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            System.out.printf(<span class="string">&quot;stack[%d]=%d\n&quot;</span>, i, stack[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回运算符的优先级，优先级使用数字表示，数字越大，优先级越高</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">priority</span><span class="params">(<span class="keyword">int</span> operation)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (operation == <span class="string">&#x27;*&#x27;</span> || operation == <span class="string">&#x27;/&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (operation == <span class="string">&#x27;+&#x27;</span> || operation == <span class="string">&#x27;-&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断是不是一个运算符</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Boolean <span class="title">isOperation</span><span class="params">(<span class="keyword">char</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value == <span class="string">&#x27;+&#x27;</span> || value == <span class="string">&#x27;-&#x27;</span> || value == <span class="string">&#x27;*&#x27;</span> || value == <span class="string">&#x27;/&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//计算方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">calculate</span><span class="params">(<span class="keyword">int</span> num1, <span class="keyword">int</span> num2, <span class="keyword">int</span> operation)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;<span class="comment">//用于存放计算结果</span></span><br><span class="line">        <span class="keyword">switch</span> (operation) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">                result = num1 + num2;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">                result = num2 - num1;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>:</span><br><span class="line">                result = num1 * num2;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;/&#x27;</span>:</span><br><span class="line">                result = num2 / num1;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获得当前栈顶的数据，不是出栈</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> stack[top];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="4、中缀表达式转为后缀表达式"><a href="#4、中缀表达式转为后缀表达式" class="headerlink" title="4、中缀表达式转为后缀表达式"></a>4、中缀表达式转为后缀表达式</h5><p>1、具体步骤如下</p>
<p>(1)初始化两个栈：运算符栈s1和存储中间结果的栈s2</p>
<p>(2)从左至右扫描中缀表达式</p>
<p>(3)遇到操作数时，将其压入s2</p>
<p>(4)遇到运算符时，比较其与s1栈顶运算符的优先级：</p>
<p>​    4.1如果s1为空，或栈顶运算符为左括号 “(” ，则直接将此运算符入s1栈</p>
<p>​    4.2否则，若优先级比栈顶运算符的高，也将运算符压入s1栈</p>
<p>​    4.3否则，将s1栈顶的运算符弹出并压入到s2中，再次转到4.1的步骤，与s1中新的栈顶运算符相比较</p>
<p>(5)遇到括号时：</p>
<p>​    5.1如果是左括号 “(” ，则直接压入s1</p>
<p>​    5.2如果是右括号 “)” ，则依次弹出s1栈顶的运算符，并压入s2，直到遇到左括号为止，此时将这一对括号丢弃</p>
<p>(6)重复步骤(2)至(5)，直到表达式的最右边</p>
<p>(7)将s1中剩余的运算符依次弹出并压入s2</p>
<p>(8)依次弹出s2中的元素并输出，结果的逆序即为中缀表达式对应的后缀表达式</p>
<p>2、举例说明</p>
<p>将中缀表达式：1+((2+3)*4)-5 转换为后缀表达式的过程如下</p>
<p><img src="https://rulerofterabithia-blog.oss-cn-hangzhou.aliyuncs.com/img/20221017103901.png"></p>
<p>因此结果为：1 2 3 + 4 * + 5 -</p>
<p>3、代码实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//将中缀表达式转成对应的List</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">toInfixExpList</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//定义一个List，存放中缀表达式对应的内容</span></span><br><span class="line">    List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;<span class="comment">//这是一个指针，用于遍历中缀表达式字符串</span></span><br><span class="line">    String str;<span class="comment">//对多位数的拼接</span></span><br><span class="line">    <span class="keyword">char</span> c;<span class="comment">//每遍历到一个字符，就放入到c中</span></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="comment">//如果c是一个非数字，需要加入到list中</span></span><br><span class="line">    <span class="keyword">if</span> ((c = s.charAt(i)) &lt; <span class="number">48</span> || (c = s.charAt(i)) &gt; <span class="number">57</span>) &#123;</span><br><span class="line">    	list.add(<span class="string">&quot;&quot;</span> + c);</span><br><span class="line">    	i++;<span class="comment">//i后移</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;<span class="comment">//如果是一个数（需要考虑多位数）</span></span><br><span class="line">    	str = <span class="string">&quot;&quot;</span>;<span class="comment">//先将str置为空</span></span><br><span class="line">    	<span class="keyword">while</span> (i &lt; s.length() &amp;&amp; (c = s.charAt(i)) &gt;= <span class="number">48</span> &amp;&amp; (c = s.charAt(i)) &lt;= <span class="number">57</span>) &#123;</span><br><span class="line">    		str += c;<span class="comment">//拼接</span></span><br><span class="line">    		i++;</span><br><span class="line">    	&#125;</span><br><span class="line">    	list.add(str);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">while</span> (i &lt; s.length());</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将中缀表达式对应的list转换成后缀表达式对应的list</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">parseSuffixExpList</span><span class="params">(List&lt;String&gt; ls)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//定义两个栈</span></span><br><span class="line">    Stack&lt;String&gt; s1 = <span class="keyword">new</span> Stack&lt;&gt;();<span class="comment">//符号栈</span></span><br><span class="line">    <span class="comment">//Stack&lt;String&gt; s2 = new Stack&lt;String&gt;();//储存中间结果的栈s2</span></span><br><span class="line">    <span class="comment">//说明：因为s2这个栈，在整个转换过程中，没有pop操作，而且后面我们还需要逆序输出</span></span><br><span class="line">    <span class="comment">//因此比较麻烦，这里我们就不用Stack&lt;String&gt;，而是直接使用List&lt;String&gt; s2</span></span><br><span class="line">    ArrayList&lt;String&gt; s2 = <span class="keyword">new</span> ArrayList&lt;&gt;();<span class="comment">//储存中间结果的list s2</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//遍历ls</span></span><br><span class="line">    <span class="keyword">for</span> (String item : ls) &#123;</span><br><span class="line">    <span class="comment">//如果是一个数，加入到s2</span></span><br><span class="line">    <span class="keyword">if</span> (item.matches(<span class="string">&quot;\\d+&quot;</span>)) &#123;</span><br><span class="line">    	s2.add(item);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (item.equals(<span class="string">&quot;(&quot;</span>)) &#123;</span><br><span class="line">    	<span class="comment">//如果是左括号</span></span><br><span class="line">    	s1.push(item);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (item.equals(<span class="string">&quot;)&quot;</span>)) &#123;</span><br><span class="line">    	<span class="comment">//如果是右括号，则依次弹出s1栈顶的运算符，直到遇到左括号为止，此时将这一对括号丢弃</span></span><br><span class="line">    	<span class="keyword">while</span> (!s1.peek().equals(<span class="string">&quot;(&quot;</span>)) &#123;</span><br><span class="line">    		s2.add(s1.pop());</span><br><span class="line">    	&#125;</span><br><span class="line">    	s1.pop();<span class="comment">//将左括号弹出s1栈，消除小括号</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    	<span class="comment">//当item的优先级小于等于s1栈顶运算符，将s1栈顶的运算符弹出并加入到s2中，再次转到（4.1）步骤与s1中新的栈顶运算符相比较</span></span><br><span class="line">    	<span class="keyword">while</span> (s1.size() != <span class="number">0</span> &amp;&amp; Operation.getValue(s1.peek()) &gt;= Operation.getValue(item)) &#123;</span><br><span class="line">    		s2.add(s1.pop());</span><br><span class="line">    	&#125;</span><br><span class="line">    	<span class="comment">//还需要将item压入栈</span></span><br><span class="line">    	s1.push(item);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将s1中剩余的运算符依次弹出并加入到s2中</span></span><br><span class="line">    <span class="keyword">while</span> (s1.size() != <span class="number">0</span>) &#123;</span><br><span class="line">    	s2.add(s1.pop());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s2;<span class="comment">//因为是存放到List，因此按顺序输出就是对应的后缀表达式对应的List</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="5、逆波兰计算器-非完整版"><a href="#5、逆波兰计算器-非完整版" class="headerlink" title="5、逆波兰计算器(非完整版)"></a>5、逆波兰计算器(非完整版)</h5><p>1、要求</p>
<p>(1)输入一个逆波兰表达式(后缀表达式)，使用栈(stack)，计算其结果</p>
<p>(2)支持小括号和多位数整数，因为这里我们主要讲的是数据结构，因此对计算器进行简化，只支持对整数的计算</p>
<p>2、思路分析</p>
<p>例如：(3+4)*5-6对应的后缀表达式就是 3 4 + 5 * 6 -</p>
<p>(1)从左到右扫描，将3和4压入堆栈</p>
<p>(2)遇到 “+” 运算符，因此弹出4和3(4为栈顶元素，3为次顶元素)，计算出3+4的值，得7，再将7入栈</p>
<p>(3)将5入栈</p>
<p>(4)接下来是 “*” 运算符，因此弹出5和7，计算出7 * 5 = 35，将35入栈</p>
<p>(5)将6入栈</p>
<p>(6)最后是 “-“ 运算符，计算出35 - 6的值，即29，由此得出最终的结果</p>
<p>3、代码实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.cyk.stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PolandNotation</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//完成将一个中缀表达式转成后缀表达式的功能</span></span><br><span class="line">        <span class="comment">//说明：</span></span><br><span class="line">        <span class="comment">//1.1+((2+3)*4)-5转成 1 2 3 + 4 * + 5 -</span></span><br><span class="line">        <span class="comment">//2.因为直接对str进行操作，不方便，因此先将&quot;1+((2+3)*4)-5&quot; =&gt;中缀表达式对应的List</span></span><br><span class="line">        <span class="comment">//即1+((2+3)*4)-5 =&gt; ArrayList [1,+,(,(,2,+,3,),*,4,),-,5]</span></span><br><span class="line">        <span class="comment">//3.将中缀表达式对应的list转换成后缀表达式对应的list</span></span><br><span class="line">        <span class="comment">//即 ArrayList [1,+,(,(,2,+,3,),*,4,),-,5]  =&gt; ArrayList [1,2,3,+,4,*,+,5,–]</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//测试</span></span><br><span class="line">        List&lt;String&gt; infixExp = toInfixExpList(<span class="string">&quot;1+((2+3)*4)-5&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;中缀表达式对应的List：&quot;</span> + infixExp);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//测试中缀表达式转换成后缀表达式</span></span><br><span class="line">        List&lt;String&gt; suffixExpList = parseSuffixExpList(infixExp);</span><br><span class="line">        System.out.println(<span class="string">&quot;后缀表达式对应的List：&quot;</span> + suffixExpList);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//测试计算的结果</span></span><br><span class="line">        System.out.printf(<span class="string">&quot;Exp = %d&quot;</span>, calculate(suffixExpList));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//先定义一个逆波兰表达式</span></span><br><span class="line">        <span class="comment">//(3+4)×5-6=&gt;3 4 + 5 * 6 -</span></span><br><span class="line"><span class="comment">//        String suffixExp = &quot;4 5 * 8 - 60 + 8 2 / +&quot;;</span></span><br><span class="line">        <span class="comment">//思路：</span></span><br><span class="line">        <span class="comment">//1、先将&quot;3 4 + 5 x 6 -&quot;放到ArrayList中</span></span><br><span class="line">        <span class="comment">//2、将ArrayList传递给一个方法，遍历ArrayList配合栈完成计算</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//        List&lt;String&gt; listString = getListString(suffixExp);</span></span><br><span class="line"><span class="comment">//        System.out.println(listString);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//测试</span></span><br><span class="line"><span class="comment">//        int result = calculate(listString);</span></span><br><span class="line"><span class="comment">//        System.out.println(&quot;计算的结果是：&quot; + result);</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将中缀表达式对应的list转换成后缀表达式对应的list</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">parseSuffixExpList</span><span class="params">(List&lt;String&gt; ls)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//定义两个栈</span></span><br><span class="line">        Stack&lt;String&gt; s1 = <span class="keyword">new</span> Stack&lt;&gt;();<span class="comment">//符号栈</span></span><br><span class="line">        <span class="comment">//Stack&lt;String&gt; s2 = new Stack&lt;String&gt;();//储存中间结果的栈s2</span></span><br><span class="line">        <span class="comment">//说明：因为s2这个栈，在整个转换过程中，没有pop操作，而且后面我们还需要逆序输出</span></span><br><span class="line">        <span class="comment">//因此比较麻烦，这里我们就不用Stack&lt;String&gt;，而是直接使用List&lt;String&gt; s2</span></span><br><span class="line">        ArrayList&lt;String&gt; s2 = <span class="keyword">new</span> ArrayList&lt;&gt;();<span class="comment">//储存中间结果的list s2</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//遍历ls</span></span><br><span class="line">        <span class="keyword">for</span> (String item : ls) &#123;</span><br><span class="line">            <span class="comment">//如果是一个数，加入到s2</span></span><br><span class="line">            <span class="keyword">if</span> (item.matches(<span class="string">&quot;\\d+&quot;</span>)) &#123;</span><br><span class="line">                s2.add(item);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (item.equals(<span class="string">&quot;(&quot;</span>)) &#123;</span><br><span class="line">                <span class="comment">//如果是左括号</span></span><br><span class="line">                s1.push(item);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (item.equals(<span class="string">&quot;)&quot;</span>)) &#123;</span><br><span class="line">                <span class="comment">//如果是右括号，则依次弹出s1栈顶的运算符，直到遇到左括号为止，此时将这一对括号丢弃</span></span><br><span class="line">                <span class="keyword">while</span> (!s1.peek().equals(<span class="string">&quot;(&quot;</span>)) &#123;</span><br><span class="line">                    s2.add(s1.pop());</span><br><span class="line">                &#125;</span><br><span class="line">                s1.pop();<span class="comment">//将左括号弹出s1栈，消除小括号</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//当item的优先级小于等于s1栈顶运算符，将s1栈顶的运算符弹出并加入到s2中，再次转到（4.1）步骤与s1中新的栈顶运算符相比较</span></span><br><span class="line">                <span class="keyword">while</span> (s1.size() != <span class="number">0</span> &amp;&amp; Operation.getValue(s1.peek()) &gt;= Operation.getValue(item)) &#123;</span><br><span class="line">                    s2.add(s1.pop());</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//还需要将item压入栈</span></span><br><span class="line">                s1.push(item);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将s1中剩余的运算符依次弹出并加入到s2中</span></span><br><span class="line">        <span class="keyword">while</span> (s1.size() != <span class="number">0</span>) &#123;</span><br><span class="line">            s2.add(s1.pop());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s2;<span class="comment">//因为是存放到List，因此按顺序输出就是对应的后缀表达式对应的List</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将中缀表达式转成对应的List</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">toInfixExpList</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//定义一个List，存放中缀表达式对应的内容</span></span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;<span class="comment">//这是一个指针，用于遍历中缀表达式字符串</span></span><br><span class="line">        String str;<span class="comment">//对多位数的拼接</span></span><br><span class="line">        <span class="keyword">char</span> c;<span class="comment">//每遍历到一个字符，就放入到c中</span></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="comment">//如果c是一个非数字，需要加入到list中</span></span><br><span class="line">            <span class="keyword">if</span> ((c = s.charAt(i)) &lt; <span class="number">48</span> || (c = s.charAt(i)) &gt; <span class="number">57</span>) &#123;</span><br><span class="line">                list.add(<span class="string">&quot;&quot;</span> + c);</span><br><span class="line">                i++;<span class="comment">//i后移</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;<span class="comment">//如果是一个数（需要考虑多位数）</span></span><br><span class="line">                str = <span class="string">&quot;&quot;</span>;<span class="comment">//先将str置为空</span></span><br><span class="line">                <span class="keyword">while</span> (i &lt; s.length() &amp;&amp; (c = s.charAt(i)) &gt;= <span class="number">48</span> &amp;&amp; (c = s.charAt(i)) &lt;= <span class="number">57</span>) &#123;</span><br><span class="line">                    str += c;<span class="comment">//拼接</span></span><br><span class="line">                    i++;</span><br><span class="line">                &#125;</span><br><span class="line">                list.add(str);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">while</span> (i &lt; s.length());</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将一个逆波兰表达式，依次将数据和运算符放入到ArrayList中</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">getListString</span><span class="params">(String suffixExp)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//将suffixExp分割</span></span><br><span class="line">        String[] split = suffixExp.split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String element : split) &#123;</span><br><span class="line">            list.add(element);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//完成对逆波兰表达式的运算</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    （1）从左至右扫描，将3和4压入堆栈</span></span><br><span class="line"><span class="comment">    （2）遇到+运算符，因此弹出4和3（4为栈顶元素，3为次顶元素），计算出3+4的值，得7，再将7入栈</span></span><br><span class="line"><span class="comment">    （3）将5入栈</span></span><br><span class="line"><span class="comment">    （4）接下来是×运算符，因此弹出5和7，计算出7×5=35，将35入栈</span></span><br><span class="line"><span class="comment">    （5）将6入栈</span></span><br><span class="line"><span class="comment">    （6）最后是-运算符，计算出35-6的值，即29，由此得出最终的结果</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">calculate</span><span class="params">(List&lt;String&gt; list)</span> </span>&#123;</span><br><span class="line">        Stack&lt;String&gt; stack = <span class="keyword">new</span> Stack&lt;String&gt;();</span><br><span class="line">        <span class="comment">//遍历list</span></span><br><span class="line">        <span class="keyword">for</span> (String item : list) &#123;</span><br><span class="line">            <span class="comment">//这里使用正则表达式来取出数</span></span><br><span class="line">            <span class="keyword">if</span> (item.matches(<span class="string">&quot;\\d+&quot;</span>)) &#123;<span class="comment">//匹配的是多位数</span></span><br><span class="line">                <span class="comment">//入栈</span></span><br><span class="line">                stack.add(item);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//pop出两个数，并计算，再入栈</span></span><br><span class="line">                <span class="keyword">int</span> num2 = Integer.parseInt(stack.pop());</span><br><span class="line">                <span class="keyword">int</span> num1 = Integer.parseInt(stack.pop());</span><br><span class="line">                <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span> (item.equals(<span class="string">&quot;+&quot;</span>)) &#123;</span><br><span class="line">                    result = num1 + num2;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (item.equals(<span class="string">&quot;-&quot;</span>)) &#123;</span><br><span class="line">                    result = num1 - num2;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (item.equals(<span class="string">&quot;*&quot;</span>)) &#123;</span><br><span class="line">                    result = num1 * num2;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (item.equals(<span class="string">&quot;/&quot;</span>)) &#123;</span><br><span class="line">                    result = num1 / num2;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;运算符有误&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//把result入栈</span></span><br><span class="line">                stack.push(result + <span class="string">&quot;&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//最后留在stack中的数据就是结果</span></span><br><span class="line">        <span class="keyword">return</span> Integer.parseInt(stack.pop());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//编写一个类Operation可以返回一个运算符对应的优先级</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Operation</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> ADD = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> SUB = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> MUL = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> DIV = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//写一个方法，返回对应的优先级的数字</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getValue</span><span class="params">(String operation)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">switch</span> (operation) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;+&quot;</span>:</span><br><span class="line">                result = ADD;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;-&quot;</span>:</span><br><span class="line">                result = SUB;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;*&quot;</span>:</span><br><span class="line">                result = MUL;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;/&quot;</span>:</span><br><span class="line">                result = DIV;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                System.out.println(<span class="string">&quot;不存在该运算符！&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/hexo-blog/2022/04/22/%E8%B0%B7%E7%B2%92%E5%AD%A6%E9%99%A2%E6%A0%B8%E5%BF%83%E4%B8%9A%E5%8A%A1%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<p>title: 谷粒学院核心业务实现<br>date: 2022-04-22 21:20:45<br>tags: 在线教育</p>
<h1 id="项目背景"><a href="#项目背景" class="headerlink" title="项目背景"></a>项目背景</h1><h2 id="1-基本概述"><a href="#1-基本概述" class="headerlink" title="1. 基本概述"></a>1. 基本概述</h2><p>在线教育顾名思义，是以网络为介质的教学方式，通过网络，学员与教师即使相隔万里也可以开展教学活动；此外，借助网络课件，学员还可以随时随地地进行学习，真正打破了时间和空间地限制，对于工作繁忙，学习时间不固定的职场人而言网络远程教育是最方便不过的学习方式</p>
<h2 id="2-发展潜力"><a href="#2-发展潜力" class="headerlink" title="2. 发展潜力"></a>2. 发展潜力</h2><p>所有人离不开教育：早期教育、课外辅导、少儿英语、职业教育、出国留学、商学院、移民服务……而在信息化爆发式发展的趋势下，在线教育越来越凸显出优势：</p>
<p>（1）在线教育可以突破时间和空间的限制，提升了学习效率；</p>
<p>（2）在线教育可以跨越因地域等方面造成的教育资源不平等分配，使教育资源共享化，降低了学习的门槛</p>
<p>基于在线教育的特点和优势，网络学校受到越来越多人的认可，各类新兴的网校及相关网站也不断涌现。显然，这代表着网校已经逐渐走进大众生活并成为一种学习的主流趋势。因此很多人开始选择在线教育，特别是白领一族和大学生们。仅2012年一年，中国在线教育市场份额已经达到723亿元，且在线教育用户呈规模性放大。</p>
<h2 id="3-适用行业"><a href="#3-适用行业" class="headerlink" title="3. 适用行业"></a>3. 适用行业</h2><p>具体来说在线培训学习系统可适合于：</p>
<p>（1）政府：现今我们的政府也提倡学习型组织，不断变化的政策环境、不断出现的新事物对政府公务员提出了更高的要求，而且政府机构的网络资源较佳，“在线培训系统”对公务员学习新知识和提高素质有很大帮助，更关键的是政府机构是垂直管理体制，只要在一个领域中创建并维护一套知识库，就可以让整个领域共享这宝贵的知识财富。</p>
<p>（2）学校：随着网络的兴起，各大中学校可通过建立网上学校，加强学校、老师、学生之间的相互交流沟通，提高教学质量，亦可建立公共教学资源库，建设精品课程，宣传学校的教育实力。</p>
<p>（3）行业：许多行业知识库体系庞大，专业多且层次深，因此行业一直注重知识和经验的积累，但这些宝贵的知识财富散落在各地，并没有利用和共享，因此，充分利用现有资源就能够创建一套丰富的知识库体系，让整个行业受益。</p>
<p>（4）企业：企业的知识库体系通常是企业的核心竞争力，使用“在线教育培训系统”，企业能够创建自己的知识库体系，并允许企业内部员工随时随地学习和分享这些知识。不断提升的员工素质和不断积累的企业知识库是企业能够保持长久的竞争力的关键。对于大型企业，还可以为合作伙伴及客户创建远程学习平台，提升和考核合作伙伴的专业技能并降低服务和支持成本。</p>
<h2 id="4-行业分类"><a href="#4-行业分类" class="headerlink" title="4. 行业分类"></a>4. 行业分类</h2><p>（1）母婴，代表网站：妈妈网</p>
<p>（2）学前教育，代表网站：宝宝巴士</p>
<p>（3）少儿外语，代表网站：VIPKID</p>
<p>（4）中小学生，代表网站：学而思</p>
<p>（5）高校学生，代表网站：中国大学慕课、学堂在线</p>
<p>（6）留学，代表网站：启德考培</p>
<p>（7）职业考试，代表网站：中公教育</p>
<p>（8）职业技能，代表网站：51CTO</p>
<p>（9）成人外语，代表网站：沪江网校</p>
<p>（10）个人兴趣，代表网站：美食杰</p>
<h1 id="八种商业模式"><a href="#八种商业模式" class="headerlink" title="八种商业模式"></a>八种商业模式</h1><h2 id="1-B2C模式（Business-To-Customer-会员模式）"><a href="#1-B2C模式（Business-To-Customer-会员模式）" class="headerlink" title="1. B2C模式（Business To Customer 会员模式）"></a>1. B2C模式（Business To Customer 会员模式）</h2><p>商家到用户，这种模式是自己制作大量自有版权的视频，放在自有平台上，让用户按月付费或者按年付费。 这种模式简单，快速，只要专心录制大量视频即可快速发展，其曾因为lynda的天价融资而大热。但在中国由于版权保护意识不强，教育内容易于复制，有海量的免费资源的竞争对手众多等原因，难以取得像样的现金流，<strong>谷粒学院所采用的就是B2C模式</strong></p>
<h2 id="2-C2C模式（Consumer-To-Consumer-平台模式-）"><a href="#2-C2C模式（Consumer-To-Consumer-平台模式-）" class="headerlink" title="2. C2C模式（Consumer To Consumer 平台模式 ）"></a>2. C2C模式（Consumer To Consumer 平台模式 ）</h2><p>用户到用户，这种模式本质是将自己的流量或者用户转卖给视频或者直播的内容提供者，通过出售内容分成获利。平台模式避开了非常沉重的内容和服务，扩张迅速，但实际这种模式也有缺陷，在线教育这两年的发展使内容迅速贬值，比较难带来更免费用户和流量</p>
<h2 id="3-B2B2C（商家到商家到用户）"><a href="#3-B2B2C（商家到商家到用户）" class="headerlink" title="3. B2B2C（商家到商家到用户）"></a>3. B2B2C（商家到商家到用户）</h2><p>平台链接第三方教育机构和用户，平台一般不直接提供课程内容，而是更多承担教育的互联网载体角色，为教学过程各个环节提供全方位支持和服务</p>
<h2 id="4-垂直领域"><a href="#4-垂直领域" class="headerlink" title="4. 垂直领域"></a>4. 垂直领域</h2><p>这种模式需要糅合录播，直播，帮助服务等多种手段，对学生学习某一项内容负责。这种模式收费高，有较强的壁垒。这种产品一旦形成口碑，会有稳定的用户群和收入，但产品非常复杂，难度大，门槛高，即使单独一个项目都会耗费大量的人力物力，因此发展速度较慢</p>
<h2 id="5-直播和互动"><a href="#5-直播和互动" class="headerlink" title="5. 直播和互动"></a>5. 直播和互动</h2><p>这种模式将传统课堂上的反馈，交互，答疑搬到线上。让用户容易接受，只要服务贴心，用 户就愿意买单，因此有丰富现金流。但缺陷是只能通过平台吸引用户，造成了竞争门槛过低， 模式雷同，对手众多，收益的永远是拥有流量或者用户的大平台</p>
<h2 id="6-1-对-1"><a href="#6-1-对-1" class="headerlink" title="6. 1 对 1"></a>6. 1 对 1</h2><p>让一个讲师在一定时间内对一个学员进行辅导，学生按照时间支付费用。这种模式收费容易， 现金流好，产品难度不大，市场空间大，但是人力资源的获取消耗却是巨大的，如果师资上控制不好，比如优秀的讲师留不住，或者整体成本太大，都会导致 1 对 1 模式难以发展</p>
<h2 id="7-O2O-模式（Online-To-Offline-线上到线下）"><a href="#7-O2O-模式（Online-To-Offline-线上到线下）" class="headerlink" title="7. O2O 模式（Online To Offline 线上到线下）"></a>7. O2O 模式（Online To Offline 线上到线下）</h2><p>就是通过免费内容或者运营，让线上平台获取用户和流量，将用户吸引到线下开课，或 者让学员到加盟的线下机构上课。这种模式形式简单，收益高，只要把控用户需求，吸引到用户，收费不成问题，而且符合传统的消费习惯</p>
<h2 id="8-freemium（免费增值）"><a href="#8-freemium（免费增值）" class="headerlink" title="8. freemium（免费增值）"></a>8. freemium（免费增值）</h2><p>Freemium最早由AVC的Fred Wilson在2006年提出, 指的是用免费服务吸引用户，然后通过增值服务，将部分免费用户转化为收费用户，实现变现。Freemium模式中有“二八定律”的因素，即一小部分对价格不敏感的高端用户，愿意为一些额 外的功能付费，为服务提供者带来大部分收入</p>
<h1 id="项目功能模块"><a href="#项目功能模块" class="headerlink" title="项目功能模块"></a>项目功能模块</h1><h2 id="1-系统后台部分（管理员使用）"><a href="#1-系统后台部分（管理员使用）" class="headerlink" title="1. 系统后台部分（管理员使用）"></a>1. 系统后台部分（管理员使用）</h2><p><strong>1、讲师管理模块</strong></p>
<p><strong>2、课程分类管理</strong></p>
<p><strong>3、课程管理模块</strong></p>
<p><strong>4、统计分析模块</strong></p>
<p><strong>5、订单管理</strong></p>
<p><strong>6、banner管理</strong></p>
<p>7、权限管理（由于该课程的权限管理讲得过于稀烂，在这里不再实现此功能）</p>
<h2 id="2-系统前台（普通用户使用）"><a href="#2-系统前台（普通用户使用）" class="headerlink" title="2. 系统前台（普通用户使用）"></a>2. 系统前台（普通用户使用）</h2><p><strong>1、首页数据显示</strong></p>
<p><strong>2、讲师列表和详情</strong></p>
<p><strong>3、课程列表和课程详情</strong></p>
<p><strong>4、登录和注册功能</strong></p>
<p><strong>5、微信扫码登录</strong></p>
<p><strong>6、微信扫码支付</strong></p>
<h1 id="项目技术点"><a href="#项目技术点" class="headerlink" title="项目技术点"></a>项目技术点</h1><h2 id="1-后端技术"><a href="#1-后端技术" class="headerlink" title="1. 后端技术"></a>1. 后端技术</h2><p><strong>SpringBoot、SpringCloud、MyBatisPlus、</strong>SpringSecurity、<strong>Redis、Maven、EasyExcel、JWT、OAuth2</strong></p>
<h2 id="2-前端技术"><a href="#2-前端技术" class="headerlink" title="2. 前端技术"></a>2. 前端技术</h2><p><strong>Vue、Element-UI、Axios、Node.js</strong> ……</p>
<h2 id="3-其他技术"><a href="#3-其他技术" class="headerlink" title="3. 其他技术"></a>3. 其他技术</h2><p><strong>阿里云oss、阿里云视频点播服务、腾讯云短信服务、微信支付和登录</strong>、Docker、Jenkins、<strong>Git</strong></p>
<h1 id="前后端分离"><a href="#前后端分离" class="headerlink" title="前后端分离"></a>前后端分离</h1><h2 id="1-什么是前后端分离"><a href="#1-什么是前后端分离" class="headerlink" title="1. 什么是前后端分离"></a>1. 什么是前后端分离</h2><p>前后端分离是目前一种非常流行的开发模式，它使项目的分工更加明确</p>
<ul>
<li><p>前端：负责显示数据</p>
</li>
<li><p>后端：负责处理、存储数据</p>
</li>
</ul>
<p>前端和后端开发人员通过<strong>接口</strong>进行数据的交换</p>
<h2 id="2-流程"><a href="#2-流程" class="headerlink" title="2. 流程"></a>2. 流程</h2><p><img src="https://rulerofterabithia-blog.oss-cn-hangzhou.aliyuncs.com/img/20220524193100.png"></p>
<p><a href="%5B%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB%E5%BC%80%E5%8F%91%E6%A8%A1%E5%BC%8F%E4%BB%8B%E7%BB%8D_dakesong%E7%9A%84%E5%8D%9A%E5%AE%A2-CSDN%E5%8D%9A%E5%AE%A2_%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB%5D(https://blog.csdn.net/weixin_45774195/article/details/107938967)">参考博客</a></p>
<h1 id="项目准备工作"><a href="#项目准备工作" class="headerlink" title="项目准备工作"></a>项目准备工作</h1><h2 id="1-数据库设计"><a href="#1-数据库设计" class="headerlink" title="1. 数据库设计"></a>1. 数据库设计</h2><p>数据库设计规约：</p>
<p>以下规约只针对本模块，更全面的文档参考《阿里巴巴Java开发手册》：五、MySQL数据库</p>
<p>1、库名与应用名称尽量一致</p>
<p>2、表名、字段名必须使用小写字母或数字，禁止出现数字开头，</p>
<p>3、表名不使用复数名词</p>
<p>4、表的命名最好是加上“业务名称_表的作用”。如，edu_teacher</p>
<p>5、表必备三字段：id, gmt_create, gmt_modified</p>
<p>说明：</p>
<p>其中 id 必为主键，类型为 bigint unsigned、单表时自增、步长为 1。</p>
<p>（如果使用分库分表集群部署，则id类型为verchar，非自增，业务中使用分布式id生成器）</p>
<p>gmt_create, gmt_modified 的类型均为 datetime 类型，前者现在时表示主动创建，后者过去分词表示被 动更新。 </p>
<p>6、单表行数超过 500 万行或者单表容量超过 2GB，才推荐进行分库分表。 说明：如果预计三年后的数据量根本达不到这个级别，请不要在创建表时就分库分表。 </p>
<p>7、表达是与否概念的字段，必须使用 is_xxx 的方式命名，数据类型是 unsigned tinyint （1 表示是，0 表示否）。 </p>
<p>说明：任何字段如果为非负数，必须是 unsigned。 </p>
<p>注意：POJO 类中的任何布尔类型的变量，都不要加 is 前缀。数据库表示是与否的值，使用 tinyint 类型，坚持 is_xxx 的 命名方式是为了明确其取值含义与取值范围。 </p>
<p>正例：表达逻辑删除的字段名 is_deleted，1 表示删除，0 表示未删除。 </p>
<p>8、小数类型为 decimal，禁止使用 float 和 double。 说明：float 和 double 在存储的时候，存在精度损失的问题，很可能在值的比较时，得到不 正确的结果。如果存储的数据范围超过 decimal 的范围，建议将数据拆成整数和小数分开存储。</p>
<p>9、如果存储的字符串长度几乎相等，使用 char 定长字符串类型。 </p>
<p>10、varchar 是可变长字符串，不预先分配存储空间，长度不要超过 5000，如果存储长度大于此值，定义字段类型为 text，独立出来一张表，用主键来对应，避免影响其它字段索 引效率。</p>
<p>11、唯一索引名为 uk_字段名；普通索引名则为 idx_字段名。</p>
<p>说明：uk_ 即 unique key；idx_ 即 index 的简称</p>
<p>12、不得使用外键与级联，一切外键概念必须在应用层解决。外键与级联更新适用于单机低并发，不适合分布式、高并发集群；级联更新是强阻塞，存在数据库更新风暴的风险；外键影响数据库的插入速度。 </p>
<h2 id="2-搭建项目工程（父工程）"><a href="#2-搭建项目工程（父工程）" class="headerlink" title="2. 搭建项目工程（父工程）"></a>2. 搭建项目工程（父工程）</h2><p>项目工程结构：</p>
<p><img src="https://rulerofterabithia-blog.oss-cn-hangzhou.aliyuncs.com/img/20220524193143.png"></p>
<h1 id="讲师管理后端"><a href="#讲师管理后端" class="headerlink" title="讲师管理后端"></a>讲师管理后端</h1><h2 id="1-创建数据库和表"><a href="#1-创建数据库和表" class="headerlink" title="1. 创建数据库和表"></a>1. 创建数据库和表</h2><blockquote>
<p>guli_edu.sql</p>
</blockquote>
<h2 id="2-配置文件"><a href="#2-配置文件" class="headerlink" title="2. 配置文件"></a>2. 配置文件</h2><p>service_edu模块配置文件</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 端口号</span></span><br><span class="line"><span class="meta">server.port</span>=<span class="string">8001</span></span><br><span class="line"><span class="comment"># 服务名</span></span><br><span class="line"><span class="meta">spring.application.name</span>=<span class="string">service-edu</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 环境设置：dev、test、prod</span></span><br><span class="line"><span class="meta">spring.profiles.active</span>=<span class="string">dev</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># mysql数据库连接</span></span><br><span class="line"><span class="meta">spring.datasource.driver-class-name</span>=<span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line"><span class="meta">spring.datasource.url</span>=<span class="string">jdbc:mysql://localhost:3306/guli_academy?serverTimezone=GMT%2B8&amp;useUnicode=true&amp;characterEncoding=utf8</span></span><br><span class="line"><span class="meta">spring.datasource.username</span>=<span class="string">root</span></span><br><span class="line"><span class="meta">spring.datasource.password</span>=<span class="string">123456</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># mybatis日志</span></span><br><span class="line"><span class="comment">#mybatis-plus.configuration.log-impl=org.apache.ibatis.logging.stdout.StdOutImpl</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回json的全局时间格式</span></span><br><span class="line"><span class="meta">spring.jackson.date-format</span>=<span class="string">yyyy-MM-dd HH:mm:ss</span></span><br><span class="line"><span class="meta">spring.jackson.time-zone</span>=<span class="string">GMT+8</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置日志级别</span></span><br><span class="line"><span class="comment">#logging.level.root=INFO</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置mapper.xml文件的路径</span></span><br><span class="line"><span class="meta">mybatis-plus.mapper-locations</span>=<span class="string">classpath:com/cyk/eduservice/mapper/xml/*.xml</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># nacos服务地址</span></span><br><span class="line"><span class="meta">spring.cloud.nacos.discovery.server-addr</span>=<span class="string">127.0.0.1:8848</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 开启熔断机制</span></span><br><span class="line"><span class="meta">feign.hystrix.enabled</span>=<span class="string">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置hystrix超时时间，默认1000ms</span></span><br><span class="line"><span class="meta">hystrix.command.default.execution.isolation.thread.timeoutInMilliseconds</span>=<span class="string">6000</span></span><br><span class="line"></span><br><span class="line"><span class="meta">spring.redis.host</span>=<span class="string">192.168.196.128</span></span><br><span class="line"><span class="meta">spring.redis.port</span>=<span class="string">6379</span></span><br><span class="line"><span class="meta">spring.redis.database</span>= <span class="string">0</span></span><br><span class="line"><span class="meta">spring.redis.timeout</span>=<span class="string">1800000</span></span><br><span class="line"></span><br><span class="line"><span class="meta">spring.redis.lettuce.pool.max-active</span>=<span class="string">20</span></span><br><span class="line"><span class="meta">spring.redis.lettuce.pool.max-wait</span>=<span class="string">-1</span></span><br><span class="line"><span class="comment">#最大阻塞等待时间(负数表示没限制)</span></span><br><span class="line"><span class="meta">spring.redis.lettuce.pool.max-idle</span>=<span class="string">5</span></span><br><span class="line"><span class="meta">spring.redis.lettuce.pool.min-idle</span>=<span class="string">0</span></span><br></pre></td></tr></table></figure>

<h2 id="3-代码生成器"><a href="#3-代码生成器" class="headerlink" title="3. 代码生成器"></a>3. 代码生成器</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CodeGenerator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1、创建代码生成器</span></span><br><span class="line">        AutoGenerator mpg = <span class="keyword">new</span> AutoGenerator();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2、全局配置</span></span><br><span class="line">        GlobalConfig gc = <span class="keyword">new</span> GlobalConfig();</span><br><span class="line">        String projectPath = System.getProperty(<span class="string">&quot;user.dir&quot;</span>);</span><br><span class="line">        gc.setOutputDir(<span class="string">&quot;D:\\Workspace\\IDEAworkspace\\guli_academy\\guli_parent\\service\\service_edu&quot;</span> + <span class="string">&quot;/src/main/java&quot;</span>);</span><br><span class="line"></span><br><span class="line">        gc.setAuthor(<span class="string">&quot;cyk&quot;</span>);</span><br><span class="line">        gc.setOpen(<span class="keyword">false</span>); <span class="comment">//生成后是否打开资源管理器</span></span><br><span class="line">        gc.setFileOverride(<span class="keyword">false</span>); <span class="comment">//重新生成时文件是否覆盖</span></span><br><span class="line">        gc.setServiceName(<span class="string">&quot;%sService&quot;</span>);    <span class="comment">//去掉Service接口的首字母I</span></span><br><span class="line">        gc.setIdType(IdType.ID_WORKER_STR); <span class="comment">//主键策略</span></span><br><span class="line">        gc.setDateType(DateType.ONLY_DATE);<span class="comment">//定义生成的实体类中日期类型</span></span><br><span class="line">        gc.setSwagger2(<span class="keyword">true</span>);<span class="comment">//开启Swagger2模式</span></span><br><span class="line"></span><br><span class="line">        mpg.setGlobalConfig(gc);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3、数据源配置</span></span><br><span class="line">        DataSourceConfig dsc = <span class="keyword">new</span> DataSourceConfig();</span><br><span class="line">        dsc.setUrl(<span class="string">&quot;jdbc:mysql://localhost:3306/guli_academy?serverTimezone=GMT%2B8&quot;</span>);</span><br><span class="line">        dsc.setDriverName(<span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>);</span><br><span class="line">        dsc.setUsername(<span class="string">&quot;root&quot;</span>);</span><br><span class="line">        dsc.setPassword(<span class="string">&quot;123456&quot;</span>);</span><br><span class="line">        dsc.setDbType(DbType.MYSQL);</span><br><span class="line">        mpg.setDataSource(dsc);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4、包配置</span></span><br><span class="line">        PackageConfig pc = <span class="keyword">new</span> PackageConfig();</span><br><span class="line">        pc.setModuleName(<span class="string">&quot;eduservice&quot;</span>); <span class="comment">//模块名</span></span><br><span class="line">        pc.setParent(<span class="string">&quot;com.cyk&quot;</span>);</span><br><span class="line">        pc.setController(<span class="string">&quot;controller&quot;</span>);</span><br><span class="line">        pc.setEntity(<span class="string">&quot;entity&quot;</span>);</span><br><span class="line">        pc.setService(<span class="string">&quot;service&quot;</span>);</span><br><span class="line">        pc.setMapper(<span class="string">&quot;mapper&quot;</span>);</span><br><span class="line">        mpg.setPackageInfo(pc);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5、策略配置</span></span><br><span class="line">        StrategyConfig strategy = <span class="keyword">new</span> StrategyConfig();</span><br><span class="line">        strategy.setInclude(<span class="string">&quot;edu_comment&quot;</span>);</span><br><span class="line">        strategy.setNaming(NamingStrategy.underline_to_camel);<span class="comment">//数据库表映射到实体的命名策略</span></span><br><span class="line">        strategy.setTablePrefix(pc.getModuleName() + <span class="string">&quot;_&quot;</span>); <span class="comment">//生成实体时去掉表前缀</span></span><br><span class="line"></span><br><span class="line">        strategy.setColumnNaming(NamingStrategy.underline_to_camel);<span class="comment">//数据库表字段映射到实体的命名策略</span></span><br><span class="line">        strategy.setEntityLombokModel(<span class="keyword">true</span>); <span class="comment">// lombok 模型 @Accessors(chain = true) setter链式操作</span></span><br><span class="line"></span><br><span class="line">        strategy.setRestControllerStyle(<span class="keyword">true</span>); <span class="comment">//restful api风格控制器</span></span><br><span class="line">        strategy.setControllerMappingHyphenStyle(<span class="keyword">true</span>); <span class="comment">//url中驼峰转连字符</span></span><br><span class="line"></span><br><span class="line">        mpg.setStrategy(strategy);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 6、执行</span></span><br><span class="line">        mpg.execute();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-讲师管理功能"><a href="#4-讲师管理功能" class="headerlink" title="4. 讲师管理功能"></a>4. 讲师管理功能</h2><h3 id="4-1-查询讲师表的所有功能"><a href="#4-1-查询讲师表的所有功能" class="headerlink" title="4.1 查询讲师表的所有功能"></a>4.1 查询讲师表的所有功能</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> EduTeacherService teacherService;</span><br><span class="line"></span><br><span class="line"><span class="meta">@ApiOperation(value = &quot;所有讲师列表&quot;)</span></span><br><span class="line"><span class="meta">@GetMapping(&quot;findAll&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> R <span class="title">findAllTeacher</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//调用service的方法实现查询所有的操作</span></span><br><span class="line">	List&lt;EduTeacher&gt; list = teacherService.list(<span class="keyword">null</span>);</span><br><span class="line">	<span class="keyword">return</span> R.ok().data(<span class="string">&quot;items&quot;</span>, list);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-2-逻辑删除讲师"><a href="#4-2-逻辑删除讲师" class="headerlink" title="4.2 逻辑删除讲师"></a>4.2 逻辑删除讲师</h3><ol>
<li>配置mybatisplus逻辑删除插件</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//逻辑删除插件</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ISqlInjector <span class="title">sqlInjector</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> LogicSqlInjector();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>在EduTeacher中的isDelete属性上添加逻辑删除注解@TableLogic</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ApiModelProperty(value = &quot;逻辑删除 1（true）已删除， 0（false）未删除&quot;)</span></span><br><span class="line"><span class="meta">@TableLogic</span></span><br><span class="line"><span class="keyword">private</span> Boolean isDeleted;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><p>编写EduTeacherController中的方法</p>
<p>@PathVariable String id代表获取路径中的参数id</p>
<p>删除直接调用EduTeacherService中的方法即可</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//2、逻辑删除讲师的方法</span></span><br><span class="line"><span class="meta">@ApiOperation(value = &quot;逻辑删除讲师&quot;)</span></span><br><span class="line"><span class="meta">@DeleteMapping(&quot;&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> R <span class="title">removeTeacher</span><span class="params">(<span class="meta">@ApiParam(name = &quot;id&quot;, value = &quot;讲师id&quot;, required = true)</span></span></span></span><br><span class="line"><span class="function"><span class="params">                       <span class="meta">@PathVariable</span> String id)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> flag = teacherService.removeById(id);</span><br><span class="line">    <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">        <span class="keyword">return</span> R.ok();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> R.error();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li><p>整合swagger</p>
<p>（1）由于普通浏览器无法通过在地址栏输入url测试@DeleteMapping、@UpdataMapping等请求，所以需要整合swagger或其他程序进行接口测试</p>
<p>（2）swagger的功能：①生成在线接口文档 ②方便接口测试</p>
<p>（3）为了所有的模块都能进行使用</p>
<p>SwaggerConfig：</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span><span class="comment">//配置类</span></span><br><span class="line"><span class="meta">@EnableSwagger2</span><span class="comment">//Swagger注解</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SwaggerConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Docket <span class="title">webApiConfig</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Docket(DocumentationType.SWAGGER_2)</span><br><span class="line">                .groupName(<span class="string">&quot;webApi&quot;</span>)</span><br><span class="line">                .apiInfo(webApiInfo())</span><br><span class="line">                .select()</span><br><span class="line"><span class="comment">//                .paths(Predicates.not(PathSelectors.regex(&quot;/admin/.*&quot;)))</span></span><br><span class="line">                .paths(Predicates.not(PathSelectors.regex(<span class="string">&quot;/error.*&quot;</span>)))</span><br><span class="line">                .build();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> ApiInfo <span class="title">webApiInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ApiInfoBuilder()</span><br><span class="line">                .title(<span class="string">&quot;谷粒学院测试&quot;</span>)</span><br><span class="line">                .description(<span class="string">&quot;本文档描述了课程中心微服务接口定义&quot;</span>)</span><br><span class="line">                .version(<span class="string">&quot;1.0&quot;</span>)</span><br><span class="line">                .contact(<span class="keyword">new</span> Contact(<span class="string">&quot;cyk&quot;</span>, <span class="string">&quot;https://github.com/rulerofterabithia&quot;</span>, <span class="string">&quot;caiyongkangofficial@gmail.com&quot;</span>))</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>为了能够让启动类扫描到swagger配置类，需要在service_edu的启动类上加上@ComponentScan(basePackages = {“com.cyk”})注解 </li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@ComponentScan(basePackages = &#123;&quot;com.cyk&quot;&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EduApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(EduApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-3-统一返回数据格式"><a href="#4-3-统一返回数据格式" class="headerlink" title="4.3 统一返回数据格式"></a>4.3 统一返回数据格式</h3><ol>
<li><p>项目中我们会将相应封装成json返回，一般我们会将所有接口的数据格式统一，使前端（IOS、Android、Web）对数据的操作更一致、轻松</p>
</li>
<li><p>json的数据格式：对象、数组，大多数情况下都是两种格式混合使用</p>
</li>
<li><p>一般情况下，统一返回数据格式没有固定的格式，只要能够描述清楚返回的数据状态以及返回的具体数据就可以。但是一般会包含状态码、返回消息、数据这几部分内容</p>
</li>
<li><p>例如，我们的系统要求返回的基本数据格式如下：</p>
</li>
</ol>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;success&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">&quot;code&quot;</span>: <span class="number">20000</span>,</span><br><span class="line">  <span class="attr">&quot;message&quot;</span>: <span class="string">&quot;成功&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;data&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;total&quot;</span>: <span class="number">17</span>,</span><br><span class="line">    <span class="attr">&quot;rows&quot;</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">&quot;id&quot;</span>: <span class="string">&quot;1&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;刘德华&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;intro&quot;</span>: <span class="string">&quot;毕业于师范大学数学系，热爱教育事业，执教数学思维6年有余&quot;</span></span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当没有返回数据时：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;success&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">&quot;code&quot;</span>: <span class="number">20000</span>,</span><br><span class="line">  <span class="attr">&quot;message&quot;</span>: <span class="string">&quot;成功&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;data&quot;</span>: &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>失败时：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;success&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">  <span class="attr">&quot;code&quot;</span>: <span class="number">20001</span>,</span><br><span class="line">  <span class="attr">&quot;message&quot;</span>: <span class="string">&quot;失败&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;data&quot;</span>: &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因此、统一定义返回数据格式为：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;success&quot;</span>: 布尔, <span class="comment">//响应是否成功</span></span><br><span class="line">  <span class="attr">&quot;code&quot;</span>: 数字, <span class="comment">//响应码</span></span><br><span class="line">  <span class="attr">&quot;message&quot;</span>: 字符串, <span class="comment">//返回消息</span></span><br><span class="line">  <span class="attr">&quot;data&quot;</span>: HashMap <span class="comment">//返回数据，放在键值对中</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>自定义返回状态码</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ResultCode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Integer SUCCESS = <span class="number">20000</span>;<span class="comment">//成功</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Integer ERROR = <span class="number">20001</span>;<span class="comment">//失败</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="6">
<li>定义返回数据格式</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//统一返回结果的类</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">R</span> </span>&#123;</span><br><span class="line">    <span class="meta">@ApiModelProperty(value = &quot;是否成功&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Boolean success;</span><br><span class="line">    <span class="meta">@ApiModelProperty(value = &quot;返回码&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Integer code;</span><br><span class="line">    <span class="meta">@ApiModelProperty(value = &quot;返回消息&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String message;</span><br><span class="line">    <span class="meta">@ApiModelProperty(value = &quot;返回数据&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, Object&gt; data = <span class="keyword">new</span> HashMap&lt;String, Object&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//把构造方法私有</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">R</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//成功静态方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> R <span class="title">ok</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        R r = <span class="keyword">new</span> R();</span><br><span class="line">        r.setSuccess(<span class="keyword">true</span>);</span><br><span class="line">        r.setCode(ResultCode.SUCCESS);</span><br><span class="line">        r.setMessage(<span class="string">&quot;成功&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//失败静态方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> R <span class="title">error</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        R r = <span class="keyword">new</span> R();</span><br><span class="line">        r.setSuccess(<span class="keyword">false</span>);</span><br><span class="line">        r.setCode(ResultCode.ERROR);</span><br><span class="line">        r.setMessage(<span class="string">&quot;失败&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> R <span class="title">success</span><span class="params">(Boolean success)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.setSuccess(success);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> R <span class="title">message</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.setMessage(message);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> R <span class="title">code</span><span class="params">(Integer code)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.setCode(code);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> R <span class="title">data</span><span class="params">(String key, Object value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.data.put(key, value);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> R <span class="title">data</span><span class="params">(Map&lt;String, Object&gt; map)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.setData(map);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-4-分页查询讲师"><a href="#4-4-分页查询讲师" class="headerlink" title="4.4 分页查询讲师"></a>4.4 分页查询讲师</h3><ol>
<li>配置mybatisplus分页插件</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//分页插件</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> PaginationInterceptor <span class="title">paginationInterceptor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> PaginationInterceptor();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>编写讲师分页查询接口的方法</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//3、分页查询讲师的方法</span></span><br><span class="line"><span class="comment">//current代表当前页，limit代表每页的记录数</span></span><br><span class="line"><span class="meta">@GetMapping(&quot;pageTeacher/&#123;current&#125;/&#123;limit&#125;&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> R <span class="title">pageListTeacher</span><span class="params">(<span class="meta">@PathVariable</span> <span class="keyword">long</span> current, <span class="meta">@PathVariable</span> <span class="keyword">long</span> limit)</span> </span>&#123;</span><br><span class="line"><span class="comment">//创建Page对象</span></span><br><span class="line">Page&lt;EduTeacher&gt; pageTeacher = <span class="keyword">new</span> Page&lt;&gt;(current, limit);</span><br><span class="line"><span class="comment">//调用方法实现分页</span></span><br><span class="line"><span class="comment">//调用方法的时候，底层会封装，把分页的所有数据封装到pageTeacher对象里面</span></span><br><span class="line">teacherService.page(pageTeacher, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> total = pageTeacher.getTotal();<span class="comment">//总记录数</span></span><br><span class="line">List&lt;EduTeacher&gt; records = pageTeacher.getRecords();<span class="comment">//数据list集合</span></span><br><span class="line"><span class="keyword">return</span> R.ok().data(<span class="string">&quot;total&quot;</span>, total).data(<span class="string">&quot;rows&quot;</span>, records);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-5-多条件组合查询讲师带分页"><a href="#4-5-多条件组合查询讲师带分页" class="headerlink" title="4.5 多条件组合查询讲师带分页"></a>4.5 多条件组合查询讲师带分页</h3><ol>
<li>把条件值传递到接口里面去，具体实现方式：把条件值封装到对象里面，再把对象传递到接口里面</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//TeacherQuery用于封装条件</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TeacherQuery</span> </span>&#123;</span><br><span class="line">    <span class="meta">@ApiModelProperty(value = &quot;教师名称，模糊查询&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="meta">@ApiModelProperty(value = &quot;头衔 1高级讲师 2首席讲师&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Integer level;</span><br><span class="line">    <span class="meta">@ApiModelProperty(value = &quot;查询开始时间&quot;, example = &quot;2019-01-01 10:10:10&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String begin;<span class="comment">//注意，这里使用的是String类型，前端传过来的值无需进行类型转换</span></span><br><span class="line">    <span class="meta">@ApiModelProperty(value = &quot;查询时间结束&quot;, example = &quot;2019-12-01 10:10:10&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String end;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>在EduTeacherController中编写方法，根据条件值判断是否为空，不为空则拼接条件</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//4、条件查询带分页的方法</span></span><br><span class="line"><span class="meta">@PostMapping(&quot;pageTeacherCondition/&#123;current&#125;/&#123;limit&#125;&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> R <span class="title">pageTeacherCondition</span><span class="params">(<span class="meta">@PathVariable</span> <span class="keyword">long</span> current,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="meta">@PathVariable</span> <span class="keyword">long</span> limit,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="meta">@RequestBody(required = false)</span> TeacherQuery teacherQuery)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//创建page对象</span></span><br><span class="line">    Page&lt;EduTeacher&gt; pageTeacher = <span class="keyword">new</span> Page&lt;&gt;(current, limit);</span><br><span class="line">    <span class="comment">//构建条件</span></span><br><span class="line">    QueryWrapper&lt;EduTeacher&gt; wrapper = <span class="keyword">new</span> QueryWrapper&lt;&gt;();</span><br><span class="line">    <span class="comment">//多条件组合查询</span></span><br><span class="line">    String name = teacherQuery.getName();</span><br><span class="line">    Integer level = teacherQuery.getLevel();</span><br><span class="line">    String begin = teacherQuery.getBegin();</span><br><span class="line">    String end = teacherQuery.getEnd();</span><br><span class="line">    <span class="comment">//判断条件值是否为空，如果不为空拼接条件</span></span><br><span class="line">    <span class="keyword">if</span> (!StringUtils.isEmpty(name)) &#123;</span><br><span class="line">        <span class="comment">//构建条件</span></span><br><span class="line">        wrapper.like(<span class="string">&quot;name&quot;</span>, name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!StringUtils.isEmpty(level)) &#123;</span><br><span class="line">        <span class="comment">//构建条件</span></span><br><span class="line">        wrapper.eq(<span class="string">&quot;level&quot;</span>, level);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!StringUtils.isEmpty(begin)) &#123;</span><br><span class="line">        <span class="comment">//构建条件</span></span><br><span class="line">        wrapper.ge(<span class="string">&quot;gmt_create&quot;</span>, begin);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!StringUtils.isEmpty(end)) &#123;</span><br><span class="line">        <span class="comment">//构建条件</span></span><br><span class="line">        wrapper.le(<span class="string">&quot;gmt_create&quot;</span>, end);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//排序</span></span><br><span class="line">    wrapper.orderByDesc(<span class="string">&quot;gmt_create&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//调用方法实现条件查询分页</span></span><br><span class="line">    teacherService.page(pageTeacher, wrapper);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> total = pageTeacher.getTotal();<span class="comment">//总记录数</span></span><br><span class="line">    List&lt;EduTeacher&gt; records = pageTeacher.getRecords();<span class="comment">//数据list集合</span></span><br><span class="line">    <span class="keyword">return</span> R.ok().data(<span class="string">&quot;total&quot;</span>, total).data(<span class="string">&quot;rows&quot;</span>, records);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>关于@ResponseBody和@RequestBody：</li>
</ol>
<p>@ResponseBody：主要作用是：在一般情况下，返回json格式的数据</p>
<p>@RequestBody：使用json传递数据，把前端的json数据封装到对应对象里面，RequestBody需要使用post提交方式</p>
<p>[参考博客](<a href="https://www.cnblogs.com/daimajun/p/7152970.html">@ResponseBody 和 @RequestBody 的作用 - 码上猿梦 - 博客园 (cnblogs.com)</a>)</p>
<h3 id="4-6-添加讲师"><a href="#4-6-添加讲师" class="headerlink" title="4.6 添加讲师"></a>4.6 添加讲师</h3><ol>
<li>设置创建时间和修改时间自动填充，添加@TableField注解</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ApiModelProperty(value = &quot;创建时间&quot;)</span></span><br><span class="line"><span class="meta">@TableField(fill = FieldFill.INSERT)</span></span><br><span class="line"><span class="keyword">private</span> Date gmtCreate;</span><br><span class="line"></span><br><span class="line"><span class="meta">@ApiModelProperty(value = &quot;更新时间&quot;)</span></span><br><span class="line"><span class="meta">@TableField(fill = FieldFill.INSERT_UPDATE)</span></span><br><span class="line"><span class="keyword">private</span> Date gmtModified;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>编写配置类</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyMetaObjectHandler</span> <span class="keyword">implements</span> <span class="title">MetaObjectHandler</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insertFill</span><span class="params">(MetaObject metaObject)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//属性名称，不是字段名称</span></span><br><span class="line">        <span class="keyword">this</span>.setFieldValByName(<span class="string">&quot;gmtCreate&quot;</span>, <span class="keyword">new</span> Date(), metaObject);</span><br><span class="line">        <span class="keyword">this</span>.setFieldValByName(<span class="string">&quot;gmtModified&quot;</span>, <span class="keyword">new</span> Date(), metaObject);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateFill</span><span class="params">(MetaObject metaObject)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.setFieldValByName(<span class="string">&quot;gmtModified&quot;</span>, <span class="keyword">new</span> Date(), metaObject);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>在EduTeacherController中编写方法</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//5、添加讲师接口的方法</span></span><br><span class="line"><span class="meta">@PostMapping(&quot;addTeacher&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> R <span class="title">addTeacher</span><span class="params">(<span class="meta">@RequestBody</span> EduTeacher eduTeacher)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> save = teacherService.save(eduTeacher);</span><br><span class="line">    <span class="keyword">if</span> (save) &#123;</span><br><span class="line">        <span class="keyword">return</span> R.ok();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> R.error();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>7.4.7 讲师的修改功能</p>
<ol>
<li>需要先根据讲师id进行查询</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//6、根据讲师id进行查询</span></span><br><span class="line"><span class="meta">@GetMapping(&quot;getTeacher/&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> R <span class="title">getTeacher</span><span class="params">(<span class="meta">@PathVariable</span> String id)</span> </span>&#123;</span><br><span class="line">    EduTeacher eduTeacher = teacherService.getById(id);</span><br><span class="line">    <span class="keyword">return</span> R.ok().data(<span class="string">&quot;teacher&quot;</span>, eduTeacher);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>修改讲师</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//7、讲师修改功能</span></span><br><span class="line"><span class="meta">@PostMapping(&quot;updateTeacher&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> R <span class="title">updateTeacher</span><span class="params">(<span class="meta">@RequestBody</span> EduTeacher eduTeacher)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> flag = teacherService.updateById(eduTeacher);</span><br><span class="line">    <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">        <span class="keyword">return</span> R.ok();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> R.error();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="统一异常处理"><a href="#统一异常处理" class="headerlink" title="统一异常处理"></a>统一异常处理</h1><h2 id="1-全局异常处理"><a href="#1-全局异常处理" class="headerlink" title="1. 全局异常处理"></a>1. 全局异常处理</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ControllerAdvice</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GlobalExceptionHandler</span> </span>&#123;</span><br><span class="line">    <span class="comment">//指定出现什么异常执行这个方法</span></span><br><span class="line">    <span class="meta">@ExceptionHandler(Exception.class)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span><span class="comment">//为了返回数据</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> R <span class="title">error</span><span class="params">(Exception e)</span> </span>&#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        <span class="keyword">return</span> R.error().message(<span class="string">&quot;执行了全局异常处理&quot;</span>);</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-特定异常处理"><a href="#2-特定异常处理" class="headerlink" title="2. 特定异常处理"></a>2. 特定异常处理</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//特定异常</span></span><br><span class="line"><span class="meta">@ExceptionHandler(ArithmeticException.class)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> R <span class="title">error</span><span class="params">(ArithmeticException e)</span> </span>&#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">    <span class="keyword">return</span> R.error().message(<span class="string">&quot;执行了ArithmeticException异常处理&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-自定义异常处理"><a href="#3-自定义异常处理" class="headerlink" title="3. 自定义异常处理"></a>3. 自定义异常处理</h2><h3 id="3-1-创建自定义异常类继承RuntimeException，编写异常属性"><a href="#3-1-创建自定义异常类继承RuntimeException，编写异常属性" class="headerlink" title="3.1 创建自定义异常类继承RuntimeException，编写异常属性"></a>3.1 创建自定义异常类继承RuntimeException，编写异常属性</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span> <span class="comment">//生成有参构造方法</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span> <span class="comment">//生成无参构造器</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GuliException</span> <span class="keyword">extends</span> <span class="title">RuntimeException</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer code;<span class="comment">//异常状态码</span></span><br><span class="line">    <span class="keyword">private</span> String msg;<span class="comment">//异常信息</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-2-在统一异常类添加规则"><a href="#3-2-在统一异常类添加规则" class="headerlink" title="3.2 在统一异常类添加规则"></a>3.2 在统一异常类添加规则</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//自定义异常</span></span><br><span class="line"><span class="meta">@ExceptionHandler(GuliException.class)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> R <span class="title">error</span><span class="params">(GuliException e)</span> </span>&#123;</span><br><span class="line">    log.error(e.getMessage());</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">    <span class="keyword">return</span> R.error().code(e.getCode()).message(e.getMsg());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-3-执行自定义异常示例"><a href="#3-3-执行自定义异常示例" class="headerlink" title="3.3 执行自定义异常示例"></a>3.3 执行自定义异常示例</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="comment">//会出现异常的代码</span></span><br><span class="line">    <span class="keyword">int</span> <span class="number">1</span> / <span class="number">0</span>; </span><br><span class="line">&#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">    <span class="comment">//执行自定义异常</span></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> GuliException(<span class="number">20001</span>,<span class="string">&quot;执行了自定义异常处理...&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="统一日志处理"><a href="#统一日志处理" class="headerlink" title="统一日志处理"></a>统一日志处理</h1><h2 id="1-日志是干什么的？"><a href="#1-日志是干什么的？" class="headerlink" title="1. 日志是干什么的？"></a>1. 日志是干什么的？</h2><p>日志的作用：通过日志可以更好地观察到程序地运行状态，更快地定位到哪里出了问题</p>
<h2 id="2-日志级别"><a href="#2-日志级别" class="headerlink" title="2. 日志级别"></a>2. 日志级别</h2><p>OFF、FATAL、ERROR、WARN、INFO、DEBUG、ALL</p>
<p>默认的日志级别是INFO</p>
<h2 id="3-设置日志级别"><a href="#3-设置日志级别" class="headerlink" title="3. 设置日志级别"></a>3. 设置日志级别</h2><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 设置日志级别</span></span><br><span class="line"><span class="meta">logging.level.root</span>=<span class="string">INFO</span></span><br></pre></td></tr></table></figure>

<h2 id="4-使用logback日志工具，把日志不仅输出到控制台，也可以输出到文件中"><a href="#4-使用logback日志工具，把日志不仅输出到控制台，也可以输出到文件中" class="headerlink" title="4. 使用logback日志工具，把日志不仅输出到控制台，也可以输出到文件中"></a>4. 使用logback日志工具，把日志不仅输出到控制台，也可以输出到文件中</h2><p>第一步：删除applications.properties中的日志配置</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 设置日志级别</span></span><br><span class="line"><span class="comment">#logging.level.root=INFO</span></span><br><span class="line"><span class="comment"># mybatis日志</span></span><br><span class="line"><span class="comment">#mybatis-plus.configuration.log-impl=org.apache.ibatis.logging.stdout.StdOutImpl</span></span><br></pre></td></tr></table></figure>

<p>第二步：在resources中创建logback-spring.xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span> <span class="attr">scan</span>=<span class="string">&quot;true&quot;</span> <span class="attr">scanPeriod</span>=<span class="string">&quot;10 seconds&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 日志级别从低到高分为TRACE &lt; DEBUG &lt; INFO &lt; WARN &lt; ERROR &lt; FATAL，如果设置为WARN，则低于WARN的信息都不会输出 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- scan:当此属性设置为true时，配置文件如果发生改变，将会被重新加载，默认值为true --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- scanPeriod:设置监测配置文件是否有修改的时间间隔，如果没有给出时间单位，默认单位是毫秒。当scan为true时，此属性生效。默认的时间间隔为1分钟。 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- de<span class="doctag">bug:</span>当此属性设置为true时，将打印出logback内部日志信息，实时查看logback运行状态。默认值为false。 --&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">contextName</span>&gt;</span>logback<span class="tag">&lt;/<span class="name">contextName</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- name的值是变量的名称，value的值时变量定义的值。通过定义的值会被插入到logger上下文中。定义变量后，可以使“$&#123;&#125;”来使用变量。 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;log.path&quot;</span> <span class="attr">value</span>=<span class="string">&quot;D:/download/guli_academy&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 彩色日志 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 配置格式变量：CONSOLE_LOG_PATTERN 彩色日志格式 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- magenta:洋红 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- boldMagenta:粗红--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- cyan:青色 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- white:白色 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- magenta:洋红 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;CONSOLE_LOG_PATTERN&quot;</span></span></span><br><span class="line"><span class="tag">              <span class="attr">value</span>=<span class="string">&quot;%yellow(%date&#123;yyyy-MM-dd HH:mm:ss&#125;) |%highlight(%-5level) |%blue(%thread) |%blue(%file:%line) |%green(%logger) |%cyan(%msg%n)&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--输出到控制台--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">&quot;CONSOLE&quot;</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.ConsoleAppender&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--此日志appender是为开发使用，只配置最底级别，控制台输出的日志级别是大于或等于此级别的日志信息--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 例如：如果此处配置了INFO级别，则后面其他位置即使配置了DEBUG级别的日志，也不会被输出 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.classic.filter.ThresholdFilter&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">level</span>&gt;</span>INFO<span class="tag">&lt;/<span class="name">level</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">encoder</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Pattern</span>&gt;</span>$&#123;CONSOLE_LOG_PATTERN&#125;<span class="tag">&lt;/<span class="name">Pattern</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 设置字符集 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">charset</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">charset</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--输出到文件--&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 时间滚动输出 level为 INFO 日志 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">&quot;INFO_FILE&quot;</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 正在记录的日志文件的路径及文件名 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">file</span>&gt;</span>$&#123;log.path&#125;/log_info.log<span class="tag">&lt;/<span class="name">file</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--日志文件输出格式--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">encoder</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;50&#125; - %msg%n<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">charset</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">charset</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 日志记录器的滚动策略，按日期，按大小记录 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">rollingPolicy</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 每天日志归档路径以及格式 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">fileNamePattern</span>&gt;</span>$&#123;log.path&#125;/info/log-info-%d&#123;yyyy-MM-dd&#125;.%i.log<span class="tag">&lt;/<span class="name">fileNamePattern</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">timeBasedFileNamingAndTriggeringPolicy</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">maxFileSize</span>&gt;</span>100MB<span class="tag">&lt;/<span class="name">maxFileSize</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">timeBasedFileNamingAndTriggeringPolicy</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--日志文件保留天数--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">maxHistory</span>&gt;</span>15<span class="tag">&lt;/<span class="name">maxHistory</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">rollingPolicy</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 此日志文件只记录info级别的 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.classic.filter.LevelFilter&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">level</span>&gt;</span>INFO<span class="tag">&lt;/<span class="name">level</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">onMatch</span>&gt;</span>ACCEPT<span class="tag">&lt;/<span class="name">onMatch</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">onMismatch</span>&gt;</span>DENY<span class="tag">&lt;/<span class="name">onMismatch</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 时间滚动输出 level为 WARN 日志 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">&quot;WARN_FILE&quot;</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 正在记录的日志文件的路径及文件名 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">file</span>&gt;</span>$&#123;log.path&#125;/log_warn.log<span class="tag">&lt;/<span class="name">file</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--日志文件输出格式--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">encoder</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;50&#125; - %msg%n<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">charset</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">charset</span>&gt;</span> <span class="comment">&lt;!-- 此处设置字符集 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 日志记录器的滚动策略，按日期，按大小记录 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">rollingPolicy</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">fileNamePattern</span>&gt;</span>$&#123;log.path&#125;/warn/log-warn-%d&#123;yyyy-MM-dd&#125;.%i.log<span class="tag">&lt;/<span class="name">fileNamePattern</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">timeBasedFileNamingAndTriggeringPolicy</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">maxFileSize</span>&gt;</span>100MB<span class="tag">&lt;/<span class="name">maxFileSize</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">timeBasedFileNamingAndTriggeringPolicy</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--日志文件保留天数--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">maxHistory</span>&gt;</span>15<span class="tag">&lt;/<span class="name">maxHistory</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">rollingPolicy</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 此日志文件只记录warn级别的 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.classic.filter.LevelFilter&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">level</span>&gt;</span>warn<span class="tag">&lt;/<span class="name">level</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">onMatch</span>&gt;</span>ACCEPT<span class="tag">&lt;/<span class="name">onMatch</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">onMismatch</span>&gt;</span>DENY<span class="tag">&lt;/<span class="name">onMismatch</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 时间滚动输出 level为 ERROR 日志 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">&quot;ERROR_FILE&quot;</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 正在记录的日志文件的路径及文件名 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">file</span>&gt;</span>$&#123;log.path&#125;/log_error.log<span class="tag">&lt;/<span class="name">file</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--日志文件输出格式--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">encoder</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;50&#125; - %msg%n<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">charset</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">charset</span>&gt;</span> <span class="comment">&lt;!-- 此处设置字符集 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 日志记录器的滚动策略，按日期，按大小记录 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">rollingPolicy</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">fileNamePattern</span>&gt;</span>$&#123;log.path&#125;/error/log-error-%d&#123;yyyy-MM-dd&#125;.%i.log<span class="tag">&lt;/<span class="name">fileNamePattern</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">timeBasedFileNamingAndTriggeringPolicy</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">maxFileSize</span>&gt;</span>100MB<span class="tag">&lt;/<span class="name">maxFileSize</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">timeBasedFileNamingAndTriggeringPolicy</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--日志文件保留天数--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">maxHistory</span>&gt;</span>15<span class="tag">&lt;/<span class="name">maxHistory</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">rollingPolicy</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 此日志文件只记录ERROR级别的 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.classic.filter.LevelFilter&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">level</span>&gt;</span>ERROR<span class="tag">&lt;/<span class="name">level</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">onMatch</span>&gt;</span>ACCEPT<span class="tag">&lt;/<span class="name">onMatch</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">onMismatch</span>&gt;</span>DENY<span class="tag">&lt;/<span class="name">onMismatch</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">        &lt;logger&gt;用来设置某一个包或者具体的某一个类的日志打印级别、以及指定&lt;appender&gt;。</span></span><br><span class="line"><span class="comment">        &lt;logger&gt;仅有一个name属性，</span></span><br><span class="line"><span class="comment">        一个可选的level和一个可选的addtivity属性。</span></span><br><span class="line"><span class="comment">        name:用来指定受此logger约束的某一个包或者具体的某一个类。</span></span><br><span class="line"><span class="comment">        level:用来设置打印级别，大小写无关：TRACE, DEBUG, INFO, WARN, ERROR, ALL 和 OFF，</span></span><br><span class="line"><span class="comment">              如果未设置此属性，那么当前logger将会继承上级的级别。</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">        使用mybatis的时候，sql语句是debug下才会打印，而这里我们只配置了info，所以想要查看sql语句的话，有以下两种操作：</span></span><br><span class="line"><span class="comment">        第一种把&lt;root level=&quot;INFO&quot;&gt;改成&lt;root level=&quot;DEBUG&quot;&gt;这样就会打印sql，不过这样日志那边会出现很多其他消息</span></span><br><span class="line"><span class="comment">        第二种就是单独给mapper下目录配置DEBUG模式，代码如下，这样配置sql语句会打印，其他还是正常DEBUG级别：</span></span><br><span class="line"><span class="comment">     --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--开发环境:打印控制台--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">springProfile</span> <span class="attr">name</span>=<span class="string">&quot;dev&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--可以输出项目中的debug日志，包括mybatis的sql日志--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">logger</span> <span class="attr">name</span>=<span class="string">&quot;com.guli&quot;</span> <span class="attr">level</span>=<span class="string">&quot;INFO&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">            root节点是必选节点，用来指定最基础的日志输出级别，只有一个level属性</span></span><br><span class="line"><span class="comment">            level:用来设置打印级别，大小写无关：TRACE, DEBUG, INFO, WARN, ERROR, ALL 和 OFF，默认是DEBUG</span></span><br><span class="line"><span class="comment">            可以包含零个或多个appender元素。</span></span><br><span class="line"><span class="comment">        --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">root</span> <span class="attr">level</span>=<span class="string">&quot;INFO&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;CONSOLE&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;INFO_FILE&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;WARN_FILE&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;ERROR_FILE&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">springProfile</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--生产环境:输出到文件--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">springProfile</span> <span class="attr">name</span>=<span class="string">&quot;pro&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">root</span> <span class="attr">level</span>=<span class="string">&quot;INFO&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;CONSOLE&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;DEBUG_FILE&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;INFO_FILE&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;ERROR_FILE&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;WARN_FILE&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">springProfile</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h1 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h1><p>前端的作用：通过ajax调用接口，得到数据，把数据做显示</p>
<p>axios：在vue中，发送ajax请求，请求接口，得到数据并显示</p>
<h2 id="1-Axios"><a href="#1-Axios" class="headerlink" title="1. Axios"></a>1. Axios</h2><h3 id="1-1-什么是axios"><a href="#1-1-什么是axios" class="headerlink" title="1.1 什么是axios"></a>1.1 什么是axios</h3><p>axios是独立的项目，不是vue里面的一部分，使用axios经常和vue一起使用，实现ajax操作</p>
<h3 id="1-2-使用axios应用场景"><a href="#1-2-使用axios应用场景" class="headerlink" title="1.2 使用axios应用场景"></a>1.2 使用axios应用场景</h3><p><img src="https://rulerofterabithia-blog.oss-cn-hangzhou.aliyuncs.com/img/20220524193415.png"></p>
<h2 id="2-Element-UI"><a href="#2-Element-UI" class="headerlink" title="2. Element-UI"></a>2. Element-UI</h2><p>element-ui是饿了么前端出品的基于Vue.js的后台组件库，方便程序员进行页面快速布局和构建</p>
<h2 id="3-Node-js"><a href="#3-Node-js" class="headerlink" title="3. Node.js"></a>3. Node.js</h2><h3 id="3-1-Node-js是什么"><a href="#3-1-Node-js是什么" class="headerlink" title="3.1 Node.js是什么"></a>3.1 Node.js是什么</h3><ol>
<li>之前学过Java，运行Java需要安装JDK环境，Node.js是JavaScript的运行环境，用于执行JavaScript代码，不需要浏览器，直接使用Node.js就可以运行JavaScript代码</li>
<li>可以模拟服务器效果，比如Tomcat</li>
</ol>
<h2 id="4-搭建前端环境"><a href="#4-搭建前端环境" class="headerlink" title="4. 搭建前端环境"></a>4. 搭建前端环境</h2><h3 id="4-1-下载vue-admin-template-master依赖"><a href="#4-1-下载vue-admin-template-master依赖" class="headerlink" title="4.1 下载vue-admin-template-master依赖"></a>4.1 下载vue-admin-template-master依赖</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install</span><br></pre></td></tr></table></figure>

<h3 id="4-2-启动前端项目"><a href="#4-2-启动前端项目" class="headerlink" title="4.2 启动前端项目"></a>4.2 启动前端项目</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm run dev</span><br></pre></td></tr></table></figure>

<h3 id="4-3-在config-index-js下做修改"><a href="#4-3-在config-index-js下做修改" class="headerlink" title="4.3 在config/index.js下做修改"></a>4.3 在config/index.js下做修改</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">useEslint: <span class="literal">false</span></span><br></pre></td></tr></table></figure>

<h3 id="4-4-在config-dev-env-js下修改访问后端接口地址，把登录请求地址改成本地"><a href="#4-4-在config-dev-env-js下修改访问后端接口地址，把登录请求地址改成本地" class="headerlink" title="4.4 在config/dev.env.js下修改访问后端接口地址，把登录请求地址改成本地"></a>4.4 在config/dev.env.js下修改访问后端接口地址，把登录请求地址改成本地</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">BASE_API: <span class="string">&#x27;&quot;http://localhost:8001&quot;&#x27;</span>,</span><br></pre></td></tr></table></figure>

<h3 id="4-5-编写登录接口"><a href="#4-5-编写登录接口" class="headerlink" title="4.5 编写登录接口"></a>4.5 编写登录接口</h3><p>进行登录调用两个方法，login登录操作方法，和info登录之后获取用户信息的方法。所以，要创建接口将两个方法实现</p>
<p>（1）login返回token值</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">Login</span>(<span class="params">&#123; commit &#125;, userInfo</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> username = userInfo.username.trim()</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">            login(username, userInfo.password).then(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">                <span class="keyword">const</span> data = response.data</span><br><span class="line">                    setToken(data.token)<span class="comment">//-----&gt;login返回token值</span></span><br><span class="line">                    commit(<span class="string">&#x27;SET_TOKEN&#x27;</span>, data.token)</span><br><span class="line">                    resolve()</span><br><span class="line">            &#125;).catch(<span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">                reject(error)</span><br><span class="line">            &#125;)</span><br><span class="line">                &#125;)</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//login</span></span><br><span class="line"><span class="meta">@PostMapping(&quot;login&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> R <span class="title">login</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> R.ok().data(<span class="string">&quot;token&quot;</span>, <span class="string">&quot;admin&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（2）info返回roles、name、avatar</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取用户信息</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="title">GetInfo</span>(<span class="params">&#123; commit, state &#125;</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        getInfo(state.token).then(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="comment">// debugger</span></span><br><span class="line">            <span class="keyword">const</span> data = response.data</span><br><span class="line">            <span class="keyword">if</span> (data.roles &amp;&amp; data.roles.length &gt; <span class="number">0</span>) &#123;<span class="comment">//验证返回的roles是否是一个非空数组</span></span><br><span class="line">                commit(<span class="string">&#x27;SET_ROLES&#x27;</span>, data.roles)<span class="comment">//-----&gt;返回roles</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                reject(<span class="string">&#x27;getInfo: roles must be a non-null array !&#x27;</span>)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">const</span> buttonAuthList = []</span><br><span class="line">            data.permissionValueList.forEach(<span class="function"><span class="params">button</span> =&gt;</span> &#123;</span><br><span class="line">                buttonAuthList.push(button)</span><br><span class="line">            &#125;)</span><br><span class="line"></span><br><span class="line">            commit(<span class="string">&#x27;SET_NAME&#x27;</span>, data.name)<span class="comment">//-----&gt;返回name</span></span><br><span class="line">            commit(<span class="string">&#x27;SET_AVATAR&#x27;</span>, data.avatar)<span class="comment">//-----&gt;返回avatar</span></span><br><span class="line">            commit(<span class="string">&#x27;SET_BUTTONS&#x27;</span>, buttonAuthList)</span><br><span class="line">            resolve(response)</span><br><span class="line">        &#125;).catch(<span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">            reject(error)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//info</span></span><br><span class="line"><span class="meta">@GetMapping(&quot;info&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> R <span class="title">info</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> R.ok().data(<span class="string">&quot;roles&quot;</span>, <span class="string">&quot;admin&quot;</span>).data(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;admin&quot;</span>).data(<span class="string">&quot;avatar&quot;</span>, 			<span class="string">&quot;https://wpimg.wallstcn.com/f778738c-e4f8-4870-b634-56703b4acafe.gif&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-6-修改src-api文件夹下的login-js文件修改成本地接口路径"><a href="#4-6-修改src-api文件夹下的login-js文件修改成本地接口路径" class="headerlink" title="4.6 修改src/api文件夹下的login.js文件修改成本地接口路径"></a>4.6 修改src/api文件夹下的login.js文件修改成本地接口路径</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">login</span>(<span class="params">username, password</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> request(&#123;</span><br><span class="line">        url: <span class="string">&#x27;/eduservice/user/login&#x27;</span>,</span><br><span class="line">        method: <span class="string">&#x27;post&#x27;</span>,</span><br><span class="line">        data: &#123;</span><br><span class="line">            username,</span><br><span class="line">            password</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">getInfo</span>(<span class="params">token</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> request(&#123;</span><br><span class="line">        url: <span class="string">&#x27;/eduservice/user/info&#x27;</span>,</span><br><span class="line">        method: <span class="string">&#x27;get&#x27;</span>,</span><br><span class="line">        params: &#123; token &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-7-解决跨域问题"><a href="#4-7-解决跨域问题" class="headerlink" title="4.7 解决跨域问题"></a>4.7 解决跨域问题</h3><ol>
<li>什么是跨域？</li>
</ol>
<p>通过一个地址去访问另外一个地址，这个过程中如果以下<strong>三个地方</strong>中的任何一个不一样就会产生跨域问题</p>
<p><strong>*三个地方**：</strong>访问协议、ip地址、端口号**</p>
<p>（1）访问协议：http、https</p>
<p>（2）ip地址：192.168.1.1、172.11.11.11</p>
<p>（3）端口号：9528、8001</p>
<p>前端的地址是：<a href="http://localhost:9528/">http://localhost:9528</a></p>
<p>后端登录接口的地址是：<a href="http://localhost:8001/">http://localhost:8001</a></p>
<p>两个地址的协议、ip地址都相同，但是端口号不一样，所以会出现跨域问题</p>
<ol start="2">
<li>如何解决跨域</li>
</ol>
<p>方法一：在后端的controller上加上@controller注解（常用）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@CrossOrigin</span> <span class="comment">//解决跨域问题</span></span><br></pre></td></tr></table></figure>

<p>方法二：使用gateway网关</p>
<h3 id="4-8-前端框架使用方法"><a href="#4-8-前端框架使用方法" class="headerlink" title="4.8 前端框架使用方法"></a>4.8 前端框架使用方法</h3><p><img src="https://rulerofterabithia-blog.oss-cn-hangzhou.aliyuncs.com/img/20220524193450.png"></p>
<h1 id="讲师管理前端"><a href="#讲师管理前端" class="headerlink" title="讲师管理前端"></a>讲师管理前端</h1><h2 id="1-讲师列表-条件查询带分页"><a href="#1-讲师列表-条件查询带分页" class="headerlink" title="1. 讲师列表-条件查询带分页"></a>1. 讲师列表-条件查询带分页</h2><h3 id="1-1-添加路由"><a href="#1-1-添加路由" class="headerlink" title="1.1 添加路由"></a>1.1 添加路由</h3><p>在src/router/index.js下添加路由</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//讲师管理</span></span><br><span class="line">&#123;</span><br><span class="line">  path: <span class="string">&#x27;/teacher&#x27;</span>,</span><br><span class="line">  component: Layout,</span><br><span class="line">  redirect: <span class="string">&#x27;/teacher/table&#x27;</span>,</span><br><span class="line">  name: <span class="string">&#x27;讲师管理&#x27;</span>,</span><br><span class="line">  meta: &#123; <span class="attr">title</span>: <span class="string">&#x27;讲师管理&#x27;</span>, <span class="attr">icon</span>: <span class="string">&#x27;example&#x27;</span> &#125;,</span><br><span class="line">  children: [</span><br><span class="line">    &#123;</span><br><span class="line">      path: <span class="string">&#x27;table&#x27;</span>,</span><br><span class="line">      name: <span class="string">&#x27;讲师列表&#x27;</span>,</span><br><span class="line">      component: <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&#x27;@/views/edu/teacher/list&#x27;</span>),</span><br><span class="line">      meta: &#123; <span class="attr">title</span>: <span class="string">&#x27;讲师列表&#x27;</span>, <span class="attr">icon</span>: <span class="string">&#x27;table&#x27;</span> &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      path: <span class="string">&#x27;edit/:id&#x27;</span>,</span><br><span class="line">      name: <span class="string">&#x27;EduTeacherEdit&#x27;</span>,</span><br><span class="line">      component: <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&#x27;@/views/edu/teacher/save&#x27;</span>),</span><br><span class="line">      meta: &#123; <span class="attr">title</span>: <span class="string">&#x27;编辑讲师&#x27;</span>, <span class="attr">noCache</span>: <span class="literal">true</span> &#125;,</span><br><span class="line">      hidden: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<h3 id="1-2-创建路由对应的页面"><a href="#1-2-创建路由对应的页面" class="headerlink" title="1.2 创建路由对应的页面"></a>1.2 创建路由对应的页面</h3><p>在views/edu/teacher下创建讲师列表页面list.vue</p>
<h3 id="1-3-定义访问的接口地址"><a href="#1-3-定义访问的接口地址" class="headerlink" title="1.3 定义访问的接口地址"></a>1.3 定义访问的接口地址</h3><p>在src/api/edu/teacher.js下</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1、讲师列表（条件查询分页）</span></span><br><span class="line"><span class="comment">//current当前页 limit每页记录数 teacherQuery条件对象</span></span><br><span class="line"><span class="function"><span class="title">getTeacherListPage</span>(<span class="params">current, limit, teacherQuery</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> request(&#123;</span><br><span class="line">        url: <span class="string">`/eduservice/teacher/pageTeacherCondition/<span class="subst">$&#123;current&#125;</span>/<span class="subst">$&#123;limit&#125;</span>`</span>,</span><br><span class="line">        method: <span class="string">&#x27;post&#x27;</span>,</span><br><span class="line">        <span class="comment">//teacherQuery条件对象，后端使用RequetBody获取数据</span></span><br><span class="line">        <span class="comment">//data表示把对象转换成json进行传递到接口里面</span></span><br><span class="line">        data: teacherQuery</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<h3 id="1-4-调用接口得到数据"><a href="#1-4-调用接口得到数据" class="headerlink" title="1.4 调用接口得到数据"></a>1.4 调用接口得到数据</h3><p>在list.vue讲师列表页面调用定义的接口的方法，得到接口返回的数据</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line"><span class="comment">//引入teacher.js文件</span></span><br><span class="line"><span class="keyword">import</span> teacher <span class="keyword">from</span> <span class="string">&quot;@/api/edu/teacher&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="comment">//写核心代码的位置</span></span><br><span class="line">  <span class="function"><span class="title">data</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="comment">//定义变量和初始值</span></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      list: <span class="literal">null</span>, <span class="comment">//查询之后接口返回集合</span></span><br><span class="line">      page: <span class="number">1</span>, <span class="comment">//当前页</span></span><br><span class="line">      limit: <span class="number">10</span>, <span class="comment">//每页记录数</span></span><br><span class="line">      total: <span class="number">0</span>, <span class="comment">//总记录数</span></span><br><span class="line">      teacherQuery: &#123;&#125;, <span class="comment">//条件封装对象</span></span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">created</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="comment">//在页面渲染之前执行，一般调用methods定义的方法</span></span><br><span class="line">    <span class="comment">//调用</span></span><br><span class="line">    <span class="built_in">this</span>.getList();</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    <span class="comment">//创建具体的方法，调用teacher.js定义的方法</span></span><br><span class="line">    <span class="comment">//讲师列表的方法</span></span><br><span class="line">    <span class="function"><span class="title">getList</span>(<span class="params">page = <span class="number">1</span></span>)</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.page = page;</span><br><span class="line">      teacher</span><br><span class="line">        .getTeacherListPage(<span class="built_in">this</span>.page, <span class="built_in">this</span>.limit, <span class="built_in">this</span>.teacherQuery)</span><br><span class="line">        .then(<span class="function">(<span class="params">response</span>) =&gt;</span> &#123;</span><br><span class="line">          <span class="comment">//response接口返回的数据</span></span><br><span class="line">          <span class="comment">// console.log(response)</span></span><br><span class="line">          <span class="built_in">this</span>.list = response.data.rows;</span><br><span class="line">          <span class="built_in">this</span>.total = response.data.total;</span><br><span class="line">          <span class="built_in">console</span>.log(<span class="built_in">this</span>.list);</span><br><span class="line">          <span class="built_in">console</span>.log(<span class="built_in">this</span>.total);</span><br><span class="line">        &#125;); <span class="comment">//表示成功</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="title">resetData</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="comment">//清空的方法</span></span><br><span class="line">      <span class="comment">//1、表单输入项的数据的清空</span></span><br><span class="line">      <span class="built_in">this</span>.teacherQuery = &#123;&#125;;</span><br><span class="line">      <span class="comment">//2、查询所有讲师</span></span><br><span class="line">      <span class="built_in">this</span>.getList();</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<h3 id="1-5-页面显示"><a href="#1-5-页面显示" class="headerlink" title="1.5 页面显示"></a>1.5 页面显示</h3><p>把请求接口获取到的数据在页面进行显示，使用element-ui实现</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class&#x3D;&quot;app-container&quot;&gt;</span><br><span class="line">    &lt;!--查询表单--&gt;</span><br><span class="line">    &lt;el-form :inline&#x3D;&quot;true&quot; class&#x3D;&quot;demo-form-inline&quot;&gt;</span><br><span class="line">      &lt;el-form-item&gt;</span><br><span class="line">        &lt;el-input v-model&#x3D;&quot;teacherQuery.name&quot; placeholder&#x3D;&quot;讲师名&quot; &#x2F;&gt;</span><br><span class="line">      &lt;&#x2F;el-form-item&gt;</span><br><span class="line"></span><br><span class="line">      &lt;el-form-item&gt;</span><br><span class="line">        &lt;el-select</span><br><span class="line">          v-model&#x3D;&quot;teacherQuery.level&quot;</span><br><span class="line">          clearable</span><br><span class="line">          placeholder&#x3D;&quot;讲师头衔&quot;</span><br><span class="line">        &gt;</span><br><span class="line">          &lt;el-option :value&#x3D;&quot;1&quot; label&#x3D;&quot;高级讲师&quot; &#x2F;&gt;</span><br><span class="line">          &lt;el-option :value&#x3D;&quot;2&quot; label&#x3D;&quot;首席讲师&quot; &#x2F;&gt;</span><br><span class="line">        &lt;&#x2F;el-select&gt;</span><br><span class="line">      &lt;&#x2F;el-form-item&gt;</span><br><span class="line"></span><br><span class="line">      &lt;el-form-item label&#x3D;&quot;添加时间&quot;&gt;</span><br><span class="line">        &lt;el-date-picker</span><br><span class="line">          v-model&#x3D;&quot;teacherQuery.begin&quot;</span><br><span class="line">          type&#x3D;&quot;datetime&quot;</span><br><span class="line">          placeholder&#x3D;&quot;选择开始时间&quot;</span><br><span class="line">          value-format&#x3D;&quot;yyyy-MM-dd HH:mm:ss&quot;</span><br><span class="line">          default-time&#x3D;&quot;00:00:00&quot;</span><br><span class="line">        &#x2F;&gt;</span><br><span class="line">      &lt;&#x2F;el-form-item&gt;</span><br><span class="line">      &lt;el-form-item&gt;</span><br><span class="line">        &lt;el-date-picker</span><br><span class="line">          v-model&#x3D;&quot;teacherQuery.end&quot;</span><br><span class="line">          type&#x3D;&quot;datetime&quot;</span><br><span class="line">          placeholder&#x3D;&quot;选择截止时间&quot;</span><br><span class="line">          value-format&#x3D;&quot;yyyy-MM-dd HH:mm:ss&quot;</span><br><span class="line">          default-time&#x3D;&quot;00:00:00&quot;</span><br><span class="line">        &#x2F;&gt;</span><br><span class="line">      &lt;&#x2F;el-form-item&gt;</span><br><span class="line"></span><br><span class="line">      &lt;el-button type&#x3D;&quot;primary&quot; icon&#x3D;&quot;el-icon-search&quot; @click&#x3D;&quot;getList()&quot;</span><br><span class="line">        &gt;查询&lt;&#x2F;el-button</span><br><span class="line">      &gt;</span><br><span class="line">      &lt;el-button type&#x3D;&quot;default&quot; @click&#x3D;&quot;resetData()&quot;&gt;清空&lt;&#x2F;el-button&gt;</span><br><span class="line">    &lt;&#x2F;el-form&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 表格 --&gt;</span><br><span class="line">    &lt;el-table :data&#x3D;&quot;list&quot; border fit highlight-current-row&gt;</span><br><span class="line">      &lt;el-table-column label&#x3D;&quot;序号&quot; width&#x3D;&quot;70&quot; align&#x3D;&quot;center&quot;&gt;</span><br><span class="line">        &lt;template slot-scope&#x3D;&quot;scope&quot;&gt;</span><br><span class="line">          &#123;&#123; (page - 1) * limit + scope.$index + 1 &#125;&#125;</span><br><span class="line">        &lt;&#x2F;template&gt;</span><br><span class="line">      &lt;&#x2F;el-table-column&gt;</span><br><span class="line"></span><br><span class="line">      &lt;el-table-column prop&#x3D;&quot;name&quot; label&#x3D;&quot;名称&quot; width&#x3D;&quot;80&quot; &#x2F;&gt;</span><br><span class="line"></span><br><span class="line">      &lt;el-table-column label&#x3D;&quot;头衔&quot; width&#x3D;&quot;80&quot;&gt;</span><br><span class="line">        &lt;template slot-scope&#x3D;&quot;scope&quot;&gt;</span><br><span class="line">          &#123;&#123; scope.row.level &#x3D;&#x3D;&#x3D; 1 ? &quot;高级讲师&quot; : &quot;首席讲师&quot; &#125;&#125;</span><br><span class="line">        &lt;&#x2F;template&gt;</span><br><span class="line">      &lt;&#x2F;el-table-column&gt;</span><br><span class="line"></span><br><span class="line">      &lt;el-table-column prop&#x3D;&quot;intro&quot; label&#x3D;&quot;资历&quot; &#x2F;&gt;</span><br><span class="line"></span><br><span class="line">      &lt;el-table-column prop&#x3D;&quot;gmtCreate&quot; label&#x3D;&quot;添加时间&quot; width&#x3D;&quot;160&quot; &#x2F;&gt;</span><br><span class="line"></span><br><span class="line">      &lt;el-table-column prop&#x3D;&quot;sort&quot; label&#x3D;&quot;排序&quot; width&#x3D;&quot;60&quot; &#x2F;&gt;</span><br><span class="line"></span><br><span class="line">      &lt;el-table-column label&#x3D;&quot;操作&quot; width&#x3D;&quot;200&quot; align&#x3D;&quot;center&quot;&gt;</span><br><span class="line">        &lt;template slot-scope&#x3D;&quot;scope&quot;&gt;</span><br><span class="line">          &lt;router-link :to&#x3D;&quot;&#39;&#x2F;teacher&#x2F;edit&#x2F;&#39; + scope.row.id&quot;&gt;</span><br><span class="line">            &lt;el-button type&#x3D;&quot;primary&quot; size&#x3D;&quot;mini&quot; icon&#x3D;&quot;el-icon-edit&quot;</span><br><span class="line">              &gt;修改&lt;&#x2F;el-button</span><br><span class="line">            &gt;</span><br><span class="line">          &lt;&#x2F;router-link&gt;</span><br><span class="line">          &lt;el-button</span><br><span class="line">            type&#x3D;&quot;danger&quot;</span><br><span class="line">            size&#x3D;&quot;mini&quot;</span><br><span class="line">            icon&#x3D;&quot;el-icon-delete&quot;</span><br><span class="line">            @click&#x3D;&quot;removeDataById(scope.row.id)&quot;</span><br><span class="line">            &gt;删除&lt;&#x2F;el-button</span><br><span class="line">          &gt;</span><br><span class="line">        &lt;&#x2F;template&gt;</span><br><span class="line">      &lt;&#x2F;el-table-column&gt;</span><br><span class="line">    &lt;&#x2F;el-table&gt;</span><br><span class="line">    &lt;!-- 分页 --&gt;</span><br><span class="line">    &lt;el-pagination</span><br><span class="line">      :current-page&#x3D;&quot;page&quot;</span><br><span class="line">      :page-size&#x3D;&quot;limit&quot;</span><br><span class="line">      :total&#x3D;&quot;total&quot;</span><br><span class="line">      style&#x3D;&quot;padding: 30px 0; text-align: center&quot;</span><br><span class="line">      layout&#x3D;&quot;total, prev, pager, next, jumper&quot;</span><br><span class="line">      @current-change&#x3D;&quot;getList&quot;</span><br><span class="line">    &#x2F;&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br></pre></td></tr></table></figure>

<h2 id="2-讲师删除"><a href="#2-讲师删除" class="headerlink" title="2. 讲师删除"></a>2. 讲师删除</h2><h3 id="2-1-添加按钮"><a href="#2-1-添加按钮" class="headerlink" title="2.1 添加按钮"></a>2.1 添加按钮</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;el-table-column label&#x3D;&quot;操作&quot; width&#x3D;&quot;200&quot; align&#x3D;&quot;center&quot;&gt;</span><br><span class="line">    &lt;template slot-scope&#x3D;&quot;scope&quot;&gt;</span><br><span class="line">		&lt;router-link :to&#x3D;&quot;&#39;&#x2F;teacher&#x2F;edit&#x2F;&#39; + scope.row.id&quot;&gt;</span><br><span class="line">    		&lt;el-button type&#x3D;&quot;primary&quot; size&#x3D;&quot;mini&quot; icon&#x3D;&quot;el-icon-edit&quot;&gt;修改&lt;&#x2F;el-button&gt;</span><br><span class="line">        &lt;&#x2F;router-link&gt;</span><br><span class="line">		&lt;el-button type&#x3D;&quot;danger&quot;</span><br><span class="line">           size&#x3D;&quot;mini&quot;</span><br><span class="line">           icon&#x3D;&quot;el-icon-delete&quot;</span><br><span class="line">           @click&#x3D;&quot;removeDataById(scope.row.id)&quot;&gt;删除&lt;&#x2F;el-button&gt;</span><br><span class="line">    &lt;&#x2F;template&gt;</span><br><span class="line">&lt;&#x2F;el-table-column&gt;</span><br></pre></td></tr></table></figure>

<h3 id="2-2-在按钮上绑定事件"><a href="#2-2-在按钮上绑定事件" class="headerlink" title="2.2 在按钮上绑定事件"></a>2.2 在按钮上绑定事件</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">@click=<span class="string">&quot;removeDataById&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="2-3-在绑定事件的方法传递删除讲师"><a href="#2-3-在绑定事件的方法传递删除讲师" class="headerlink" title="2.3 在绑定事件的方法传递删除讲师"></a>2.3 在绑定事件的方法传递删除讲师</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">@click=<span class="string">&quot;removeDataById(scope.row.id)&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="2-4-定义接口的地址"><a href="#2-4-定义接口的地址" class="headerlink" title="2.4 定义接口的地址"></a>2.4 定义接口的地址</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//删除讲师</span></span><br><span class="line"><span class="function"><span class="title">deleteTeacherById</span>(<span class="params">id</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> request(&#123;</span><br><span class="line">        url: <span class="string">`/eduservice/teacher/<span class="subst">$&#123;id&#125;</span>`</span>,</span><br><span class="line">        method: <span class="string">&#x27;delete&#x27;</span>,</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<h3 id="2-5-页面调用方法，实现删除"><a href="#2-5-页面调用方法，实现删除" class="headerlink" title="2.5 页面调用方法，实现删除"></a>2.5 页面调用方法，实现删除</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//删除讲师的方法</span></span><br><span class="line"><span class="function"><span class="title">removeDataById</span>(<span class="params">id</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.$confirm(<span class="string">&quot;此操作将永久删除讲师记录, 是否继续?&quot;</span>, <span class="string">&quot;提示&quot;</span>, &#123;</span><br><span class="line">        confirmButtonText: <span class="string">&quot;确定&quot;</span>,</span><br><span class="line">        cancelButtonText: <span class="string">&quot;取消&quot;</span>,</span><br><span class="line">        type: <span class="string">&quot;warning&quot;</span>,</span><br><span class="line">    &#125;).then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">//点击确定，执行then方法</span></span><br><span class="line">        <span class="comment">//调用删除的方法</span></span><br><span class="line">        teacher.deleteTeacherById(id).then(<span class="function">(<span class="params">response</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="comment">//删除成功</span></span><br><span class="line">            <span class="comment">//提示信息</span></span><br><span class="line">            <span class="built_in">this</span>.$message(&#123;</span><br><span class="line">                type: <span class="string">&quot;success&quot;</span>,</span><br><span class="line">                message: <span class="string">&quot;删除成功!&quot;</span>,</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="comment">//回到列表页面</span></span><br><span class="line">            <span class="built_in">this</span>.getList();</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<h2 id="3-添加讲师"><a href="#3-添加讲师" class="headerlink" title="3. 添加讲师"></a>3. 添加讲师</h2><h3 id="3-1-添加路由"><a href="#3-1-添加路由" class="headerlink" title="3.1 添加路由"></a>3.1 添加路由</h3><p>在src/router/index.js下添加路由</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    path: <span class="string">&#x27;save&#x27;</span>,</span><br><span class="line">    name: <span class="string">&#x27;添加讲师&#x27;</span>,</span><br><span class="line">    component: <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&#x27;@/views/edu/teacher/save&#x27;</span>),</span><br><span class="line">    meta: &#123; <span class="attr">title</span>: <span class="string">&#x27;添加讲师&#x27;</span>, <span class="attr">icon</span>: <span class="string">&#x27;tree&#x27;</span> &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<h3 id="3-2-创建路由对应的页面"><a href="#3-2-创建路由对应的页面" class="headerlink" title="3.2 创建路由对应的页面"></a>3.2 创建路由对应的页面</h3><p>在views/edu/teacher下创建讲师列表页面save.vue</p>
<h3 id="3-3-定义访问的接口地址"><a href="#3-3-定义访问的接口地址" class="headerlink" title="3.3 定义访问的接口地址"></a>3.3 定义访问的接口地址</h3><p>在src/api/edu/teacher.js下</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//添加讲师</span></span><br><span class="line"><span class="function"><span class="title">addTeacher</span>(<span class="params">teacher</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> request(&#123;</span><br><span class="line">        url: <span class="string">`/eduservice/teacher/addTeacher`</span>,</span><br><span class="line">        method: <span class="string">&#x27;post&#x27;</span>,</span><br><span class="line">        data: teacher</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<h3 id="3-4-调用接口得到数据"><a href="#3-4-调用接口得到数据" class="headerlink" title="3.4 调用接口得到数据"></a>3.4 调用接口得到数据</h3><p>在save.vue讲师列表页面调用定义的接口的方法，得到接口返回的数据</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">import</span> teacherApi <span class="keyword">from</span> <span class="string">&quot;@/api/edu/teacher&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> ImageCropper <span class="keyword">from</span> <span class="string">&quot;@/components/ImageCropper&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> PanThumb <span class="keyword">from</span> <span class="string">&quot;@/components/PanThumb&quot;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  components: &#123; ImageCropper, PanThumb &#125;,</span><br><span class="line">  <span class="function"><span class="title">data</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      teacher: &#123;</span><br><span class="line">        name: <span class="string">&quot;&quot;</span>,</span><br><span class="line">        sort: <span class="string">&quot;&quot;</span>,</span><br><span class="line">        level: <span class="number">1</span>,</span><br><span class="line">        career: <span class="string">&quot;&quot;</span>,</span><br><span class="line">        intro: <span class="string">&quot;&quot;</span>,</span><br><span class="line">        avatar: <span class="string">&quot;&quot;</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="comment">//上传弹框组件是否显示</span></span><br><span class="line">      imagecropperShow: <span class="literal">false</span>,</span><br><span class="line">      imagecropperKey: <span class="number">0</span>, <span class="comment">//上传组件的唯一标识</span></span><br><span class="line">      BASE_API: process.env.BASE_API, <span class="comment">//获取地址</span></span><br><span class="line">      saveBtnDisabled: <span class="literal">false</span>, <span class="comment">//保存按钮是否禁用</span></span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">created</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.init();</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">//监听</span></span><br><span class="line">  watch: &#123;</span><br><span class="line">    <span class="comment">//路由变化的方式，当路由发生变化，方法就会执行</span></span><br><span class="line">    $route(to, <span class="keyword">from</span>) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&quot;watch $route&quot;</span>);</span><br><span class="line">      <span class="built_in">this</span>.init();</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    <span class="comment">//关闭上传弹窗的方法</span></span><br><span class="line">    <span class="function"><span class="title">close</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.imagecropperShow = <span class="literal">false</span>;</span><br><span class="line">      <span class="comment">//上传组件初始化</span></span><br><span class="line">      <span class="built_in">this</span>.imagecropperKey = <span class="built_in">this</span>.imagecropperKey + <span class="number">1</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">//上传成功的方法</span></span><br><span class="line">    <span class="function"><span class="title">cropSuccess</span>(<span class="params">data</span>)</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.imagecropperShow = <span class="literal">false</span>;</span><br><span class="line">      <span class="comment">//上传成功之后返回图片的地址</span></span><br><span class="line">      <span class="built_in">this</span>.teacher.avatar = data.url;</span><br><span class="line">      <span class="built_in">this</span>.imagecropperKey = <span class="built_in">this</span>.imagecropperKey + <span class="number">1</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="title">init</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="comment">//判断路径有id值，做修改</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">this</span>.$route.params &amp;&amp; <span class="built_in">this</span>.$route.params.id) &#123;</span><br><span class="line">        <span class="comment">//从路径获取id值</span></span><br><span class="line">        <span class="keyword">const</span> id = <span class="built_in">this</span>.$route.params.id;</span><br><span class="line">        <span class="comment">//调用根据id查询的方法</span></span><br><span class="line">        <span class="built_in">this</span>.getInfo(id);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//路径没有id值，做添加</span></span><br><span class="line">        <span class="comment">//清空表单</span></span><br><span class="line">        <span class="built_in">this</span>.teacher = &#123;&#125;;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">//数据回显</span></span><br><span class="line">    <span class="function"><span class="title">getInfo</span>(<span class="params">id</span>)</span> &#123;</span><br><span class="line">      teacherApi.getTeacherInfo(id).then(<span class="function">(<span class="params">response</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.teacher = response.data.teacher;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="title">saveOrUpdate</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="comment">//判断修改还是添加</span></span><br><span class="line">      <span class="keyword">if</span> (!<span class="built_in">this</span>.teacher.id) &#123;</span><br><span class="line">        <span class="comment">//添加</span></span><br><span class="line">        <span class="built_in">this</span>.saveTeacher();</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//修改</span></span><br><span class="line">        <span class="built_in">this</span>.updateTeacher();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">//添加讲师的方法</span></span><br><span class="line">    <span class="function"><span class="title">saveTeacher</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      teacherApi.addTeacher(<span class="built_in">this</span>.teacher).then(<span class="function">(<span class="params">response</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">//提示成功信息</span></span><br><span class="line">        <span class="built_in">this</span>.$message(&#123;</span><br><span class="line">          type: <span class="string">&quot;success&quot;</span>,</span><br><span class="line">          message: <span class="string">&quot;添加成功！&quot;</span>,</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">//回到列表页面 路由跳转</span></span><br><span class="line">        <span class="built_in">this</span>.$router.push(&#123; <span class="attr">path</span>: <span class="string">&quot;/teacher/table&quot;</span> &#125;);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">//修改讲师的方法</span></span><br><span class="line">    <span class="function"><span class="title">updateTeacher</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      teacherApi.updataTeacherInfo(<span class="built_in">this</span>.teacher).then(<span class="function">(<span class="params">response</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.$message(&#123;</span><br><span class="line">          type: <span class="string">&quot;success&quot;</span>,</span><br><span class="line">          message: <span class="string">&quot;修改成功！&quot;</span>,</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="built_in">this</span>.$router.push(&#123; <span class="attr">path</span>: <span class="string">&quot;/teacher/table&quot;</span> &#125;);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<h3 id="3-5-添加成功之后跳转到讲师列表页面"><a href="#3-5-添加成功之后跳转到讲师列表页面" class="headerlink" title="3.5 添加成功之后跳转到讲师列表页面"></a>3.5 添加成功之后跳转到讲师列表页面</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//回到列表页面 路由跳转</span></span><br><span class="line"><span class="built_in">this</span>.$router.push(&#123; <span class="attr">path</span>: <span class="string">&quot;/teacher/table&quot;</span> &#125;);</span><br></pre></td></tr></table></figure>

<h2 id="4-修改讲师"><a href="#4-修改讲师" class="headerlink" title="4. 修改讲师"></a>4. 修改讲师</h2><h3 id="4-1-每条记录后面添加修改按钮"><a href="#4-1-每条记录后面添加修改按钮" class="headerlink" title="4.1 每条记录后面添加修改按钮"></a>4.1 每条记录后面添加修改按钮</h3><h3 id="4-2-点击修改按钮，进入表单页面，进行数据回显"><a href="#4-2-点击修改按钮，进入表单页面，进行数据回显" class="headerlink" title="4.2 点击修改按钮，进入表单页面，进行数据回显"></a>4.2 点击修改按钮，进入表单页面，进行数据回显</h3><p>根据讲师id查询数据并进行数据回显</p>
<h3 id="4-3-通过路由跳转进入数据回显页面，在路由index页面添加路由"><a href="#4-3-通过路由跳转进入数据回显页面，在路由index页面添加路由" class="headerlink" title="4.3 通过路由跳转进入数据回显页面，在路由index页面添加路由"></a>4.3 通过路由跳转进入数据回显页面，在路由index页面添加路由</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    path: <span class="string">&#x27;edit/:id&#x27;</span>,</span><br><span class="line">    name: <span class="string">&#x27;EduTeacherEdit&#x27;</span>,</span><br><span class="line">    component: <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&#x27;@/views/edu/teacher/save&#x27;</span>),</span><br><span class="line">    meta: &#123; <span class="attr">title</span>: <span class="string">&#x27;编辑讲师&#x27;</span>, <span class="attr">noCache</span>: <span class="literal">true</span> &#125;,</span><br><span class="line">    hidden: <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-4-在表单页面中实现数据回显"><a href="#4-4-在表单页面中实现数据回显" class="headerlink" title="4.4 在表单页面中实现数据回显"></a>4.4 在表单页面中实现数据回显</h3><p>（1）在teacher.js中定义根据id查询接口</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//根据id查询讲师信息</span></span><br><span class="line"><span class="function"><span class="title">getTeacherInfo</span>(<span class="params">id</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> request(&#123;</span><br><span class="line">        url: <span class="string">`/eduservice/teacher/getTeacher/<span class="subst">$&#123;id&#125;</span>`</span>,</span><br><span class="line">        method: <span class="string">&#x27;get&#x27;</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<p>（2）在页面调用接口实现数据回显</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//数据回显</span></span><br><span class="line"><span class="function"><span class="title">getInfo</span>(<span class="params">id</span>)</span> &#123;</span><br><span class="line">    teacherApi.getTeacherInfo(id).then(<span class="function">(<span class="params">response</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.teacher = response.data.teacher;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<p>（3）调用根据id查询讲师信息的方法</p>
<p>因为添加和修改都使用save.vue页面，所以需要区别添加和修改，只有在修改的时候才会查询数据进行回显</p>
<p>如何判断查询和修改？</p>
<p>判断路径里面是否有讲师id值，如果有id值则是修改，没有id值就是添加</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//判断路径有id值，做修改</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">this</span>.$route.params &amp;&amp; <span class="built_in">this</span>.$route.params.id) &#123;</span><br><span class="line">    <span class="comment">//从路径获取id值</span></span><br><span class="line">    <span class="keyword">const</span> id = <span class="built_in">this</span>.$route.params.id;</span><br><span class="line">    <span class="comment">//调用根据id查询的方法</span></span><br><span class="line">    <span class="built_in">this</span>.getInfo(id);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//路径没有id值，做添加</span></span><br><span class="line">    <span class="comment">//清空表单</span></span><br><span class="line">    <span class="built_in">this</span>.teacher = &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-5-在src-api-edu-teacher-js里面定义修改的接口"><a href="#4-5-在src-api-edu-teacher-js里面定义修改的接口" class="headerlink" title="4.5 在src/api/edu/teacher.js里面定义修改的接口"></a>4.5 在src/api/edu/teacher.js里面定义修改的接口</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//修改讲师</span></span><br><span class="line"><span class="function"><span class="title">updataTeacherInfo</span>(<span class="params">teacher</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> request(&#123;</span><br><span class="line">        url: <span class="string">`/eduservice/teacher/updateTeacher`</span>,</span><br><span class="line">        method: <span class="string">&#x27;post&#x27;</span>,</span><br><span class="line">        data: teacher</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-6-在页面中调用接口"><a href="#4-6-在页面中调用接口" class="headerlink" title="4.6 在页面中调用接口"></a>4.6 在页面中调用接口</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//修改讲师的方法</span></span><br><span class="line"><span class="function"><span class="title">updateTeacher</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    teacherApi.updataTeacherInfo(<span class="built_in">this</span>.teacher).then(<span class="function">(<span class="params">response</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.$message(&#123;</span><br><span class="line">            type: <span class="string">&quot;success&quot;</span>,</span><br><span class="line">            message: <span class="string">&quot;修改成功！&quot;</span>,</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="built_in">this</span>.$router.push(&#123; <span class="attr">path</span>: <span class="string">&quot;/teacher/table&quot;</span> &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<h3 id="4-7-判断是添加还是修改"><a href="#4-7-判断是添加还是修改" class="headerlink" title="4.7 判断是添加还是修改"></a>4.7 判断是添加还是修改</h3><p>在修改完成之后，由于所点击的“保存”按钮同时做了添加和修改两个功能，所以需要判断是添加还是修改</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">saveOrUpdate</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="comment">//判断修改还是添加</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">this</span>.teacher.id) &#123;</span><br><span class="line">        <span class="comment">//添加</span></span><br><span class="line">        <span class="built_in">this</span>.saveTeacher();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//修改</span></span><br><span class="line">        <span class="built_in">this</span>.updateTeacher();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<h2 id="5-可能会遇到的问题？"><a href="#5-可能会遇到的问题？" class="headerlink" title="5. 可能会遇到的问题？"></a>5. 可能会遇到的问题？</h2><p><img src="https://rulerofterabithia-blog.oss-cn-hangzhou.aliyuncs.com/img/20220524193635.png"></p>
<h1 id="阿里云OSS"><a href="#阿里云OSS" class="headerlink" title="阿里云OSS"></a>阿里云OSS</h1><h2 id="1-搭建阿里云oss操作项目环境"><a href="#1-搭建阿里云oss操作项目环境" class="headerlink" title="1. 搭建阿里云oss操作项目环境"></a>1. 搭建阿里云oss操作项目环境</h2><p><img src="https://rulerofterabithia-blog.oss-cn-hangzhou.aliyuncs.com/img/20220524193722.png"></p>
<h2 id="2-读取配置文件中的配置信息"><a href="#2-读取配置文件中的配置信息" class="headerlink" title="2. 读取配置文件中的配置信息"></a>2. 读取配置文件中的配置信息</h2><p>编写工具类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConstantPropertiesUtils</span> <span class="keyword">implements</span> <span class="title">InitializingBean</span> </span>&#123;</span><br><span class="line">    <span class="comment">//读取配置文件的内容</span></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;aliyun.oss.file.endpoint&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String endpoint;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;aliyun.oss.file.keyid&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String keyId;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;aliyun.oss.file.keysecret&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String keySecret;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;aliyun.oss.file.bucketname&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String bucketName;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义公开静态常量</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String END_POINT;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String ACCESS_KEY_ID;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String ACCESS_KEY_SECRET;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String BUCKET_NAME;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 项目启动后，在属性交由Spring管理之后，该方法执行</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        END_POINT = endpoint;</span><br><span class="line">        ACCESS_KEY_ID = keyId;</span><br><span class="line">        ACCESS_KEY_SECRET = keySecret;</span><br><span class="line">        BUCKET_NAME = bucketName;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-创建controller，创建service"><a href="#3-创建controller，创建service" class="headerlink" title="3. 创建controller，创建service"></a>3. 创建controller，创建service</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/eduoss/fileoss&quot;)</span></span><br><span class="line"><span class="meta">@CrossOrigin</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OssController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    OssService ossService;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//上传头像的方法</span></span><br><span class="line">    <span class="meta">@PostMapping</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> R <span class="title">uploadOssFile</span><span class="params">(MultipartFile file)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//获取上传文件  MultipartFile</span></span><br><span class="line">        <span class="comment">//返回上传到oss的路径</span></span><br><span class="line">        String url = ossService.uploadFileAvatar(file);</span><br><span class="line">        <span class="keyword">return</span> R.ok().data(<span class="string">&quot;url&quot;</span>, url);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-在service中实现上传文件到oss的过程"><a href="#4-在service中实现上传文件到oss的过程" class="headerlink" title="4. 在service中实现上传文件到oss的过程"></a>4. 在service中实现上传文件到oss的过程</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">OssService</span> </span>&#123;</span><br><span class="line">    <span class="comment">//上传头像到OSS</span></span><br><span class="line">    <span class="function">String <span class="title">uploadFileAvatar</span><span class="params">(MultipartFile file)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OssServiceImpl</span> <span class="keyword">implements</span> <span class="title">OssService</span> </span>&#123;</span><br><span class="line">    <span class="comment">//上传头像到OSS</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">uploadFileAvatar</span><span class="params">(MultipartFile file)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//工具类获取值</span></span><br><span class="line">        <span class="comment">// yourEndpoint填写Bucket所在地域对应的Endpoint</span></span><br><span class="line">        String endpoint = ConstantPropertiesUtils.END_POINT;</span><br><span class="line">        <span class="comment">// 阿里云账号AccessKey拥有所有API的访问权限，风险很高。强烈建议您创建并使用RAM用户进行API访问或日常运维，请登录RAM控制台创建RAM用户</span></span><br><span class="line">        String accessKeyId = ConstantPropertiesUtils.ACCESS_KEY_ID;</span><br><span class="line">        String accessKeySecret = ConstantPropertiesUtils.ACCESS_KEY_SECRET;</span><br><span class="line">        String bucketName = ConstantPropertiesUtils.BUCKET_NAME;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 创建OSSClient实例</span></span><br><span class="line">            OSS ossClient = <span class="keyword">new</span> OSSClientBuilder().build(endpoint, accessKeyId, accessKeySecret);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//获取上传文件输入流</span></span><br><span class="line">            InputStream inputStream = file.getInputStream();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//获取文件名称</span></span><br><span class="line">            String filename = file.getOriginalFilename();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//在文件名称里面添加随机唯一的值</span></span><br><span class="line">            String uuid = UUID.randomUUID().toString().replaceAll(<span class="string">&quot;-&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">            filename = uuid + filename;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//把文件按照日期分类</span></span><br><span class="line">            String datePath = <span class="keyword">new</span> DateTime().toString(<span class="string">&quot;yyyy/MM/dd&quot;</span>);</span><br><span class="line">            filename = datePath + <span class="string">&quot;/&quot;</span> + filename;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//调用OSS方法实现上传</span></span><br><span class="line">            <span class="comment">//第一个参数 Bucket名称</span></span><br><span class="line">            <span class="comment">//第二个参数 上传到OSS文件路径和文件名称</span></span><br><span class="line">            <span class="comment">//第三个参数 上传文件的输入流</span></span><br><span class="line">            ossClient.putObject(bucketName, filename, inputStream);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 关闭OSSClient</span></span><br><span class="line">            ossClient.shutdown();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//把上传之后的文件路径返回</span></span><br><span class="line">            String url = <span class="string">&quot;https://&quot;</span> + bucketName + <span class="string">&quot;.&quot;</span> + endpoint + <span class="string">&quot;/&quot;</span> + filename;</span><br><span class="line">            <span class="keyword">return</span> url;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment">#可以在配置文件里面配置单个文件最大大小 spring.servlet.multipart.max-file-size=10MB</span></span><br></pre></td></tr></table></figure>

<h2 id="5-文件名称添加随机唯一值"><a href="#5-文件名称添加随机唯一值" class="headerlink" title="5. 文件名称添加随机唯一值"></a>5. 文件名称添加随机唯一值</h2><p>多次上传相同名称的文件，会造成最后一次上传的文件把之前上传的文件覆盖掉</p>
<p>解决方案？在文件名称添加随机唯一值，让每个文件名称不同</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在文件名称里面添加随机唯一的值</span></span><br><span class="line">String uuid = UUID.randomUUID().toString().replaceAll(<span class="string">&quot;-&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">filename = uuid + filename;</span><br></pre></td></tr></table></figure>

<h2 id="6-把文件进行分类管理"><a href="#6-把文件进行分类管理" class="headerlink" title="6. 把文件进行分类管理"></a>6. 把文件进行分类管理</h2><p>根据日期进行分类，实现年月日分类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//把文件按照日期分类</span></span><br><span class="line">String datePath = <span class="keyword">new</span> DateTime().toString(<span class="string">&quot;yyyy/MM/dd&quot;</span>);</span><br><span class="line">filename = datePath + <span class="string">&quot;/&quot;</span> + filename;</span><br></pre></td></tr></table></figure>

<h1 id="nginx"><a href="#nginx" class="headerlink" title="nginx"></a>nginx</h1><h2 id="1-什么是nginx"><a href="#1-什么是nginx" class="headerlink" title="1. 什么是nginx?"></a>1. 什么是nginx?</h2><p>nginx是高性能的HTTP和反向代理的服务器，处理高并发能力是十分强大的，能经受高负载的考验，有报告表明能支持高达50,000个并发连接数。</p>
<h2 id="2-主要的功能"><a href="#2-主要的功能" class="headerlink" title="2. 主要的功能"></a>2. 主要的功能</h2><p>（1）请求转发</p>
<p>（2）负载均衡</p>
<p>（3）动静分离</p>
<h2 id="3-什么是请求转发？"><a href="#3-什么是请求转发？" class="headerlink" title="3. 什么是请求转发？"></a>3. 什么是请求转发？</h2><p><img src="https://rulerofterabithia-blog.oss-cn-hangzhou.aliyuncs.com/img/20220524193756.png"></p>
<h2 id="4-什么是负载均衡？"><a href="#4-什么是负载均衡？" class="headerlink" title="4. 什么是负载均衡？"></a>4. 什么是负载均衡？</h2><p><img src="https://rulerofterabithia-blog.oss-cn-hangzhou.aliyuncs.com/img/20220524193824.png"></p>
<h2 id="5-什么是动静分离？"><a href="#5-什么是动静分离？" class="headerlink" title="5. 什么是动静分离？"></a>5. 什么是动静分离？</h2><p><img src="https://rulerofterabithia-blog.oss-cn-hangzhou.aliyuncs.com/img/20220524193922.png"></p>
<h2 id="6-nginx配置请求转发"><a href="#6-nginx配置请求转发" class="headerlink" title="6. nginx配置请求转发"></a>6. nginx配置请求转发</h2><p><img src="https://rulerofterabithia-blog.oss-cn-hangzhou.aliyuncs.com/img/20220524193954.png"></p>
<h1 id="上传头像前端"><a href="#上传头像前端" class="headerlink" title="上传头像前端"></a>上传头像前端</h1><h2 id="1-创建上传组件"><a href="#1-创建上传组件" class="headerlink" title="1. 创建上传组件"></a>1. 创建上传组件</h2><p>在添加讲师页面，创建上传组件，实现上传，使用element-ui组件实现</p>
<h2 id="2-在添加讲师页面使用上传组件"><a href="#2-在添加讲师页面使用上传组件" class="headerlink" title="2. 在添加讲师页面使用上传组件"></a>2. 在添加讲师页面使用上传组件</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- 讲师头像 --&gt;</span><br><span class="line">&lt;el-form-item label&#x3D;&quot;讲师头像&quot;&gt;</span><br><span class="line">    &lt;!-- 头衔缩略图 --&gt;</span><br><span class="line">    &lt;pan-thumb :image&#x3D;&quot;teacher.avatar&quot; &#x2F;&gt;</span><br><span class="line">    &lt;!-- 文件上传按钮 --&gt;</span><br><span class="line">    &lt;el-button</span><br><span class="line">               type&#x3D;&quot;primary&quot;</span><br><span class="line">               icon&#x3D;&quot;el-icon-upload&quot;</span><br><span class="line">               @click&#x3D;&quot;imagecropperShow &#x3D; true&quot;</span><br><span class="line">               &gt;更换头像</span><br><span class="line">    &lt;&#x2F;el-button&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--</span><br><span class="line">		v-show：是否显示上传组件</span><br><span class="line">		:key：类似于id，如果一个页面多个图片上传控件，可以做区分</span><br><span class="line">		:url：后台上传的url地址</span><br><span class="line">		@close：关闭上传组件</span><br><span class="line">		@crop-upload-success：上传成功后的回调 </span><br><span class="line">		&lt;input type&#x3D;&quot;file&quot; name&#x3D;&quot;file&quot;&#x2F;&gt;</span><br><span class="line">	--&gt;</span><br><span class="line">    &lt;image-cropper</span><br><span class="line">                   v-show&#x3D;&quot;imagecropperShow&quot;</span><br><span class="line">                   :width&#x3D;&quot;300&quot;</span><br><span class="line">                   :height&#x3D;&quot;300&quot;</span><br><span class="line">                   :key&#x3D;&quot;imagecropperKey&quot;</span><br><span class="line">                   :url&#x3D;&quot;BASE_API + &#39;&#x2F;eduoss&#x2F;fileoss&#39;&quot;</span><br><span class="line">                   field&#x3D;&quot;file&quot;</span><br><span class="line">                   @close&#x3D;&quot;close&quot;</span><br><span class="line">                   @crop-upload-success&#x3D;&quot;cropSuccess&quot;</span><br><span class="line">                   &#x2F;&gt;</span><br><span class="line">&lt;&#x2F;el-form-item&gt;</span><br><span class="line"></span><br><span class="line">&lt;el-form-item&gt;</span><br><span class="line">    &lt;el-button</span><br><span class="line">               :disabled&#x3D;&quot;saveBtnDisabled&quot;</span><br><span class="line">               type&#x3D;&quot;primary&quot;</span><br><span class="line">               @click&#x3D;&quot;saveOrUpdate&quot;</span><br><span class="line">               &gt;保存&lt;&#x2F;el-button</span><br><span class="line">        &gt;</span><br><span class="line">&lt;&#x2F;el-form-item&gt;</span><br></pre></td></tr></table></figure>

<p>JavaScript方法</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//关闭上传弹窗的方法</span></span><br><span class="line"><span class="function"><span class="title">close</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.imagecropperShow = <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">//上传组件初始化，防止下次打开上传文件弹窗还是上一次的状态</span></span><br><span class="line">    <span class="built_in">this</span>.imagecropperKey = <span class="built_in">this</span>.imagecropperKey + <span class="number">1</span>;</span><br><span class="line">&#125;,</span><br><span class="line"><span class="comment">//上传成功的方法</span></span><br><span class="line"><span class="function"><span class="title">cropSuccess</span>(<span class="params">data</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.imagecropperShow = <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">//上传成功之后返回图片的地址</span></span><br><span class="line">    <span class="built_in">this</span>.teacher.avatar = data.url;</span><br><span class="line">    <span class="built_in">this</span>.imagecropperKey = <span class="built_in">this</span>.imagecropperKey + <span class="number">1</span>;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<h1 id="课程分类"><a href="#课程分类" class="headerlink" title="课程分类"></a>课程分类</h1><h2 id="1-课程分类存储结构"><a href="#1-课程分类存储结构" class="headerlink" title="1. 课程分类存储结构"></a>1. 课程分类存储结构</h2><p><img src="https://rulerofterabithia-blog.oss-cn-hangzhou.aliyuncs.com/img/20220524194027.png"></p>
<h2 id="2-什么是EasyExcel？"><a href="#2-什么是EasyExcel？" class="headerlink" title="2. 什么是EasyExcel？"></a>2. 什么是EasyExcel？</h2><p>EasyExcel是一个基于Java的简单、省内存的读写Excel的开源项目。在尽可能节约内存的情况下支持读写百M的Excel。</p>
<h2 id="3-创建实体类和excel对应关系"><a href="#3-创建实体类和excel对应关系" class="headerlink" title="3. 创建实体类和excel对应关系"></a>3. 创建实体类和excel对应关系</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SubjectData</span> </span>&#123;</span><br><span class="line">    <span class="meta">@ExcelProperty(index = 0)</span></span><br><span class="line">    <span class="keyword">private</span> String oneSubjectName;</span><br><span class="line">    <span class="meta">@ExcelProperty(index = 1)</span></span><br><span class="line">    <span class="keyword">private</span> String twoSubjectName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-添加课程分类"><a href="#4-添加课程分类" class="headerlink" title="4. 添加课程分类"></a>4. 添加课程分类</h2><p>通过EasyExcel，获取上传过来的文件，把文件内容读取出来</p>
<p>（1）EduSubjectController：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//添加课程分类</span></span><br><span class="line"><span class="comment">//获取上传过来的文件，把文件内容读取出来</span></span><br><span class="line"><span class="meta">@PostMapping(&quot;addSubject&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> R <span class="title">addSubject</span><span class="params">(MultipartFile file)</span> </span>&#123;</span><br><span class="line">    subjectService.saveSubject(file, subjectService);</span><br><span class="line">    <span class="keyword">return</span> R.ok();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（2）EduSubjectService：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//添加课程分类</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">saveSubject</span><span class="params">(MultipartFile file,EduSubjectService subjectService)</span></span>;</span><br></pre></td></tr></table></figure>

<p>（3）EduSubjectServiceImpl：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//添加课程分类</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveSubject</span><span class="params">(MultipartFile file, EduSubjectService subjectService)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//文件输入流</span></span><br><span class="line">        InputStream in = file.getInputStream();</span><br><span class="line">        <span class="comment">//调用方法进行读取</span></span><br><span class="line">        EasyExcel.read(in, SubjectData.class, <span class="keyword">new</span> SubjectExcelListener(subjectService)).sheet().doRead();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（4）监听器实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SubjectExcelListener</span> <span class="keyword">extends</span> <span class="title">AnalysisEventListener</span>&lt;<span class="title">SubjectData</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">//因为SubjectExcelListener不能交给Spring管理，需要自己new，不能注入其他对象</span></span><br><span class="line">    <span class="comment">//不能实现数据库操作</span></span><br><span class="line">    <span class="keyword">public</span> EduSubjectService subjectService;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SubjectExcelListener</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SubjectExcelListener</span><span class="params">(EduSubjectService subjectService)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.subjectService = subjectService;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">invoke</span><span class="params">(SubjectData subjectData, AnalysisContext analysisContext)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (subjectData == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> GuliException(<span class="number">20001</span>, <span class="string">&quot;文件数据为空&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//一行一行读取，每次读取有两个值，第一个值是一级分类，第二个值是二级分类</span></span><br><span class="line">        <span class="comment">//判断一级分类是否重复</span></span><br><span class="line">        EduSubject existOneSubject = <span class="keyword">this</span>.existOneSubject(subjectService, subjectData.getOneSubjectName());</span><br><span class="line">        <span class="keyword">if</span> (existOneSubject == <span class="keyword">null</span>) &#123;</span><br><span class="line">            existOneSubject = <span class="keyword">new</span> EduSubject();</span><br><span class="line">            existOneSubject.setParentId(<span class="string">&quot;0&quot;</span>);</span><br><span class="line">            existOneSubject.setTitle(subjectData.getOneSubjectName());</span><br><span class="line">            subjectService.save(existOneSubject);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//添加二级分类</span></span><br><span class="line">        <span class="comment">//判断二级分类是否重复</span></span><br><span class="line">        <span class="comment">//获取一级分类id值</span></span><br><span class="line">        String pid = existOneSubject.getId();</span><br><span class="line">        EduSubject existTwoSubject = <span class="keyword">this</span>.existTwoSubject(subjectService, subjectData.getOneSubjectName(), pid);</span><br><span class="line">        <span class="keyword">if</span> (existTwoSubject == <span class="keyword">null</span>) &#123;</span><br><span class="line">            existTwoSubject = <span class="keyword">new</span> EduSubject();</span><br><span class="line">            existTwoSubject.setParentId(pid);</span><br><span class="line">            existTwoSubject.setTitle(subjectData.getTwoSubjectName());</span><br><span class="line">            subjectService.save(existTwoSubject);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断一级分类不能重复添加</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> EduSubject <span class="title">existOneSubject</span><span class="params">(EduSubjectService subjectService, String name)</span> </span>&#123;</span><br><span class="line">        QueryWrapper&lt;EduSubject&gt; wrapper = <span class="keyword">new</span> QueryWrapper&lt;&gt;();</span><br><span class="line">        wrapper.eq(<span class="string">&quot;title&quot;</span>, name);</span><br><span class="line">        wrapper.eq(<span class="string">&quot;parent_id&quot;</span>, <span class="string">&quot;0&quot;</span>);</span><br><span class="line">        EduSubject oneSubject = subjectService.getOne(wrapper);</span><br><span class="line">        <span class="keyword">return</span> oneSubject;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断二级分类不能重复添加</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> EduSubject <span class="title">existTwoSubject</span><span class="params">(EduSubjectService subjectService, String name, String pid)</span> </span>&#123;</span><br><span class="line">        QueryWrapper&lt;EduSubject&gt; wrapper = <span class="keyword">new</span> QueryWrapper&lt;&gt;();</span><br><span class="line">        wrapper.eq(<span class="string">&quot;title&quot;</span>, name);</span><br><span class="line">        wrapper.eq(<span class="string">&quot;parent_id&quot;</span>, pid);</span><br><span class="line">        EduSubject twoSubject = subjectService.getOne(wrapper);</span><br><span class="line">        <span class="keyword">return</span> twoSubject;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doAfterAllAnalysed</span><span class="params">(AnalysisContext analysisContext)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="课程分类前端"><a href="#课程分类前端" class="headerlink" title="课程分类前端"></a>课程分类前端</h1><h2 id="1-添加课程分类路由"><a href="#1-添加课程分类路由" class="headerlink" title="1. 添加课程分类路由"></a>1. 添加课程分类路由</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//课程分类管理</span></span><br><span class="line">&#123;</span><br><span class="line">  path: <span class="string">&#x27;/subject&#x27;</span>,</span><br><span class="line">  component: Layout,</span><br><span class="line">  redirect: <span class="string">&#x27;/subject/list&#x27;</span>,</span><br><span class="line">  name: <span class="string">&#x27;课程分类管理&#x27;</span>,</span><br><span class="line">  meta: &#123; <span class="attr">title</span>: <span class="string">&#x27;课程分类管理&#x27;</span>, <span class="attr">icon</span>: <span class="string">&#x27;example&#x27;</span> &#125;,</span><br><span class="line">  children: [</span><br><span class="line">    &#123;</span><br><span class="line">      path: <span class="string">&#x27;list&#x27;</span>,</span><br><span class="line">      name: <span class="string">&#x27;课程分类列表&#x27;</span>,</span><br><span class="line">      component: <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&#x27;@/views/edu/subject/list&#x27;</span>),</span><br><span class="line">      meta: &#123; <span class="attr">title</span>: <span class="string">&#x27;课程分类列表&#x27;</span>, <span class="attr">icon</span>: <span class="string">&#x27;table&#x27;</span> &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      path: <span class="string">&#x27;save&#x27;</span>,</span><br><span class="line">      name: <span class="string">&#x27;添加课程分类&#x27;</span>,</span><br><span class="line">      component: <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&#x27;@/views/edu/subject/save&#x27;</span>),</span><br><span class="line">      meta: &#123; <span class="attr">title</span>: <span class="string">&#x27;添加课程分类&#x27;</span>, <span class="attr">icon</span>: <span class="string">&#x27;tree&#x27;</span> &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">  ]</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<h2 id="2-上传课程分类文件"><a href="#2-上传课程分类文件" class="headerlink" title="2. 上传课程分类文件"></a>2. 上传课程分类文件</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class&#x3D;&quot;app-container&quot;&gt;</span><br><span class="line">    &lt;el-form label-width&#x3D;&quot;120px&quot;&gt;</span><br><span class="line">      &lt;el-form-item label&#x3D;&quot;信息描述&quot;&gt;</span><br><span class="line">        &lt;el-tag type&#x3D;&quot;info&quot;&gt;excel模版说明&lt;&#x2F;el-tag&gt;</span><br><span class="line">        &lt;el-tag&gt;</span><br><span class="line">          &lt;i class&#x3D;&quot;el-icon-download&quot; &#x2F;&gt;</span><br><span class="line">          &lt;a :href&#x3D;&quot;&#39;&#x2F;static&#x2F;01.xlsx&#39;&quot;&gt;点击下载模版&lt;&#x2F;a&gt;</span><br><span class="line">        &lt;&#x2F;el-tag&gt;</span><br><span class="line">      &lt;&#x2F;el-form-item&gt;</span><br><span class="line"></span><br><span class="line">      &lt;!--accept&#x3D;&quot;application&#x2F;vnd.ms-excel&quot;--&gt;</span><br><span class="line">      &lt;el-form-item label&#x3D;&quot;选择Excel&quot;&gt;</span><br><span class="line">        &lt;el-upload ref&#x3D;&quot;upload&quot; :auto-upload&#x3D;&quot;false&quot; :on-success&#x3D;&quot;fileUploadSuccess&quot; :on-error&#x3D;&quot;fileUploadError&quot;</span><br><span class="line">          :disabled&#x3D;&quot;importBtnDisabled&quot; :limit&#x3D;&quot;1&quot; :action&#x3D;&quot;BASE_API + &#39;&#x2F;eduservice&#x2F;subject&#x2F;addSubject&#39;&quot; name&#x3D;&quot;file&quot;</span><br><span class="line">          accept&#x3D;&quot;.xlsx&quot;&gt;</span><br><span class="line">          &lt;el-button slot&#x3D;&quot;trigger&quot; size&#x3D;&quot;small&quot; type&#x3D;&quot;primary&quot;&gt;选取文件&lt;&#x2F;el-button&gt;</span><br><span class="line">          &lt;el-button :loading&#x3D;&quot;loading&quot; style&#x3D;&quot;margin-left: 10px&quot; size&#x3D;&quot;small&quot; type&#x3D;&quot;success&quot; @click&#x3D;&quot;submitUpload&quot;&gt;</span><br><span class="line">            上传到服务器&lt;&#x2F;el-button&gt;</span><br><span class="line">        &lt;&#x2F;el-upload&gt;</span><br><span class="line">      &lt;&#x2F;el-form-item&gt;</span><br><span class="line">    &lt;&#x2F;el-form&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      BASE_API: process.env.BASE_API, &#x2F;&#x2F; 接口API地址</span><br><span class="line">      OSS_PATH: process.env.OSS_PATH, &#x2F;&#x2F; 阿里云OSS地址</span><br><span class="line">      fileUploadBtnText: &quot;上传到服务器&quot;, &#x2F;&#x2F; 按钮文字</span><br><span class="line">      importBtnDisabled: false, &#x2F;&#x2F; 按钮是否禁用,</span><br><span class="line">      loading: false,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  created() &#123; &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    &#x2F;&#x2F;点击按钮上传文件到接口里面</span><br><span class="line">    submitUpload() &#123;</span><br><span class="line">      this.importBtnDisabled &#x3D; true;</span><br><span class="line">      this.loading &#x3D; true;</span><br><span class="line">      this.$refs.upload.submit();</span><br><span class="line">    &#125;,</span><br><span class="line">    &#x2F;&#x2F;上传成功</span><br><span class="line">    fileUploadSuccess() &#123;</span><br><span class="line">      &#x2F;&#x2F;提示信息</span><br><span class="line">      this.loading &#x3D; false;</span><br><span class="line">      this.$message(&#123;</span><br><span class="line">        type: &quot;success&quot;,</span><br><span class="line">        message: &quot;添加课程分类成功&quot;,</span><br><span class="line">      &#125;);</span><br><span class="line">      &#x2F;&#x2F;跳转到课程分类列表</span><br><span class="line">      &#x2F;&#x2F;路由跳转</span><br><span class="line">      this.router.push(&#123; path: &#39;&#x2F;subject&#x2F;list&#39; &#125;)</span><br><span class="line">    &#125;,</span><br><span class="line">    &#x2F;&#x2F;上传失败</span><br><span class="line">    fileUploadError() &#123;</span><br><span class="line">      this.loading &#x3D; false;</span><br><span class="line">      this.$message(&#123;</span><br><span class="line">        type: &quot;error&quot;,</span><br><span class="line">        message: &quot;添加课程分类失败&quot;,</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<h2 id="3-课程分类树形结构显示"><a href="#3-课程分类树形结构显示" class="headerlink" title="3. 课程分类树形结构显示"></a>3. 课程分类树形结构显示</h2><p>（1）在属性结构显示分类中，我们需要从接口中得到类似如下格式的数据：</p>
<p><img src="https://rulerofterabithia-blog.oss-cn-hangzhou.aliyuncs.com/img/20220524194154.png"></p>
<h3 id="3-1-如何得到这样格式的数据？"><a href="#3-1-如何得到这样格式的数据？" class="headerlink" title="3.1 如何得到这样格式的数据？"></a>3.1 如何得到这样格式的数据？</h3><p>（1）针对返回数据创建对应的实体类，我们可以将id和label当作一个实体类中的两个属性，那么在此我们就需要创建两个实体类，一级分类和二级分类，并且一个一级分类中可以有多个二级分类</p>
<p>一级分类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//一级分类</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OneSubject</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String id;</span><br><span class="line">    <span class="keyword">private</span> String title;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//一个一级分类中有多个二级分类</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;TwoSubject&gt; children = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>二级分类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//二级分类</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TwoSubject</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String id;</span><br><span class="line">    <span class="keyword">private</span> String title;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>封装数据格式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//课程分类列表（树形结构）</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;OneSubject&gt; <span class="title">getAllOneTwoSubject</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//1、查询所有一级分类 parent_id = 0</span></span><br><span class="line">    QueryWrapper&lt;EduSubject&gt; wrapperOne = <span class="keyword">new</span> QueryWrapper&lt;&gt;();</span><br><span class="line">    wrapperOne.eq(<span class="string">&quot;parent_id&quot;</span>, <span class="number">0</span>);</span><br><span class="line">    List&lt;EduSubject&gt; oneSubjectList = baseMapper.selectList(wrapperOne);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2、查询所有二级分类 parent_id != 0</span></span><br><span class="line">    QueryWrapper&lt;EduSubject&gt; wrapperTwo = <span class="keyword">new</span> QueryWrapper&lt;&gt;();</span><br><span class="line">    wrapperOne.ne(<span class="string">&quot;parent_id&quot;</span>, <span class="number">0</span>);</span><br><span class="line">    List&lt;EduSubject&gt; twoSubjectList = baseMapper.selectList(wrapperTwo);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建list集合，用于存储最终封装的数据</span></span><br><span class="line">    ArrayList&lt;OneSubject&gt; finalSubjectList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3、封装一级分类</span></span><br><span class="line">    <span class="comment">//查询出来所有的一级分类list集合遍历，得到每个一级分类对象，获取每一个一级分类对象地值，封装到所要求的list集合里面</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; oneSubjectList.size(); i++) &#123;</span><br><span class="line">        <span class="comment">//得到oneSubjectList每个值，存放到eduSubject中去</span></span><br><span class="line">        EduSubject eduSubject = oneSubjectList.get(i);</span><br><span class="line">        <span class="comment">//从eduSubject里面获取出来的值，存放到oneSubject对象里面</span></span><br><span class="line">        OneSubject oneSubject = <span class="keyword">new</span> OneSubject();</span><br><span class="line">        <span class="comment">//get eduSubject里面的值，set 到oneSubject中去</span></span><br><span class="line">        BeanUtils.copyProperties(eduSubject, oneSubject);</span><br><span class="line">        <span class="comment">//将oneSubject放到finalSubjectList中去</span></span><br><span class="line">        finalSubjectList.add(oneSubject);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//4、封装二级分类</span></span><br><span class="line">        <span class="comment">//在一级分类中循环遍历查询所有的二级分类</span></span><br><span class="line">        <span class="comment">//创建list集合封装每一个一级分类的二级分类</span></span><br><span class="line">        ArrayList&lt;TwoSubject&gt; twoFinalSubjectList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">//遍历二级分类list集合</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; twoSubjectList.size(); j++) &#123;</span><br><span class="line">            <span class="comment">//获取每个二级分类 tSubject：每个二级分类</span></span><br><span class="line">            EduSubject tSubject = twoSubjectList.get(j);</span><br><span class="line">            <span class="comment">//判断二级分类的parent_id是否和一级分类的id相同</span></span><br><span class="line">            <span class="keyword">if</span> (tSubject.getParentId().equals(eduSubject.getId())) &#123;</span><br><span class="line">                <span class="comment">//把tSubject值复制到twoSubject里面，再放到twoFinalSubjectList里面</span></span><br><span class="line">                TwoSubject twoSubject = <span class="keyword">new</span> TwoSubject();</span><br><span class="line">                BeanUtils.copyProperties(tSubject, twoSubject);</span><br><span class="line">                twoFinalSubjectList.add(twoSubject);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//把一级下面所有二级分类放到一级分类里面</span></span><br><span class="line">        oneSubject.setChildren(twoFinalSubjectList);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> finalSubjectList;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-前端接口调用"><a href="#4-前端接口调用" class="headerlink" title="4. 前端接口调用"></a>4. 前端接口调用</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    <span class="comment">//课程分类列表</span></span><br><span class="line">    <span class="function"><span class="title">getSubjectList</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> request(&#123;</span><br><span class="line">            url: <span class="string">`/eduservice/subject/getAllSubject`</span>,</span><br><span class="line">            method: <span class="string">&#x27;get&#x27;</span>,</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-前端页面显示"><a href="#5-前端页面显示" class="headerlink" title="5. 前端页面显示"></a>5. 前端页面显示</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class&#x3D;&quot;app-container&quot;&gt;</span><br><span class="line">    &lt;el-input v-model&#x3D;&quot;filterText&quot; placeholder&#x3D;&quot;Filter keyword&quot; style&#x3D;&quot;margin-bottom: 30px&quot; &#x2F;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;el-tree ref&#x3D;&quot;tree2&quot; :data&#x3D;&quot;data2&quot; :props&#x3D;&quot;defaultProps&quot; :filter-node-method&#x3D;&quot;filterNode&quot; class&#x3D;&quot;filter-tree&quot;</span><br><span class="line">      default-expand-all &#x2F;&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import subject from &quot;@&#x2F;api&#x2F;edu&#x2F;subject&quot;;</span><br><span class="line">export default &#123;</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      filterText: &quot;&quot;,</span><br><span class="line">      data2: [], &#x2F;&#x2F;返回的所有类型的数据</span><br><span class="line">      defaultProps: &#123;</span><br><span class="line">        children: &quot;children&quot;,</span><br><span class="line">        label: &quot;title&quot;,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  created() &#123;</span><br><span class="line">    this.getAllSubjectList();</span><br><span class="line">  &#125;,</span><br><span class="line">  watch: &#123;</span><br><span class="line">    filterText(val) &#123;</span><br><span class="line">      this.$refs.tree2.filter(val);</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  methods: &#123;</span><br><span class="line">    getAllSubjectList() &#123;</span><br><span class="line">      subject.getSubjectList().then((response) &#x3D;&gt; &#123;</span><br><span class="line">        this.data2 &#x3D; response.data.list;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;,</span><br><span class="line">    filterNode(value, data) &#123;</span><br><span class="line">      if (!value) return true;</span><br><span class="line">      return data.title.toLowerCase().indexOf(value.toLowerCase()) !&#x3D;&#x3D; -1;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<h1 id="课程发布"><a href="#课程发布" class="headerlink" title="课程发布"></a>课程发布</h1><h2 id="1-课程发布流程"><a href="#1-课程发布流程" class="headerlink" title="1. 课程发布流程"></a>1. 课程发布流程</h2><p><img src="https://rulerofterabithia-blog.oss-cn-hangzhou.aliyuncs.com/img/20220523223028.png"></p>
<h2 id="2-课程相关表关系"><a href="#2-课程相关表关系" class="headerlink" title="2. 课程相关表关系"></a>2. 课程相关表关系</h2><p><img src="https://rulerofterabithia-blog.oss-cn-hangzhou.aliyuncs.com/img/20220523223144.png"></p>
<h2 id="3-课程发布的实现"><a href="#3-课程发布的实现" class="headerlink" title="3. 课程发布的实现"></a>3. 课程发布的实现</h2><h3 id="3-1-使用代码生成器生成课程相关的代码"><a href="#3-1-使用代码生成器生成课程相关的代码" class="headerlink" title="3.1 使用代码生成器生成课程相关的代码"></a>3.1 使用代码生成器生成课程相关的代码</h3><h3 id="3-2-创建实体类用于表单数据封装"><a href="#3-2-创建实体类用于表单数据封装" class="headerlink" title="3.2 创建实体类用于表单数据封装"></a>3.2 创建实体类用于表单数据封装</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CourseInfoVo</span> </span>&#123;</span><br><span class="line">    <span class="meta">@ApiModelProperty(value = &quot;课程ID&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String id;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ApiModelProperty(value = &quot;课程讲师ID&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String teacherId;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ApiModelProperty(value = &quot;课程专业ID&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String subjectId;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ApiModelProperty(value = &quot;一级分类ID&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String subjectParentId;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ApiModelProperty(value = &quot;课程标题&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String title;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ApiModelProperty(value = &quot;课程销售价格，设置为0则可免费观看&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> BigDecimal price;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ApiModelProperty(value = &quot;总课时&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Integer lessonNum;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ApiModelProperty(value = &quot;课程封面图片路径&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String cover;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ApiModelProperty(value = &quot;课程简介&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String description;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-3-编写controller和service部分"><a href="#3-3-编写controller和service部分" class="headerlink" title="3.3 编写controller和service部分"></a>3.3 编写controller和service部分</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> EduCourseService courseService;</span><br><span class="line"></span><br><span class="line"><span class="comment">//添加课程基本信息的方法</span></span><br><span class="line"><span class="meta">@PostMapping(&quot;/addCourseInfo&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> R <span class="title">addCourseInfo</span><span class="params">(<span class="meta">@RequestBody</span> CourseInfoVo courseInfoVo)</span> </span>&#123;</span><br><span class="line">    String id = courseService.saveCourseInfo(courseInfoVo);</span><br><span class="line">    <span class="keyword">return</span> R.ok().data(<span class="string">&quot;courseId&quot;</span>, id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//添加课程基本信息的方法</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">saveCourseInfo</span><span class="params">(CourseInfoVo courseInfoVo)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//1、向课程表添加课程基本信息 edu_course</span></span><br><span class="line">    <span class="comment">//把courseInfoVo转换成eduCourse</span></span><br><span class="line">    EduCourse eduCourse = <span class="keyword">new</span> EduCourse();</span><br><span class="line">    BeanUtils.copyProperties(courseInfoVo, eduCourse);</span><br><span class="line">    <span class="keyword">int</span> insert = baseMapper.insert(eduCourse);</span><br><span class="line">    <span class="keyword">if</span> (insert &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> GuliException(<span class="number">20001</span>, <span class="string">&quot;添加课程信息失败&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取添加成功后的课程id</span></span><br><span class="line">    String cid = eduCourse.getId();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2、向课程简介表添加课程简介</span></span><br><span class="line">    EduCourseDescription eduCourseDescription = <span class="keyword">new</span> EduCourseDescription();</span><br><span class="line">    eduCourseDescription.setDescription(courseInfoVo.getDescription());</span><br><span class="line"></span><br><span class="line">    eduCourseDescription.setId(cid);<span class="comment">//设置课程描述id就是课程id</span></span><br><span class="line">    eduCourseDescriptionService.save(eduCourseDescription);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> cid;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-下拉列表显示所有讲师"><a href="#4-下拉列表显示所有讲师" class="headerlink" title="4. 下拉列表显示所有讲师"></a>4. 下拉列表显示所有讲师</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- 课程讲师 --&gt;</span><br><span class="line">&lt;el-form-item label&#x3D;&quot;课程讲师&quot;&gt;</span><br><span class="line">    &lt;el-select v-model&#x3D;&quot;courseInfo.teacherId&quot; placeholder&#x3D;&quot;请选择&quot;&gt;</span><br><span class="line">        &lt;el-option v-for&#x3D;&quot;teacher in teacherList&quot; :key&#x3D;&quot;teacher.id&quot; 														:label&#x3D;&quot;teacher.name&quot; :value&#x3D;&quot;teacher.id&quot; &#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;el-select&gt;</span><br><span class="line">&lt;&#x2F;el-form-item&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">created</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="comment">//初始化所有讲师</span></span><br><span class="line">    <span class="built_in">this</span>.getTeacherList();</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//查询所有的讲师</span></span><br><span class="line"><span class="function"><span class="title">getTeacherList</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    course.getTeacherList().then(<span class="function">(<span class="params">response</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.teacherList = response.data.items;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<h2 id="5-课程分类二级联动显示"><a href="#5-课程分类二级联动显示" class="headerlink" title="5. 课程分类二级联动显示"></a>5. 课程分类二级联动显示</h2><h3 id="5-1-第一次进入页面，显示所有一级分类"><a href="#5-1-第一次进入页面，显示所有一级分类" class="headerlink" title="5.1 第一次进入页面，显示所有一级分类"></a>5.1 第一次进入页面，显示所有一级分类</h3><p>此时不查询二级分类，二级分类为空</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">created</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">                .</span></span><br><span class="line"><span class="comment">                .</span></span><br><span class="line"><span class="comment">                .</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">    <span class="comment">//初始化一级分类</span></span><br><span class="line">    <span class="built_in">this</span>.getOneSubject();</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">                .</span></span><br><span class="line"><span class="comment">                .</span></span><br><span class="line"><span class="comment">                .</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<h3 id="5-2-当选择一级分类时，显示一级分类里面对应的二级分类"><a href="#5-2-当选择一级分类时，显示一级分类里面对应的二级分类" class="headerlink" title="5.2 当选择一级分类时，显示一级分类里面对应的二级分类"></a>5.2 当选择一级分类时，显示一级分类里面对应的二级分类</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//查询所有的一级分类</span></span><br><span class="line"><span class="function"><span class="title">getOneSubject</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    subject.getSubjectList().then(<span class="function">(<span class="params">response</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.subjectOneList = response.data.list;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;el-select v-model&#x3D;&quot;courseInfo.subjectParentId&quot; placeholder&#x3D;&quot;一级分类&quot; @change&#x3D;&quot;subjectLevelOneChanged&quot;&gt;</span><br><span class="line">    &lt;el-option v-for&#x3D;&quot;subject in subjectOneList&quot; </span><br><span class="line">               :key&#x3D;&quot;subject.id&quot; 																   :label&#x3D;&quot;subject.title&quot; :value&#x3D;&quot;subject.id&quot; &#x2F;&gt;</span><br><span class="line">&lt;&#x2F;el-select&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//点击某一个分类，触发change，显示对应的二级分类</span></span><br><span class="line"><span class="function"><span class="title">subjectLevelOneChanged</span>(<span class="params">value</span>)</span> &#123;</span><br><span class="line">    <span class="comment">//value就是一级分类的id值</span></span><br><span class="line">    <span class="comment">//遍历所有的分类，包含一级和二级</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="built_in">this</span>.subjectOneList.length; i++) &#123;</span><br><span class="line">        <span class="comment">//每个一级分类</span></span><br><span class="line">        <span class="keyword">var</span> oneSubject = <span class="built_in">this</span>.subjectOneList[i];</span><br><span class="line">        <span class="comment">//判断：所有一级分类的id和所选择的一级分类的id是否一样</span></span><br><span class="line">        <span class="keyword">if</span> (value === oneSubject.id) &#123;</span><br><span class="line">            <span class="comment">//从一级分类中获取所有的二级分类</span></span><br><span class="line">            <span class="built_in">this</span>.subjectTwoList = oneSubject.children;</span><br><span class="line">            <span class="comment">//把二级分类的id值清空</span></span><br><span class="line">            <span class="built_in">this</span>.courseInfo.subjectId = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- 二级分类 --&gt;</span><br><span class="line">&lt;el-select v-model&#x3D;&quot;courseInfo.subjectId&quot; placeholder&#x3D;&quot;二级分类&quot;&gt;</span><br><span class="line">    &lt;el-option v-for&#x3D;&quot;subject in subjectTwoList&quot; </span><br><span class="line">               :key&#x3D;&quot;subject.id&quot; 																   :label&#x3D;&quot;subject.title&quot; :value&#x3D;&quot;subject.id&quot; &#x2F;&gt;</span><br><span class="line">&lt;&#x2F;el-select&gt;</span><br></pre></td></tr></table></figure>

<h2 id="6-上传课程封面"><a href="#6-上传课程封面" class="headerlink" title="6. 上传课程封面"></a>6. 上传课程封面</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- 课程封面--&gt;</span><br><span class="line">&lt;el-form-item label&#x3D;&quot;课程封面&quot;&gt;</span><br><span class="line">    &lt;el-upload :show-file-list&#x3D;&quot;false&quot; :on-success&#x3D;&quot;handleAvatarSuccess&quot; </span><br><span class="line">               :before-upload&#x3D;&quot;beforeAvatarUpload&quot;</span><br><span class="line">               :action&#x3D;&quot;BASE_API + &#39;&#x2F;eduoss&#x2F;fileoss&#39;&quot; class&#x3D;&quot;avatar-uploader&quot;&gt;</span><br><span class="line">        &lt;img :src&#x3D;&quot;courseInfo.cover&quot; &#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;el-upload&gt;</span><br><span class="line">&lt;&#x2F;el-form-item&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//上传之前调用的方法</span></span><br><span class="line"><span class="function"><span class="title">beforeAvatarUpload</span>(<span class="params">file</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> isJPG = file.type === <span class="string">&quot;image/jpeg&quot;</span>;</span><br><span class="line">    <span class="keyword">const</span> isLt2M = file.size / <span class="number">1024</span> / <span class="number">1024</span> &lt; <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!isJPG) &#123;</span><br><span class="line">        <span class="built_in">this</span>.$message.error(<span class="string">&quot;上传头像图片只能是 JPG 格式!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!isLt2M) &#123;</span><br><span class="line">        <span class="built_in">this</span>.$message.error(<span class="string">&quot;上传头像图片大小不能超过 2MB!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> isJPG &amp;&amp; isLt2M;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//上传封面成功调用的方法</span></span><br><span class="line"><span class="function"><span class="title">handleAvatarSuccess</span>(<span class="params">res, file</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.courseInfo.cover = res.data.url;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<h2 id="7-整合富文本编辑器"><a href="#7-整合富文本编辑器" class="headerlink" title="7. 整合富文本编辑器"></a>7. 整合富文本编辑器</h2><p><img src="https://rulerofterabithia-blog.oss-cn-hangzhou.aliyuncs.com/img/20220524195509.png"></p>
<h1 id="课程大纲"><a href="#课程大纲" class="headerlink" title="课程大纲"></a>课程大纲</h1><h2 id="1-课程章节小节数据封装"><a href="#1-课程章节小节数据封装" class="headerlink" title="1. 课程章节小节数据封装"></a>1. 课程章节小节数据封装</h2><p>思路类似于课程分类时的数据封装，先创建两个实体类（章节和小节），在章节实体类中使用list封装小节</p>
<p>课程小节：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VideoVo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String id;</span><br><span class="line">    <span class="keyword">private</span> String title;</span><br><span class="line">    <span class="keyword">private</span> String videoSourceId;<span class="comment">//视频id</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>课程章节：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChapterVo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String id;</span><br><span class="line">    <span class="keyword">private</span> String title;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//章节里的小节</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;VideoVo&gt; children = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>封装数据：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> EduVideoService eduVideoService;</span><br><span class="line"></span><br><span class="line"><span class="comment">//根据课程id查询课程章节信息</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;ChapterVo&gt; <span class="title">getChapterVideoByCourseId</span><span class="params">(String courseId)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//1、根据课程id查询课程章节信息</span></span><br><span class="line">    QueryWrapper&lt;EduChapter&gt; wrapperChapter = <span class="keyword">new</span> QueryWrapper&lt;&gt;();</span><br><span class="line">    wrapperChapter.eq(<span class="string">&quot;course_id&quot;</span>, courseId);</span><br><span class="line">    List&lt;EduChapter&gt; eduChapterList = baseMapper.selectList(wrapperChapter);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2、根据课程id查询课程里面的所有小节</span></span><br><span class="line">    QueryWrapper&lt;EduVideo&gt; wrapperVideo = <span class="keyword">new</span> QueryWrapper&lt;&gt;();</span><br><span class="line">    wrapperVideo.eq(<span class="string">&quot;course_id&quot;</span>, courseId);</span><br><span class="line">    List&lt;EduVideo&gt; eduVideoList = eduVideoService.list(wrapperVideo);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3、循环遍历eduChapterList，将其中的值封装到ChapterVo中</span></span><br><span class="line">    List&lt;ChapterVo&gt; finalList = <span class="keyword">new</span> ArrayList&lt;&gt;();<span class="comment">//用于封装eduChapter</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; eduChapterList.size(); i++) &#123;</span><br><span class="line">        EduChapter eduChapter = eduChapterList.get(i);</span><br><span class="line">        <span class="comment">//将eduChapter中的值取出来放到chapterVo中</span></span><br><span class="line">        ChapterVo chapterVo = <span class="keyword">new</span> ChapterVo();</span><br><span class="line">        BeanUtils.copyProperties(eduChapter, chapterVo);</span><br><span class="line">        <span class="comment">//把chapterVo放到finalList中</span></span><br><span class="line">        finalList.add(chapterVo);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4、循环遍历eduVideoList，将其中的值封装到VideoVo</span></span><br><span class="line">        List&lt;VideoVo&gt; videoList = <span class="keyword">new</span> ArrayList&lt;&gt;();<span class="comment">//用于封装eduVideo</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; eduVideoList.size(); j++) &#123;</span><br><span class="line">            EduVideo eduVideo = eduVideoList.get(j);</span><br><span class="line">            <span class="comment">//判断小节里面的chapterId和章节里面的id是否一样，相等再进行封装</span></span><br><span class="line">            <span class="keyword">if</span> (eduVideo.getChapterId().equals(eduChapter.getId())) &#123;</span><br><span class="line">                VideoVo videoVo = <span class="keyword">new</span> VideoVo();</span><br><span class="line">                <span class="comment">//将eduVideo中的值取出来放到videoVo中</span></span><br><span class="line">                BeanUtils.copyProperties(eduVideo, videoVo);</span><br><span class="line">                <span class="comment">//把videoVo放到videoList中</span></span><br><span class="line">                videoList.add(videoVo);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//设置章节里的小节</span></span><br><span class="line">        chapterVo.setChildren(videoList);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> finalList;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-前端实现"><a href="#2-前端实现" class="headerlink" title="2. 前端实现"></a>2. 前端实现</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1、根据课程id获取章节和小节数据列表</span></span><br><span class="line"><span class="function"><span class="title">getAllChapterVideo</span>(<span class="params">courseId</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> request(&#123;</span><br><span class="line">        url: <span class="string">&#x27;/eduservice/chapter/getChapterVideo/&#x27;</span> + courseId,</span><br><span class="line">        method: <span class="string">&#x27;get&#x27;</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取路由的id值</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">this</span>.$route.params &amp;&amp; <span class="built_in">this</span>.$route.params.id) &#123;</span><br><span class="line">    <span class="built_in">this</span>.courseId = <span class="built_in">this</span>.$route.params.id;</span><br><span class="line">    <span class="comment">//根据课程id查询章节和小节</span></span><br><span class="line">    <span class="built_in">this</span>.getChapterVideo();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//根据课程id查询章节和小节</span></span><br><span class="line"><span class="function"><span class="title">getChapterVideo</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    chapter.getAllChapterVideo(<span class="built_in">this</span>.courseId).then(<span class="function">(<span class="params">response</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.chapterVideoList = response.data.allChapterVideo;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- 章节 --&gt;</span><br><span class="line">&lt;ul class&#x3D;&quot;chapterList&quot;&gt;</span><br><span class="line">    &lt;li v-for&#x3D;&quot;chapter in chapterVideoList&quot; :key&#x3D;&quot;chapter.id&quot;&gt;</span><br><span class="line">        &lt;p&gt;</span><br><span class="line">            &#123;&#123; chapter.title &#125;&#125;</span><br><span class="line">            &lt;span class&#x3D;&quot;acts&quot;&gt;</span><br><span class="line">                &lt;el-button style&#x3D;&quot;&quot; </span><br><span class="line">                           type&#x3D;&quot;text&quot; </span><br><span class="line">                           @click&#x3D;&quot;openVideo(chapter.id)&quot;&gt;添加小节&lt;&#x2F;el-button&gt;</span><br><span class="line">                &lt;el-button style&#x3D;&quot;&quot; </span><br><span class="line">                           type&#x3D;&quot;text&quot; </span><br><span class="line">                           @click&#x3D;&quot;openEditChatper(chapter.id)&quot;&gt;编辑&lt;&#x2F;el-button&gt;</span><br><span class="line">                &lt;el-button type&#x3D;&quot;text&quot; </span><br><span class="line">                           @click&#x3D;&quot;removeChapter(chapter.id)&quot;&gt;删除&lt;&#x2F;el-button&gt;</span><br><span class="line">            &lt;&#x2F;span&gt;</span><br><span class="line">        &lt;&#x2F;p&gt;</span><br><span class="line"></span><br><span class="line">        &lt;!-- 视频 --&gt;</span><br><span class="line">        &lt;ul class&#x3D;&quot;chanpterList videoList&quot;&gt;</span><br><span class="line">            &lt;li v-for&#x3D;&quot;video in chapter.children&quot; :key&#x3D;&quot;video.id&quot;&gt;</span><br><span class="line">                &lt;p&gt;</span><br><span class="line">                    &#123;&#123; video.title &#125;&#125;</span><br><span class="line">                    &lt;span class&#x3D;&quot;acts&quot;&gt;</span><br><span class="line">                        &lt;el-button type&#x3D;&quot;text&quot; </span><br><span class="line">                                   @click&#x3D;&quot;getVideoInfo(video.id)&quot;&gt;编辑&lt;&#x2F;el-button&gt;</span><br><span class="line">                        &lt;el-button type&#x3D;&quot;text&quot; </span><br><span class="line">                                   @click&#x3D;&quot;removeVideo(video.id)&quot;&gt;删除&lt;&#x2F;el-button&gt;</span><br><span class="line">                    &lt;&#x2F;span&gt;</span><br><span class="line">                &lt;&#x2F;p&gt;</span><br><span class="line">            &lt;&#x2F;li&gt;</span><br><span class="line">        &lt;&#x2F;ul&gt;</span><br><span class="line">    &lt;&#x2F;li&gt;</span><br><span class="line">&lt;&#x2F;ul&gt;</span><br></pre></td></tr></table></figure>

<h1 id="修改课程信息"><a href="#修改课程信息" class="headerlink" title="修改课程信息"></a>修改课程信息</h1><h2 id="1-数据回显"><a href="#1-数据回显" class="headerlink" title="1. 数据回显"></a>1. 数据回显</h2><p>点击上一步的时候，回到第一步，把课程的基本信息进行数据回显</p>
<p>EduCourseController：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//根据课程id查询课程信息</span></span><br><span class="line"><span class="meta">@GetMapping(&quot;getCourseInfo/&#123;courseId&#125;&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> R <span class="title">getCourseInfo</span><span class="params">(<span class="meta">@PathVariable</span> String courseId)</span> </span>&#123;</span><br><span class="line">    CourseInfoVo courseInfoVo = courseService.getCourseInfo(courseId);</span><br><span class="line">    <span class="keyword">return</span> R.ok().data(<span class="string">&quot;courseInfoVo&quot;</span>, courseInfoVo);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>EduCourseServiceImpl：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//根据课程id查询课程信息</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> CourseInfoVo <span class="title">getCourseInfo</span><span class="params">(String courseId)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1、查询课程表</span></span><br><span class="line">    EduCourse eduCourse = baseMapper.selectById(courseId);</span><br><span class="line">    CourseInfoVo courseInfoVo = <span class="keyword">new</span> CourseInfoVo();<span class="comment">//用于封装课程信息和课程描述</span></span><br><span class="line">    BeanUtils.copyProperties(eduCourse, courseInfoVo);</span><br><span class="line">    <span class="comment">//2、查询课程描述表</span></span><br><span class="line">    EduCourseDescription eduCourseDescription = 																		eduCourseDescriptionService.getById(courseId);</span><br><span class="line">    courseInfoVo.setDescription(eduCourseDescription.getDescription());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> courseInfoVo;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-修改内容"><a href="#2-修改内容" class="headerlink" title="2. 修改内容"></a>2. 修改内容</h2><p>在数据回显页面，修改内容，保存，修改数据库中的内容</p>
<p>EduCourseController：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//修改课程信息</span></span><br><span class="line"><span class="meta">@PostMapping(&quot;updateCourseInfo&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> R <span class="title">updateCourseInfo</span><span class="params">(<span class="meta">@RequestBody</span> CourseInfoVo courseInfoVo)</span> </span>&#123;</span><br><span class="line">    courseService.updateCourseInfo(courseInfoVo);</span><br><span class="line">    <span class="keyword">return</span> R.ok();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>EduCourseServiceImpl：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//修改课程信息</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateCourseInfo</span><span class="params">(CourseInfoVo courseInfoVo)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//修改课程表</span></span><br><span class="line">    EduCourse eduCourse = <span class="keyword">new</span> EduCourse();</span><br><span class="line">    BeanUtils.copyProperties(courseInfoVo, eduCourse);</span><br><span class="line">    <span class="keyword">int</span> update = baseMapper.updateById(eduCourse);</span><br><span class="line">    <span class="keyword">if</span> (update &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> GuliException(<span class="number">20001</span>, <span class="string">&quot;修改课程信息失败&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//修改课程描述表</span></span><br><span class="line">    EduCourseDescription eduCourseDescription = <span class="keyword">new</span> EduCourseDescription();</span><br><span class="line">    eduCourseDescription.setId(courseInfoVo.getId());</span><br><span class="line">    eduCourseDescription.setDescription(courseInfoVo.getDescription());</span><br><span class="line">    eduCourseDescriptionService.updateById(eduCourseDescription);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-整合前端"><a href="#3-整合前端" class="headerlink" title="3. 整合前端"></a>3. 整合前端</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//根据课程id查询课程基本信息</span></span><br><span class="line"><span class="function"><span class="title">getCourseInfoId</span>(<span class="params">id</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> request(&#123;</span><br><span class="line">        url: <span class="string">&#x27;/eduservice/course/getCourseInfo/&#x27;</span> + id,</span><br><span class="line">        method: <span class="string">&#x27;get&#x27;</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//修改课程信息</span></span><br><span class="line"><span class="function"><span class="title">updateCourseInfo</span>(<span class="params">courseInfo</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> request(&#123;</span><br><span class="line">        url: <span class="string">&#x27;/eduservice/course/updateCourseInfo&#x27;</span>,</span><br><span class="line">        method: <span class="string">&#x27;post&#x27;</span>,</span><br><span class="line">        data: courseInfo</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<p>chapter.vue：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">previous</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.$router.push(&#123; <span class="attr">path</span>: <span class="string">&quot;/course/info/&quot;</span> + <span class="built_in">this</span>.courseId &#125;);</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<p>info.vue：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">created</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="comment">//获取路由中的id值</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.$route.params &amp;&amp; <span class="built_in">this</span>.$route.params.id) &#123;</span><br><span class="line">        <span class="built_in">this</span>.courseId = <span class="built_in">this</span>.$route.params.id;</span><br><span class="line">        <span class="comment">//调用根据id查询课程的方法</span></span><br><span class="line">        <span class="built_in">this</span>.getInfo();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//......</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">getInfo</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    course.getCourseInfoId(<span class="built_in">this</span>.courseId).then(<span class="function">(<span class="params">response</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">//在courseInfo课程基本信息，包含 一级分类id 和 二级分类id</span></span><br><span class="line">        <span class="built_in">this</span>.courseInfo = response.data.courseInfoVo;</span><br><span class="line">        <span class="comment">//1、查询所有的分类，包含一级和二级</span></span><br><span class="line">        subject.getSubjectList().then(<span class="function">(<span class="params">response</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="comment">//2、获取所有一级分类</span></span><br><span class="line">            <span class="built_in">this</span>.subjectOneList = response.data.list;</span><br><span class="line">            <span class="comment">//3、把所有的一级分类数组进行遍历</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="built_in">this</span>.subjectOneList.length; i++) &#123;</span><br><span class="line">                <span class="comment">//获取每个一级分类</span></span><br><span class="line">                <span class="keyword">var</span> oneSubject = <span class="built_in">this</span>.subjectOneList[i];</span><br><span class="line">                <span class="comment">//比较当前courseInfo里面一级分类id和所有的一级分类id</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">this</span>.courseInfo.subjectParentId == oneSubject.id) &#123;</span><br><span class="line">                    <span class="comment">//获取一级分类所有的二级分类</span></span><br><span class="line">                    <span class="built_in">this</span>.subjectTwoList = oneSubject.children;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">//初始化所有讲师</span></span><br><span class="line">        <span class="built_in">this</span>.getTeacherList();</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//路由监听</span></span><br><span class="line">watch: &#123;</span><br><span class="line">    $route(to, <span class="keyword">from</span>) &#123;</span><br><span class="line">        <span class="comment">//路由变化方式，当路由发送变化，方法就执行</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;watch $route&quot;</span>);</span><br><span class="line">        location.reload();</span><br><span class="line">        <span class="built_in">this</span>.courseInfo = &#123;&#125;;</span><br><span class="line">        <span class="built_in">this</span>.courseInfo.cover = <span class="string">&quot;https://guli-academy-edu.oss-cn-							beijing.aliyuncs.com/2021/10/21/8b0a53e19b524c6c9df9b357f1a5b501default.jpg&quot;</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<h2 id="4-最终实现"><a href="#4-最终实现" class="headerlink" title="4. 最终实现"></a>4. 最终实现</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">saveOrUpdate</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="comment">//判断添加还是修改</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">this</span>.courseInfo.id) &#123;</span><br><span class="line">        <span class="comment">//添加</span></span><br><span class="line">        <span class="built_in">this</span>.addCourse();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.updateCourse();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//修改课程</span></span><br><span class="line"><span class="function"><span class="title">updateCourse</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    course.updateCourseInfo(<span class="built_in">this</span>.courseInfo).then(<span class="function">(<span class="params">response</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.$message(&#123;</span><br><span class="line">            type: <span class="string">&quot;success&quot;</span>,</span><br><span class="line">            message: <span class="string">&quot;修改课程信息成功！&quot;</span>,</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">//跳转到第二步</span></span><br><span class="line">        <span class="built_in">this</span>.$router.push(&#123; <span class="attr">path</span>: <span class="string">&quot;/course/chapter/&quot;</span> + <span class="built_in">this</span>.courseId &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//添加课程的方法</span></span><br><span class="line"><span class="function"><span class="title">addCourse</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    course.addCourseInfo(<span class="built_in">this</span>.courseInfo).then(<span class="function">(<span class="params">response</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">//提示信息</span></span><br><span class="line">        <span class="built_in">this</span>.$message(&#123;</span><br><span class="line">            type: <span class="string">&quot;success&quot;</span>,</span><br><span class="line">            message: <span class="string">&quot;添加课程信息成功&quot;</span>,</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//跳转到第二步</span></span><br><span class="line">        <span class="built_in">this</span>.$router.push(&#123;</span><br><span class="line">            path: <span class="string">&quot;/course/chapter/&quot;</span> + response.data.courseId,</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<h1 id="课程章节"><a href="#课程章节" class="headerlink" title="课程章节"></a>课程章节</h1><h2 id="1-添加章节"><a href="#1-添加章节" class="headerlink" title="1. 添加章节"></a>1. 添加章节</h2><p>EduChapterController：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//添加章节</span></span><br><span class="line"><span class="meta">@PostMapping(&quot;addChapter&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> R <span class="title">addChapter</span><span class="params">(<span class="meta">@RequestBody</span> EduChapter eduChapter)</span> </span>&#123;</span><br><span class="line">    eduChapterService.save(eduChapter);</span><br><span class="line">    <span class="keyword">return</span> R.ok();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>前端：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//添加章节</span></span><br><span class="line"><span class="function"><span class="title">addChapter</span>(<span class="params">chapter</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> request(&#123;</span><br><span class="line">        url: <span class="string">&#x27;/eduservice/chapter/addChapter&#x27;</span>,</span><br><span class="line">        method: <span class="string">&#x27;post&#x27;</span>,</span><br><span class="line">        data: chapter</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<p>点击添加章节按钮，弹出添加弹框，输入章节信息，点击保存添加</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- 添加和修改章节表单 --&gt;</span><br><span class="line">&lt;el-dialog :visible.sync&#x3D;&quot;dialogChapterFormVisible&quot; title&#x3D;&quot;添加章节&quot;&gt;</span><br><span class="line">    &lt;el-form :model&#x3D;&quot;chapter&quot; label-width&#x3D;&quot;120px&quot;&gt;</span><br><span class="line">        &lt;el-form-item label&#x3D;&quot;章节标题&quot;&gt;</span><br><span class="line">            &lt;el-input v-model&#x3D;&quot;chapter.title&quot; &#x2F;&gt;</span><br><span class="line">        &lt;&#x2F;el-form-item&gt;</span><br><span class="line">        &lt;el-form-item label&#x3D;&quot;章节排序&quot;&gt;</span><br><span class="line">            &lt;el-input-number v-model&#x3D;&quot;chapter.sort&quot; </span><br><span class="line">                             :min&#x3D;&quot;0&quot; </span><br><span class="line">                             controls-position&#x3D;&quot;right&quot; &#x2F;&gt;</span><br><span class="line">        &lt;&#x2F;el-form-item&gt;</span><br><span class="line">    &lt;&#x2F;el-form&gt;</span><br><span class="line">    &lt;div slot&#x3D;&quot;footer&quot; class&#x3D;&quot;dialog-footer&quot;&gt;</span><br><span class="line">        &lt;el-button @click&#x3D;&quot;dialogChapterFormVisible &#x3D; false&quot;&gt;取 消&lt;&#x2F;el-button&gt;</span><br><span class="line">        &lt;el-button type&#x3D;&quot;primary&quot; @click&#x3D;&quot;saveOrUpdate&quot;&gt;确 定&lt;&#x2F;el-button&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;el-dialog&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//添加章节</span></span><br><span class="line"><span class="function"><span class="title">addChapter</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="comment">//设置课程id到chapter对象里面</span></span><br><span class="line">    <span class="built_in">this</span>.chapter.courseId = <span class="built_in">this</span>.courseId;</span><br><span class="line">    chapter.addChapter(<span class="built_in">this</span>.chapter).then(<span class="function">(<span class="params">response</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">//关闭弹框</span></span><br><span class="line">        <span class="built_in">this</span>.dialogChapterFormVisible = <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">//提示</span></span><br><span class="line">        <span class="built_in">this</span>.$message(&#123;</span><br><span class="line">            type: <span class="string">&quot;success&quot;</span>,</span><br><span class="line">            message: <span class="string">&quot;添加章节成功!&quot;</span>,</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">//刷新页面</span></span><br><span class="line">        <span class="built_in">this</span>.getChapterVideo();</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">saveOrUpdate</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">this</span>.chapter.id) &#123;</span><br><span class="line">        <span class="built_in">this</span>.addChapter();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//......</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<h2 id="2-删除章节"><a href="#2-删除章节" class="headerlink" title="2. 删除章节"></a>2. 删除章节</h2><p>如果章节里面有小节，如何删除？</p>
<p>第一种：删除章节的时候，把章节里面的所有小节都删除</p>
<p>第二种：如果删除地章节下面有小节，不让进行删除</p>
<p>这里使用第二种方式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//删除章节</span></span><br><span class="line"><span class="meta">@DeleteMapping(&quot;&#123;chapterId&#125;&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> R <span class="title">deleteChapter</span><span class="params">(<span class="meta">@PathVariable</span> String chapterId)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> flag = eduChapterService.deleteChapter(chapterId);</span><br><span class="line">    <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">        <span class="keyword">return</span> R.ok();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> R.error();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//删除章节</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">deleteChapter</span><span class="params">(String chapterId)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//根据章节id查询章节里面的小节，如果有数据，则不进行删除</span></span><br><span class="line">    QueryWrapper&lt;EduVideo&gt; wrapper = <span class="keyword">new</span> QueryWrapper&lt;&gt;();</span><br><span class="line">    wrapper.eq(<span class="string">&quot;chapter_id&quot;</span>, chapterId);</span><br><span class="line">    <span class="keyword">int</span> count = eduVideoService.count(wrapper);</span><br><span class="line">    <span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//能查出小节</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> GuliException(<span class="number">20001</span>, <span class="string">&quot;不能删除&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> result = baseMapper.deleteById(chapterId);</span><br><span class="line">        <span class="keyword">return</span> result &gt; <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>前端：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//删除章节</span></span><br><span class="line"><span class="function"><span class="title">deleteChapter</span>(<span class="params">chapterId</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> request(&#123;</span><br><span class="line">        url: <span class="string">&#x27;/eduservice/chapter/&#x27;</span> + chapterId,</span><br><span class="line">        method: <span class="string">&#x27;delete&#x27;</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;el-button type&#x3D;&quot;text&quot; @click&#x3D;&quot;removeChapter(chapter.id)&quot;&gt;删除&lt;&#x2F;el-button&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//删除章节</span></span><br><span class="line"><span class="function"><span class="title">removeChapter</span>(<span class="params">chapterId</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.$confirm(<span class="string">&quot;此操作将删除章节, 是否继续?&quot;</span>, <span class="string">&quot;提示&quot;</span>, &#123;</span><br><span class="line">        confirmButtonText: <span class="string">&quot;确定&quot;</span>,</span><br><span class="line">        cancelButtonText: <span class="string">&quot;取消&quot;</span>,</span><br><span class="line">        type: <span class="string">&quot;warning&quot;</span>,</span><br><span class="line">    &#125;).then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">//点击确定，执行then方法</span></span><br><span class="line">        <span class="comment">//调用删除的方法</span></span><br><span class="line">        chapter.deleteChapter(chapterId).then(<span class="function">(<span class="params">response</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="comment">//删除成功</span></span><br><span class="line">            <span class="comment">//提示信息</span></span><br><span class="line">            <span class="built_in">this</span>.$message(&#123;</span><br><span class="line">                type: <span class="string">&quot;success&quot;</span>,</span><br><span class="line">                message: <span class="string">&quot;删除成功!&quot;</span>,</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="comment">//刷新页面</span></span><br><span class="line">            <span class="built_in">this</span>.getChapterVideo();</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;); <span class="comment">//点击取消，执行catch方法</span></span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<h2 id="3-修改章节"><a href="#3-修改章节" class="headerlink" title="3. 修改章节"></a>3. 修改章节</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;el-button style&#x3D;&quot;&quot; type&#x3D;&quot;text&quot; @click&#x3D;&quot;openEditChatper(chapter.id)&quot;&gt;编辑&lt;&#x2F;el-button&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//修改章节弹框数据回显</span></span><br><span class="line"><span class="function"><span class="title">openEditChatper</span>(<span class="params">chapterId</span>)</span> &#123;</span><br><span class="line">    <span class="comment">//弹框</span></span><br><span class="line">    <span class="built_in">this</span>.dialogChapterFormVisible = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">//调用接口</span></span><br><span class="line">    chapter.getChapter(chapterId).then(<span class="function">(<span class="params">response</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.chapter = response.data.chapter;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//修改章节的方法</span></span><br><span class="line"><span class="function"><span class="title">updateChapter</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    chapter.updateChapter(<span class="built_in">this</span>.chapter).then(<span class="function">(<span class="params">response</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">//关闭弹框</span></span><br><span class="line">        <span class="built_in">this</span>.dialogChapterFormVisible = <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">//提示</span></span><br><span class="line">        <span class="built_in">this</span>.$message(&#123;</span><br><span class="line">            type: <span class="string">&quot;success&quot;</span>,</span><br><span class="line">            message: <span class="string">&quot;修改章节成功!&quot;</span>,</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">//刷新页面</span></span><br><span class="line">        <span class="built_in">this</span>.getChapterVideo();</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">saveOrUpdate</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">this</span>.chapter.id) &#123;</span><br><span class="line">        <span class="built_in">this</span>.addChapter();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.updateChapter();</span><br><span class="line">        location.reload(); <span class="comment">//刷新</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//修改章节</span></span><br><span class="line"><span class="function"><span class="title">updateChapter</span>(<span class="params">chapter</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> request(&#123;</span><br><span class="line">        url: <span class="string">&#x27;/eduservice/chapter/updateChapter&#x27;</span>,</span><br><span class="line">        method: <span class="string">&#x27;post&#x27;</span>,</span><br><span class="line">        data: chapter</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<h1 id="课程小节"><a href="#课程小节" class="headerlink" title="课程小节"></a>课程小节</h1><h2 id="1-添加小节"><a href="#1-添加小节" class="headerlink" title="1. 添加小节"></a>1. 添加小节</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//添加小节</span></span><br><span class="line"><span class="meta">@PostMapping(&quot;addVideo&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> R <span class="title">addVideo</span><span class="params">(<span class="meta">@RequestBody</span> EduVideo eduVideo)</span> </span>&#123;</span><br><span class="line">    eduVideoService.save(eduVideo);</span><br><span class="line">    <span class="keyword">return</span> R.ok();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;el-button style&#x3D;&quot;&quot; type&#x3D;&quot;text&quot; @click&#x3D;&quot;openVideo(chapter.id)&quot;&gt;添加小节&lt;&#x2F;el-button&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//添加小节</span></span><br><span class="line"><span class="function"><span class="title">addVideo</span>(<span class="params">video</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> request(&#123;</span><br><span class="line">        url: <span class="string">&#x27;/eduservice/video/addVideo&#x27;</span>,</span><br><span class="line">        method: <span class="string">&#x27;post&#x27;</span>,</span><br><span class="line">        data: video</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//添加小节弹框的方法</span></span><br><span class="line"><span class="function"><span class="title">openVideo</span>(<span class="params">chapterId</span>)</span> &#123;</span><br><span class="line">    <span class="comment">//把文件列表清空</span></span><br><span class="line">    <span class="built_in">this</span>.fileList = [];</span><br><span class="line">    <span class="comment">//清空之前的数据</span></span><br><span class="line">    <span class="built_in">this</span>.video = &#123;&#125;;</span><br><span class="line">    <span class="comment">//弹框</span></span><br><span class="line">    <span class="built_in">this</span>.dialogVideoFormVisible = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">//设置章节id</span></span><br><span class="line">    <span class="built_in">this</span>.video.chapterId = chapterId;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//添加小节</span></span><br><span class="line"><span class="function"><span class="title">addVideo</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="comment">//设置课程id</span></span><br><span class="line">    <span class="built_in">this</span>.video.courseId = <span class="built_in">this</span>.courseId;</span><br><span class="line">    video.addVideo(<span class="built_in">this</span>.video).then(<span class="function">(<span class="params">response</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">//关闭弹框</span></span><br><span class="line">        <span class="built_in">this</span>.dialogVideoFormVisible = <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">//提示</span></span><br><span class="line">        <span class="built_in">this</span>.$message(&#123;</span><br><span class="line">            type: <span class="string">&quot;success&quot;</span>,</span><br><span class="line">            message: <span class="string">&quot;添加小节成功!&quot;</span>,</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">//刷新页面</span></span><br><span class="line">        <span class="built_in">this</span>.getChapterVideo();</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<h2 id="2-删除小节"><a href="#2-删除小节" class="headerlink" title="2.删除小节"></a>2.删除小节</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//删除小节，删除对应的阿里云中的视频</span></span><br><span class="line"><span class="meta">@DeleteMapping(&quot;&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> R <span class="title">deleteVideo</span><span class="params">(<span class="meta">@PathVariable</span> String id)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//根据小节id获取视频id，调用相应的方法实现删除</span></span><br><span class="line">    EduVideo eduVideo = eduVideoService.getById(id);</span><br><span class="line">    String videoSourceId = eduVideo.getVideoSourceId();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断小节里面是否有视频</span></span><br><span class="line">    <span class="keyword">if</span> (!StringUtils.isEmpty(videoSourceId)) &#123;</span><br><span class="line">        <span class="comment">//根据视频id，远程调用，删除视频</span></span><br><span class="line">        R result = vodClient.removeAliyunVideo(videoSourceId);</span><br><span class="line">        <span class="keyword">if</span> (result.getCode() == <span class="number">20001</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> GuliException(<span class="number">20001</span>, <span class="string">&quot;删除视频失败，熔断器&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//删除小节</span></span><br><span class="line">    eduVideoService.removeById(id);</span><br><span class="line">    <span class="keyword">return</span> R.ok();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;el-button type&#x3D;&quot;text&quot; @click&#x3D;&quot;removeVideo(video.id)&quot;&gt;删除&lt;&#x2F;el-button&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//删除小节</span></span><br><span class="line"><span class="function"><span class="title">removeVideo</span>(<span class="params">id</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.$confirm(<span class="string">&quot;此操作将删除小节, 是否继续?&quot;</span>, <span class="string">&quot;提示&quot;</span>, &#123;</span><br><span class="line">        confirmButtonText: <span class="string">&quot;确定&quot;</span>,</span><br><span class="line">        cancelButtonText: <span class="string">&quot;取消&quot;</span>,</span><br><span class="line">        type: <span class="string">&quot;warning&quot;</span>,</span><br><span class="line">    &#125;).then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">//点击确定，执行then方法</span></span><br><span class="line">        <span class="comment">//调用删除的方法</span></span><br><span class="line">        video.deleteVideo(id).then(<span class="function">(<span class="params">response</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="comment">//删除成功</span></span><br><span class="line">            <span class="comment">//提示信息</span></span><br><span class="line">            <span class="built_in">this</span>.$message(&#123;</span><br><span class="line">                type: <span class="string">&quot;success&quot;</span>,</span><br><span class="line">                message: <span class="string">&quot;删除小节成功!&quot;</span>,</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="comment">//刷新页面</span></span><br><span class="line">            <span class="built_in">this</span>.getChapterVideo();</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;); <span class="comment">//点击取消，执行catch方法</span></span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//删除小节</span></span><br><span class="line"><span class="function"><span class="title">deleteVideo</span>(<span class="params">id</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> request(&#123;</span><br><span class="line">        url: <span class="string">&#x27;/eduservice/video/&#x27;</span> + id,</span><br><span class="line">        method: <span class="string">&#x27;delete&#x27;</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<h2 id="3-修改小节"><a href="#3-修改小节" class="headerlink" title="3.修改小节"></a>3.修改小节</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//修改小节</span></span><br><span class="line"><span class="meta">@PostMapping(&quot;updateVideo&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> R <span class="title">updateVideo</span><span class="params">(<span class="meta">@RequestBody</span> EduVideo eduVideo)</span> </span>&#123;</span><br><span class="line">    eduVideoService.updateById(eduVideo);</span><br><span class="line">    <span class="keyword">return</span> R.ok();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;el-button type&#x3D;&quot;text&quot; @click&#x3D;&quot;getVideoInfo(video.id)&quot;&gt;编辑&lt;&#x2F;el-button&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//修改小节</span></span><br><span class="line"><span class="function"><span class="title">updateVideo</span>(<span class="params">video</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> request(&#123;</span><br><span class="line">        url: <span class="string">&#x27;/eduservice/video/updateVideo&#x27;</span>,</span><br><span class="line">        method: <span class="string">&#x27;post&#x27;</span>,</span><br><span class="line">        data: video</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//修改小节表单回显</span></span><br><span class="line"><span class="function"><span class="title">getVideoInfo</span>(<span class="params">videoId</span>)</span> &#123;</span><br><span class="line">    <span class="comment">//弹出小节弹窗</span></span><br><span class="line">    <span class="built_in">this</span>.dialogVideoFormVisible = <span class="literal">true</span>;</span><br><span class="line">    video.getVideoInfo(videoId).then(<span class="function">(<span class="params">resp</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.video = resp.data.video;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//小节修改</span></span><br><span class="line"><span class="function"><span class="title">updateVideo</span>(<span class="params">videoId</span>)</span> &#123;</span><br><span class="line">    <span class="comment">//设置小节id到video对象中</span></span><br><span class="line">    <span class="built_in">this</span>.video.id = videoId;</span><br><span class="line">    video.updateVideo(<span class="built_in">this</span>.video).then(<span class="function">(<span class="params">response</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">//关闭弹框</span></span><br><span class="line">        <span class="built_in">this</span>.dialogVideoFormVisible = <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">//提示信息</span></span><br><span class="line">        <span class="built_in">this</span>.$message(&#123;</span><br><span class="line">            message: <span class="string">&quot;修改小节成功&quot;</span>,</span><br><span class="line">            type: <span class="string">&quot;success&quot;</span>,</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">//刷新页面</span></span><br><span class="line">        <span class="built_in">this</span>.getChapterVideo();</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<h1 id="课程信息确认"><a href="#课程信息确认" class="headerlink" title="课程信息确认"></a>课程信息确认</h1><h2 id="1-多表连接查询"><a href="#1-多表连接查询" class="headerlink" title="1. 多表连接查询"></a>1. 多表连接查询</h2><p><img src="https://rulerofterabithia-blog.oss-cn-hangzhou.aliyuncs.com/img/20220524191932.png"></p>
<p>CoursePublishVo：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CoursePublishVo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String id;</span><br><span class="line">    <span class="keyword">private</span> String title;</span><br><span class="line">    <span class="keyword">private</span> String cover;</span><br><span class="line">    <span class="keyword">private</span> Integer lessonNum;</span><br><span class="line">    <span class="keyword">private</span> String subjectLevelOne;</span><br><span class="line">    <span class="keyword">private</span> String subjectLevelTwo;</span><br><span class="line">    <span class="keyword">private</span> String teacherName;</span><br><span class="line">    <span class="keyword">private</span> String price;<span class="comment">//只用于显示</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>EduCourseController：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//根据课程id查询课程确认信息</span></span><br><span class="line"><span class="meta">@GetMapping(&quot;getPublishCourseInfo/&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> R <span class="title">getPublishCourseInfo</span><span class="params">(<span class="meta">@PathVariable</span> String id)</span> </span>&#123;</span><br><span class="line">    CoursePublishVo coursePublishVo = courseService.publishCourseInfo(id);</span><br><span class="line">    <span class="keyword">return</span> R.ok().data(<span class="string">&quot;publishCourse&quot;</span>, coursePublishVo);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>EduCourseServiceImpl：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//根据课程id查询课程确认信息</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> CoursePublishVo <span class="title">publishCourseInfo</span><span class="params">(String id)</span> </span>&#123;</span><br><span class="line">    CoursePublishVo publishCourseInfo = baseMapper.getPublishCourseInfo(id);</span><br><span class="line">    <span class="keyword">return</span> publishCourseInfo;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>EduCourseMapper：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">EduCourseMapper</span> <span class="keyword">extends</span> <span class="title">BaseMapper</span>&lt;<span class="title">EduCourse</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> CoursePublishVo <span class="title">getPublishCourseInfo</span><span class="params">(String courseId)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>EduCourseMapper.xml：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--根据课程id查询课程确认信息--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getPublishCourseInfo&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.cyk.eduservice.entity.vo.CoursePublishVo&quot;</span>&gt;</span></span><br><span class="line">    SELECT ec.id,</span><br><span class="line">    ec.title,</span><br><span class="line">    ec.price,</span><br><span class="line">    ec.lesson_num AS lessonNum,</span><br><span class="line">    ec.cover,</span><br><span class="line">    et.name       AS teacherName,</span><br><span class="line">    es1.title     AS subjectLevelOne,</span><br><span class="line">    es2.title     AS subjectLevelTwo</span><br><span class="line">    FROM edu_course ec</span><br><span class="line">    LEFT OUTER JOIN edu_course_description ecd</span><br><span class="line">    ON ec.id = ecd.id</span><br><span class="line">    LEFT OUTER JOIN edu_teacher et</span><br><span class="line">    ON ec.teacher_id = et.id</span><br><span class="line">    LEFT OUTER JOIN edu_subject es1</span><br><span class="line">    ON ec.subject_parent_id = es1.id</span><br><span class="line">    LEFT OUTER JOIN edu_subject es2</span><br><span class="line">    ON ec.subject_id = es2.id</span><br><span class="line">    WHERE ec.id = #&#123;courseId&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="2-可能存在的问题？"><a href="#2-可能存在的问题？" class="headerlink" title="2. 可能存在的问题？"></a>2. 可能存在的问题？</h2><p><img src="https://rulerofterabithia-blog.oss-cn-hangzhou.aliyuncs.com/img/20220524192203.png"></p>
<p><img src="https://rulerofterabithia-blog.oss-cn-hangzhou.aliyuncs.com/img/20220524192941.png"></p>
<h2 id="3-前端实现"><a href="#3-前端实现" class="headerlink" title="3. 前端实现"></a>3. 前端实现</h2><p>首先要获取到路由中的课程id，根据此课程id查询展示</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">created</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="comment">//获取里面的课程id值</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.$route.params &amp;&amp; <span class="built_in">this</span>.$route.params.id) &#123;</span><br><span class="line">        <span class="built_in">this</span>.courseId = <span class="built_in">this</span>.$route.params.id;</span><br><span class="line">        <span class="comment">//调用接口方法根据课程id查询</span></span><br><span class="line">        <span class="built_in">this</span>.getCoursePublishId();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//根据课程id查询</span></span><br><span class="line"><span class="function"><span class="title">getCoursePublishId</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    course.getPublishCourseInfo(<span class="built_in">this</span>.courseId).then(<span class="function">(<span class="params">response</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.coursePublish = response.data.publishCourse;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//课程确认信息显示</span></span><br><span class="line"><span class="function"><span class="title">getPublishCourseInfo</span>(<span class="params">id</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> request(&#123;</span><br><span class="line">        url: <span class="string">&#x27;/eduservice/course/getPublishCourseInfo/&#x27;</span> + id,</span><br><span class="line">        method: <span class="string">&#x27;get&#x27;</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div class&#x3D;&quot;ccInfo&quot;&gt;</span><br><span class="line">    &lt;img :src&#x3D;&quot;coursePublish.cover&quot; &#x2F;&gt;</span><br><span class="line">    &lt;div class&#x3D;&quot;main&quot;&gt;</span><br><span class="line">        &lt;h2&gt;&#123;&#123; coursePublish.title &#125;&#125;&lt;&#x2F;h2&gt;</span><br><span class="line">        &lt;p class&#x3D;&quot;gray&quot;&gt;</span><br><span class="line">            &lt;span&gt;共&#123;&#123; coursePublish.lessonNum &#125;&#125;课时&lt;&#x2F;span&gt;</span><br><span class="line">        &lt;&#x2F;p&gt;</span><br><span class="line">        &lt;p&gt;</span><br><span class="line">            &lt;span&gt;所属分类：&#123;&#123; coursePublish.subjectLevelOne &#125;&#125; —</span><br><span class="line">                &#123;&#123; coursePublish.subjectLevelTwo &#125;&#125;&lt;&#x2F;span&gt;</span><br><span class="line">        &lt;&#x2F;p&gt;</span><br><span class="line">        &lt;p&gt;课程讲师：&#123;&#123; coursePublish.teacherName &#125;&#125;&lt;&#x2F;p&gt;</span><br><span class="line">        &lt;h3 class&#x3D;&quot;red&quot;&gt;￥&#123;&#123; coursePublish.price &#125;&#125;&lt;&#x2F;h3&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure>

<h2 id="4-最终发布"><a href="#4-最终发布" class="headerlink" title="4.最终发布"></a>4.最终发布</h2><p>修改课程的status状态是Normal(已发布)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//课程最终发布，修改课程状态</span></span><br><span class="line"><span class="meta">@PostMapping(&quot;publishCourse/&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> R <span class="title">publishCourse</span><span class="params">(<span class="meta">@PathVariable</span> String id)</span> </span>&#123;</span><br><span class="line">    EduCourse eduCourse = <span class="keyword">new</span> EduCourse();</span><br><span class="line">    eduCourse.setId(id);</span><br><span class="line">    eduCourse.setStatus(<span class="string">&quot;Normal&quot;</span>);<span class="comment">//设置课程发布状态</span></span><br><span class="line">    courseService.updateById(eduCourse);</span><br><span class="line">    <span class="keyword">return</span> R.ok();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//课程最终发布</span></span><br><span class="line"><span class="function"><span class="title">publishCourse</span>(<span class="params">id</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> request(&#123;</span><br><span class="line">        url: <span class="string">&#x27;/eduservice/course/publishCourse/&#x27;</span> + id,</span><br><span class="line">        method: <span class="string">&#x27;post&#x27;</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//最终发布</span></span><br><span class="line"><span class="function"><span class="title">publish</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    course.publishCourse(<span class="built_in">this</span>.courseId).then(<span class="function">(<span class="params">response</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">//提示</span></span><br><span class="line">        <span class="built_in">this</span>.$message(&#123;</span><br><span class="line">            type: <span class="string">&quot;success&quot;</span>,</span><br><span class="line">            message: <span class="string">&quot;课程发布成功!&quot;</span>,</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">//跳转课程列表页面</span></span><br><span class="line">        <span class="built_in">this</span>.$router.push(&#123; <span class="attr">path</span>: <span class="string">&quot;/course/list&quot;</span> &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<h1 id="课程列表"><a href="#课程列表" class="headerlink" title="课程列表"></a>课程列表</h1><p>类似于讲师列表</p>
<p><img src="https://rulerofterabithia-blog.oss-cn-hangzhou.aliyuncs.com/img/20220525144554.png"></p>
<h2 id="删除课程"><a href="#删除课程" class="headerlink" title="删除课程"></a>删除课程</h2><p>一般不用外键做约束，因为如果用外键作为约束条件，在删除课程时，需要先删除章节表中的数据，否则，课程表中的数据无法被删除</p>
<p><img src="https://rulerofterabithia-blog.oss-cn-hangzhou.aliyuncs.com/img/20220525145251.png"></p>
<h1 id="阿里云视频点播"><a href="#阿里云视频点播" class="headerlink" title="阿里云视频点播"></a>阿里云视频点播</h1><h2 id="1-视频地址"><a href="#1-视频地址" class="headerlink" title="1. 视频地址"></a>1. 视频地址</h2><p>在线教育平台中，所有的视频都需要上传到阿里云，使用阿里云点播技术，通过获取阿里云中的视频地址，可以进行视频播放</p>
<h2 id="2-视频加密"><a href="#2-视频加密" class="headerlink" title="2. 视频加密"></a>2. 视频加密</h2><p>我们需要在阿里云中对视频进行加密，防止视频被盗取，但是在加密之后，无法再通过视频地址播放视频</p>
<h2 id="3-视频id"><a href="#3-视频id" class="headerlink" title="3. 视频id"></a>3. 视频id</h2><p>通过视频id，可以获取到加密视频的播放凭证和播放地址，通过播放凭证既可以播放加密视频，也可以播放非加密视频。所以，需要<strong>在数据库中存储视频id</strong></p>
<p><img src="https://rulerofterabithia-blog.oss-cn-hangzhou.aliyuncs.com/img/20220525151654.png"></p>
<h2 id="4-获取视频凭证"><a href="#4-获取视频凭证" class="headerlink" title="4. 获取视频凭证"></a>4. 获取视频凭证</h2><p><img src="https://rulerofterabithia-blog.oss-cn-hangzhou.aliyuncs.com/img/20220525152624.png"></p>
<h2 id="5-上传视频测试"><a href="#5-上传视频测试" class="headerlink" title="5. 上传视频测试"></a>5. 上传视频测试</h2><p>手动安装jar包</p>
<p><img src="https://rulerofterabithia-blog.oss-cn-hangzhou.aliyuncs.com/img/20220525155547.png"></p>
<h2 id="6-上传小节视频"><a href="#6-上传小节视频" class="headerlink" title="6. 上传小节视频"></a>6. 上传小节视频</h2><p><img src="https://rulerofterabithia-blog.oss-cn-hangzhou.aliyuncs.com/img/20220525162047.png"></p>
]]></content>
  </entry>
  <entry>
    <title>MySQL</title>
    <url>/hexo-blog/2022/04/08/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="MySQL数据库笔记"><a href="#MySQL数据库笔记" class="headerlink" title="MySQL数据库笔记"></a>MySQL数据库笔记</h1><h2 id="第一部分-MySQL基础篇"><a href="#第一部分-MySQL基础篇" class="headerlink" title="第一部分 MySQL基础篇"></a>第一部分 MySQL基础篇</h2><h3 id="第01章-数据库概述"><a href="#第01章-数据库概述" class="headerlink" title="第01章 数据库概述"></a>第01章 数据库概述</h3><h4 id="1-为什么要使用数据库"><a href="#1-为什么要使用数据库" class="headerlink" title="1. 为什么要使用数据库"></a>1. 为什么要使用数据库</h4><ul>
<li>持久化(persistence)：<strong>把数据保存到可掉电式存储设备中以供之后使用</strong>。大多数情况下，特别是企业级应用，<strong>数据持久化意味着将内存中的数据保存到硬盘上加以“固化”</strong>，而持久化的实现过程大多通过各种关系数据库来完成。</li>
<li>持久化的主要作用是<strong>将内存中的数据存储在关系型数据库中</strong>，当然也可以存储在磁盘文件、XML数据文件中。</li>
</ul>
<h4 id="2-数据库与数据库管理系统"><a href="#2-数据库与数据库管理系统" class="headerlink" title="2. 数据库与数据库管理系统"></a>2. 数据库与数据库管理系统</h4><h5 id="2-1-数据库的相关概念"><a href="#2-1-数据库的相关概念" class="headerlink" title="2.1 数据库的相关概念"></a>2.1 数据库的相关概念</h5><ul>
<li><p><strong>DB：数据库(Database)</strong></p>
<ul>
<li>即存储数据的“仓库”，其本质是一个文件系统。它保存了一系列有组织的数据。</li>
</ul>
</li>
<li><p><strong>DBMS：数据库管理系统(Database Management System)</strong></p>
<ul>
<li>是一种操纵和管理数据库的大型软件，用于建立、使用和维护数据库，对数据库进行统一管理和控制。用户通过数据库管理系统访问数据库中表内的数据。</li>
</ul>
</li>
<li><p><strong>SQL：结构化查询语言（Structured Query Language）</strong></p>
<ul>
<li>专门用来与数据库通信的语言。</li>
</ul>
</li>
</ul>
<h4 id="3-RDBMS与非RDBMS"><a href="#3-RDBMS与非RDBMS" class="headerlink" title="3. RDBMS与非RDBMS"></a>3. RDBMS与非RDBMS</h4><h5 id="3-1-关系型数据库-RDBMS"><a href="#3-1-关系型数据库-RDBMS" class="headerlink" title="3.1 关系型数据库(RDBMS)"></a>3.1 关系型数据库(RDBMS)</h5><h6 id="3-1-1-实质"><a href="#3-1-1-实质" class="headerlink" title="3.1.1 实质"></a>3.1.1 实质</h6><ul>
<li>这种类型的数据库是<strong>最古老</strong>的数据库类型，关系型数据库模型是把复杂的数据结构归结为简单的<strong>二元关系</strong> （即二维表格形式）。</li>
<li>关系型数据库以**行(row)<strong>和</strong>列(column)<strong>的形式存储数据，以便于用户理解。这一系列的行和列被称为</strong>表(table)<strong>，一组表组成了一个</strong>库(database)**。</li>
<li>SQL就是关系型数据库的查询语言。</li>
</ul>
<h6 id="3-1-2-优势"><a href="#3-1-2-优势" class="headerlink" title="3.1.2 优势"></a>3.1.2 优势</h6><ul>
<li><strong>复杂查询</strong>可以用SQL语句方便的在一个表以及多个表之间做非常复杂的数据查询。</li>
<li><strong>事务支持</strong>使得对于安全性能很高的数据访问要求得以实现。</li>
</ul>
<h5 id="3-2-非关系型数据库-非RDBMS"><a href="#3-2-非关系型数据库-非RDBMS" class="headerlink" title="3.2 非关系型数据库(非RDBMS)"></a>3.2 非关系型数据库(非RDBMS)</h5><h6 id="3-2-1-介绍"><a href="#3-2-1-介绍" class="headerlink" title="3.2.1 介绍"></a>3.2.1 介绍</h6><p><strong>非关系型数据库</strong>，可看成传统关系型数据库的功能<strong>阉割版本</strong>，基于键值对存储数据，不需要经过SQL层的解析，<strong>性能非常高</strong>。同时，通过减少不常用的功能，进一步提高性能。</p>
<h4 id="4-关系型数据库设计规则"><a href="#4-关系型数据库设计规则" class="headerlink" title="4. 关系型数据库设计规则"></a>4. 关系型数据库设计规则</h4><ul>
<li>一个数据库中可以有多个表，每个表都有一个名字，用来标识自己。表名具有唯一性。</li>
<li>表具有一些特性，这些特性定义了数据在表中如何存储，类似Java和Python中 “类”的设计。</li>
</ul>
<h5 id="4-1-表、记录、字段"><a href="#4-1-表、记录、字段" class="headerlink" title="4.1 表、记录、字段"></a>4.1 表、记录、字段</h5><ul>
<li>E-R（entity-relationship，实体-联系）模型中有三个主要概念是：<strong>实体集</strong>、<strong>属性</strong>、<strong>联系集</strong>。</li>
<li>一个实体集（class）对应于数据库中的一个表（table），一个实体（instance）则对应于数据库表中的一行（row），也称为一条记录（record）。一个属性（attribute）对应于数据库表中的一列（column），也称为一个字段（field）。</li>
</ul>
<h5 id="4-2-表的关联关系"><a href="#4-2-表的关联关系" class="headerlink" title="4.2 表的关联关系"></a>4.2 表的关联关系</h5><ul>
<li>表与表之间的数据记录有关系(relationship)。现实世界中的各种实体以及实体之间的各种联系均用关系模型来表示。</li>
<li>四种：一对一关联、一对多关联、多对多关联、自我引用</li>
</ul>
<h3 id="第02章-MySQL环境搭建（略）"><a href="#第02章-MySQL环境搭建（略）" class="headerlink" title="第02章 MySQL环境搭建（略）"></a>第02章 MySQL环境搭建（略）</h3><h4 id="1-MySQL演示使用"><a href="#1-MySQL演示使用" class="headerlink" title="1. MySQL演示使用"></a>1. MySQL演示使用</h4><h5 id="1-1-MySQL的编码设置"><a href="#1-1-MySQL的编码设置" class="headerlink" title="1.1 MySQL的编码设置"></a>1.1 MySQL的编码设置</h5><p><strong>MySQL5.7中</strong></p>
<p><strong>问题再现：命令行操作sql乱码问题</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">INSERT</span> <span class="keyword">INTO</span> t_stu <span class="keyword">VALUES</span>(<span class="number">1</span>,<span class="string">&#x27;张三&#x27;</span>,<span class="string">&#x27;男&#x27;</span>);</span><br><span class="line">ERROR <span class="number">1366</span> (HY000): Incorrect string <span class="keyword">value</span>: <span class="string">&#x27;\xD5\xC5\xC8\xFD&#x27;</span> <span class="keyword">for</span> <span class="keyword">column</span> <span class="string">&#x27;sname&#x27;</span> <span class="keyword">at</span> <span class="type">row</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p><strong>问题解决</strong></p>
<p>步骤1：查看编码命令</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;character_%&#x27;</span>;</span><br><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;collation_%&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>步骤2：修改mysql的数据目录下的my.ini配置文件</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">default-character-set</span>=utf8 <span class="comment">#默认字符集 [mysqld]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 大概在76行左右，在其下添加</span></span><br><span class="line">...</span><br><span class="line"><span class="attr">character-set-server</span>=utf8</span><br><span class="line"><span class="attr">collation-server</span>=utf8_general_ci</span><br></pre></td></tr></table></figure>

<p>步骤3：重启服务</p>
<p>步骤4：查看编码命令</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;character_%&#x27;</span>;</span><br><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;collation_%&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p><strong>MySQL8.0中</strong></p>
<p>在MySQL 8.0版本之前，默认字符集为latin1，utf8字符集指向的是utf8mb3。网站开发人员在数据库设计的时候往往会将编码修改为utf8字符集。如果遗忘修改默认的编码，就会出现乱码的问题。从MySQL 8.0开始，数据库的默认编码改为<strong>utf8mb4</strong>，从而避免了上述的乱码问题。</p>
<h4 id="问题1：root用户密码忘记，重置的操作"><a href="#问题1：root用户密码忘记，重置的操作" class="headerlink" title="问题1：root用户密码忘记，重置的操作"></a>问题1：root用户密码忘记，重置的操作</h4><p>1: 通过任务管理器或者服务管理，关掉mysqld(服务进程)</p>
<p>2: 通过命令行+特殊参数开启mysqld mysqld – defaults-file=”D:\ProgramFiles\mysql\MySQLServer5.7Data\my.ini” –skip-grant-tables </p>
<p>3: 此时，mysqld服务进程已经打开。并且不需要权限检查</p>
<p>4: mysql -uroot 无密码登陆服务器。另启动一个客户端进行</p>
<p>5: 修改权限表 （1） use mysql; （2）update user set authentication_string=password(‘新密码’) where user=’root’ and Host=’localhost’; （3）flush privileges;</p>
<p>6: 通过任务管理器，关掉mysqld服务进程。</p>
<p>7: 再次通过服务管理，打开mysql服务。</p>
<p>8: 即可用修改后的新密码登陆。</p>
<h4 id="问题2：mysql命令报“不是内部或外部命令”"><a href="#问题2：mysql命令报“不是内部或外部命令”" class="headerlink" title="问题2：mysql命令报“不是内部或外部命令”"></a>问题2：mysql命令报“不是内部或外部命令”</h4><p>如果输入mysql命令报“不是内部或外部命令”，把mysql安装目录的bin目录配置到环境变量path中。</p>
<h4 id="问题3：-No-database-selected"><a href="#问题3：-No-database-selected" class="headerlink" title="问题3： No database selected"></a>问题3： No database selected</h4><p>解决方案一：就是使用“USE 数据库名;”语句，这样接下来的语句就默认针对这个数据库进行操作</p>
<p>解决方案二：就是所有的表对象前面都加上“数据库.” </p>
<h4 id="问题4：命令行客户端的字符集问题"><a href="#问题4：命令行客户端的字符集问题" class="headerlink" title="问题4：命令行客户端的字符集问题"></a>问题4：命令行客户端的字符集问题</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">INSERT</span> <span class="keyword">INTO</span> t_stu <span class="keyword">VALUES</span>(<span class="number">1</span>,<span class="string">&#x27;张三&#x27;</span>,<span class="string">&#x27;男&#x27;</span>);</span><br><span class="line">ERROR <span class="number">1366</span> (HY000): Incorrect string <span class="keyword">value</span>: <span class="string">&#x27;\xD5\xC5\xC8\xFD&#x27;</span> <span class="keyword">for</span> <span class="keyword">column</span> <span class="string">&#x27;sname&#x27;</span> <span class="keyword">at</span> <span class="type">row</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>查看所有字符集：<code>SHOW VARIABLES LIKE &#39;character_set_%&#39;; </code></p>
<p>解决方案，设置当前连接的客户端字符集 <code>SET NAMES GBK;</code></p>
<h4 id="问题5：修改数据库和表的字符编码"><a href="#问题5：修改数据库和表的字符编码" class="headerlink" title="问题5：修改数据库和表的字符编码"></a>问题5：修改数据库和表的字符编码</h4><p>修改编码：</p>
<p>（1)先停止服务，（2）修改my.ini文件（3）重新启动服务</p>
<p>说明：</p>
<p>如果是在修改my.ini之前建的库和表，那么库和表的编码还是原来的Latin1，要么删了重建，要么使用alter语句修改编码。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">create</span> database <span class="number">0728</span>db charset Latin1;</span><br><span class="line">Query OK, <span class="number">1</span> <span class="type">row</span> affected (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> use <span class="number">0728</span>db;</span><br><span class="line">Database changed</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> <span class="keyword">create</span> <span class="keyword">table</span> student\G</span><br><span class="line"><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span> <span class="number">1.</span> <span class="type">row</span> <span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span></span><br><span class="line"><span class="keyword">Table</span>: student </span><br><span class="line"><span class="keyword">Create</span> <span class="keyword">Table</span>: <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `student` ( `id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>, `name` <span class="type">varchar</span>(<span class="number">20</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>, <span class="keyword">PRIMARY</span> KEY (`id`) ) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>latin1 <span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">alter</span> <span class="keyword">table</span> student charset utf8; #修改表字符编码为UTF8</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.01</span> sec)</span><br><span class="line">Records: <span class="number">0</span> Duplicates: <span class="number">0</span> Warnings: <span class="number">0</span></span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> <span class="keyword">create</span> <span class="keyword">table</span> student\G</span><br><span class="line"><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span> <span class="number">1.</span> <span class="type">row</span> <span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span></span><br><span class="line"><span class="keyword">Table</span>: student</span><br><span class="line"><span class="keyword">Create</span> <span class="keyword">Table</span>: <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `student` ( `id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>, `name` <span class="type">varchar</span>(<span class="number">20</span>) <span class="type">CHARACTER</span> <span class="keyword">SET</span> latin1 <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>, #字段仍然是latin1编码 <span class="keyword">PRIMARY</span> KEY (`id`) ) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8</span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">alter</span> <span class="keyword">table</span> student modify name <span class="type">varchar</span>(<span class="number">20</span>) charset utf8; #修改字段字符编码为UTF8</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.05</span> sec)</span><br><span class="line">Records: <span class="number">0</span> Duplicates: <span class="number">0</span> Warnings: <span class="number">0</span></span><br><span class="line">                                      </span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> <span class="keyword">create</span> <span class="keyword">table</span> student\G</span><br><span class="line"><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span> <span class="number">1.</span> <span class="type">row</span> <span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span></span><br><span class="line"><span class="keyword">Table</span>: student </span><br><span class="line"><span class="keyword">Create</span> <span class="keyword">Table</span>: <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `student` ( `id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>, `name` <span class="type">varchar</span>(<span class="number">20</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>, <span class="keyword">PRIMARY</span> KEY (`id`) ) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8 <span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> <span class="keyword">create</span> database <span class="number">0728</span>db;</span><br><span class="line"><span class="operator">+</span><span class="comment">--------+-----------------------------------------------------------------+</span></span><br><span class="line"><span class="operator">|</span>Database<span class="operator">|</span> <span class="keyword">Create</span> Database <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------+-------------------------------------------------------------------+</span></span><br><span class="line"><span class="operator">|</span><span class="number">0728</span>db<span class="operator">|</span> <span class="keyword">CREATE</span> DATABASE `<span class="number">0728</span>db` <span class="comment">/*!40100 DEFAULT CHARACTER SET latin1 */</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------+-------------------------------------------------------------------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">alter</span> database <span class="number">0728</span>db charset utf8; #修改数据库的字符编码为utf8</span><br><span class="line">Query OK, <span class="number">1</span> <span class="type">row</span> affected (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>

<h3 id="第03章-基本的SELECT语句"><a href="#第03章-基本的SELECT语句" class="headerlink" title="第03章 基本的SELECT语句"></a>第03章 基本的SELECT语句</h3><h4 id="1-SQL概述"><a href="#1-SQL概述" class="headerlink" title="1. SQL概述"></a>1. SQL概述</h4><h5 id="1-1-SQL分类"><a href="#1-1-SQL分类" class="headerlink" title="1.1 SQL分类"></a>1.1 SQL分类</h5><ul>
<li><p>DDL:数据定义语言。<code>CREATE</code> \ <code>ALTER</code> \ <code>DROP</code> \ <code>RENAME</code> \ <code>TRUNCATE</code></p>
</li>
<li><p>DML:数据操作语言。<code>INSERT</code> \ <code>DELETE</code> \ <code>UPDATE</code> \ <code>SELECT</code> （重中之重）</p>
</li>
<li><p>DCL:数据控制语言。<code>COMMIT</code> \ <code>ROLLBACK</code> \ <code>SAVEPOINT</code> \ <code>GRANT</code> \ <code>REVOKE</code></p>
</li>
</ul>
<h4 id="2-SQL语言的规则与规范"><a href="#2-SQL语言的规则与规范" class="headerlink" title="2. SQL语言的规则与规范"></a>2. SQL语言的规则与规范</h4><h5 id="2-1-基本规则"><a href="#2-1-基本规则" class="headerlink" title="2.1 基本规则"></a>2.1 基本规则</h5><ul>
<li>SQL 可以写在一行或者多行。为了提高可读性，各子句分行写，必要时使用缩进</li>
<li>每条命令以 ; 或 \g 或 \G 结束</li>
<li>关键字不能被缩写也不能分行</li>
<li>关于标点符号<ul>
<li>必须保证所有的()、单引号、双引号是成对结束的</li>
<li>必须使用英文状态下的半角输入方式</li>
<li>字符串型和日期时间类型的数据可以使用单引号（’ ‘）表示</li>
<li>列的别名，尽量使用双引号（” “），而且不建议省略as</li>
</ul>
</li>
</ul>
<h5 id="2-2-SQL大小写规范-（建议遵守）"><a href="#2-2-SQL大小写规范-（建议遵守）" class="headerlink" title="2.2 SQL大小写规范 （建议遵守）"></a>2.2 SQL大小写规范 （建议遵守）</h5><ul>
<li><strong>MySQL在Windows环境下是大小写不敏感的</strong></li>
<li><strong>MySQL在Linux环境下是大小写敏感的</strong><ul>
<li>数据库名、表名、表的别名、变量名是严格区分大小写的</li>
<li>关键字、函数名、列名(或字段名)、列的别名(字段的别名) 是忽略大小写的。</li>
</ul>
</li>
<li><strong>推荐采用统一的书写规范：</strong><ul>
<li>数据库名、表名、表别名、字段名、字段别名等都小写</li>
<li>SQL 关键字、函数名、绑定变量等都大写</li>
</ul>
</li>
</ul>
<h5 id="2-3-注-释"><a href="#2-3-注-释" class="headerlink" title="2.3 注 释"></a>2.3 注 释</h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">单行注释：#注释文字(MySQL特有的方式)</span><br><span class="line">单行注释：<span class="comment">-- 注释文字(--后面必须包含一个空格。)</span></span><br><span class="line">多行注释：<span class="comment">/* 注释文字 */</span></span><br></pre></td></tr></table></figure>

<h5 id="2-4-命名规则（暂时了解）"><a href="#2-4-命名规则（暂时了解）" class="headerlink" title="2.4 命名规则（暂时了解）"></a>2.4 命名规则（暂时了解）</h5><ul>
<li>数据库、表名不得超过30个字符，变量名限制为29个</li>
<li>必须只能包含 A–Z, a–z, 0–9, _共63个字符</li>
<li>数据库名、表名、字段名等对象名中间不要包含空格</li>
<li>同一个MySQL软件中，数据库不能同名；同一个库中，表不能重名；同一个表中，字段不能重名</li>
<li>必须保证你的字段没有和保留字、数据库系统或常用方法冲突。如果坚持使用，请在SQL语句中使用`（着重号）引起来</li>
<li>保持字段名和类型的一致性，在命名字段并为其指定数据类型的时候一定要保证一致性。假如数据类型在一个表里是整数，那在另一个表里可就别变成字符型了</li>
</ul>
<h5 id="2-5-数据导入指令"><a href="#2-5-数据导入指令" class="headerlink" title="2.5 数据导入指令"></a>2.5 数据导入指令</h5><p>在命令行客户端登录mysql，使用source指令导入</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> source d:\mysqldb.sql</span><br></pre></td></tr></table></figure>

<h4 id="3-基本的SELECT语句"><a href="#3-基本的SELECT语句" class="headerlink" title="3. 基本的SELECT语句"></a>3. 基本的SELECT语句</h4><h5 id="3-0-SELECT…"><a href="#3-0-SELECT…" class="headerlink" title="3.0 SELECT…"></a>3.0 SELECT…</h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="number">1</span>; #没有任何子句</span><br><span class="line"><span class="keyword">SELECT</span> <span class="number">1</span> <span class="operator">+</span> <span class="number">1</span>,<span class="number">3</span> <span class="operator">*</span> <span class="number">2</span></span><br><span class="line"><span class="keyword">FROM</span> DUAL; #dual：伪表</span><br></pre></td></tr></table></figure>

<h5 id="3-1-SELECT-…-FROM"><a href="#3-1-SELECT-…-FROM" class="headerlink" title="3.1 SELECT … FROM"></a><strong>3.1 SELECT … FROM</strong></h5><ul>
<li>语法：</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 标识选择哪些列</span><br><span class="line"><span class="keyword">FROM</span> 标识从哪个表中选择</span><br></pre></td></tr></table></figure>

<ul>
<li>选择全部列：</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> </span><br><span class="line"><span class="keyword">FROM</span> departments;</span><br></pre></td></tr></table></figure>

<ul>
<li>选择特定的列：</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> department_id, location_id</span><br><span class="line"><span class="keyword">FROM</span> departments;</span><br></pre></td></tr></table></figure>

<h5 id="3-2-列的别名"><a href="#3-2-列的别名" class="headerlink" title="3.2 列的别名"></a><strong>3.2</strong> <strong>列的别名</strong></h5><ul>
<li>重命名一个列</li>
<li>便于计算</li>
<li>紧跟列名，也可以<strong>在列名和别名之间加入关键字AS，别名使用双引号</strong>，以便在别名中包含空格或特殊的字符并区分大小写。</li>
<li>AS 可以省略</li>
<li>建议别名简短，见名知意</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> last_name <span class="keyword">AS</span> name, commission_pct comm </span><br><span class="line"><span class="keyword">FROM</span> employees;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> last_name &quot;Name&quot;, salary<span class="operator">*</span><span class="number">12</span> &quot;Annual Salary&quot;</span><br><span class="line"><span class="keyword">FROM</span> employees;</span><br></pre></td></tr></table></figure>

<h5 id="3-3-去除重复行"><a href="#3-3-去除重复行" class="headerlink" title="3.3 去除重复行"></a><strong>3.3</strong> <strong>去除重复行</strong></h5><p><strong>在SELECT语句中使用关键字DISTINCT去除重复行</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> department_id,salary </span><br><span class="line"><span class="keyword">FROM</span> employees;</span><br></pre></td></tr></table></figure>

<p>这里有两点需要注意：</p>
<ol>
<li><p><code>DISTINCT</code>需要放到所有列名的前面，如果写成<code>SELECT salary, DISTINCT department_id FROM employees</code>会报错。</p>
</li>
<li><p><code>DISTINCT</code>其实是对后面所有列名的组合进行去重。如果你想要看都有哪些不同的部门（department_id），只需要写<code>DISTINCT department_id</code>即可，后面不需要再加其他的列名了。</p>
</li>
</ol>
<h5 id="3-4-空值参与运算"><a href="#3-4-空值参与运算" class="headerlink" title="3.4 空值参与运算"></a><strong>3.4</strong> <strong>空值参与运算</strong></h5><ul>
<li>所有运算符或列值遇到null值，运算的结果都为null</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> employee_id,salary,commission_pct, <span class="number">12</span> <span class="operator">*</span> salary <span class="operator">*</span> (<span class="number">1</span> <span class="operator">+</span> commission_pct) &quot;annual_sal&quot; </span><br><span class="line"><span class="keyword">FROM</span> employees;</span><br></pre></td></tr></table></figure>

<p>在 MySQL 里面， 空值不等于空字符串。一个空字符串的长度是 0，而一个空值的长度是空。而且，在 MySQL 里面，空值是占用空间的。</p>
<h5 id="3-5-着重号"><a href="#3-5-着重号" class="headerlink" title="3.5 着重号"></a><strong>3.5</strong> <strong>着重号</strong></h5><ul>
<li>错误的</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="keyword">ORDER</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>正确的</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> `<span class="keyword">ORDER</span>`;</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> `<span class="keyword">order</span>`;</span><br></pre></td></tr></table></figure>

<ul>
<li>结论</li>
</ul>
<p>我们需要保证表中的字段、表名等没有和保留字、数据库系统或常用方法冲突。如果真的相同，请在SQL语句中使用一对``（着重号）引起来。</p>
<h5 id="3-6-查询常数"><a href="#3-6-查询常数" class="headerlink" title="3.6 查询常数"></a><strong>3.6 查询常数</strong></h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="string">&#x27;尚硅谷&#x27;</span> <span class="keyword">as</span> corporation, last_name</span><br><span class="line"><span class="keyword">FROM</span> employees;</span><br></pre></td></tr></table></figure>

<h4 id="4-显示表结构"><a href="#4-显示表结构" class="headerlink" title="4. 显示表结构"></a><strong>4.</strong> <strong>显示表结构</strong></h4><p>使用DESCRIBE 或 DESC 命令，表示表结构。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DESCRIBE</span> employees;</span><br><span class="line">或</span><br><span class="line"><span class="keyword">DESC</span> employees;</span><br></pre></td></tr></table></figure>

<h4 id="5-过滤数据"><a href="#5-过滤数据" class="headerlink" title="5. 过滤数据"></a><strong>5.</strong> <strong>过滤数据</strong></h4><ul>
<li>语法<ul>
<li>使用WHERE 子句，将不满足条件的行过滤掉</li>
<li><strong>WHERE子句紧随FROM子句</strong></li>
</ul>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 字段<span class="number">1</span>,字段<span class="number">2</span></span><br><span class="line"><span class="keyword">FROM</span> 表名</span><br><span class="line"><span class="keyword">WHERE</span> 过滤条件</span><br></pre></td></tr></table></figure>

<ul>
<li>举例</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> employee_id, last_name, job_id, department_id</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> department_id <span class="operator">=</span> <span class="number">90</span>;</span><br></pre></td></tr></table></figure>

<h3 id="第04章-运算符"><a href="#第04章-运算符" class="headerlink" title="第04章 运算符"></a>第04章 运算符</h3><h4 id="1-算术运算符"><a href="#1-算术运算符" class="headerlink" title="1. 算术运算符"></a><strong>1.</strong> <strong>算术运算符</strong></h4><table>
<thead>
<tr>
<th>运算符</th>
<th>名称</th>
<th>作用</th>
<th>实例</th>
</tr>
</thead>
<tbody><tr>
<td>+</td>
<td>加法运算符</td>
<td>计算两个值或表达式的和</td>
<td>SELECT A + B</td>
</tr>
<tr>
<td>-</td>
<td>减法运算符</td>
<td>计算两个值或表达式的差</td>
<td>SELECT A - B</td>
</tr>
<tr>
<td>*</td>
<td>乘法运算符</td>
<td>计算两个值或表达式的乘积</td>
<td>SELECT A * B</td>
</tr>
<tr>
<td>/ 或 DIV</td>
<td>除法运算符</td>
<td>计算两个值或表达式的商</td>
<td>SELECT A / B 或者 SELECT A DIV B</td>
</tr>
<tr>
<td>% 或 MOD</td>
<td>求模（求余）运算符</td>
<td>计算两个值或表达式的余数</td>
<td>SELECT A % B 或者 SELECT A MOD B</td>
</tr>
</tbody></table>
<p>加法与减法运算符结论:</p>
<blockquote>
<ul>
<li>一个整数类型的值对整数进行加法和减法操作，结果还是一个整数；</li>
<li>一个整数类型的值对浮点数进行加法和减法操作，结果是一个浮点数；</li>
<li>加法和减法的优先级相同，进行先加后减操作与进行先减后加操作的结果是一样的；</li>
<li><strong>在Java中，+的左右两边如果有字符串，那么表示字符串的拼接。但是在MySQL中+只表示数值相加。如果遇到非数值类型，先尝试转成数值，如果转失败，就按0计算。（补充：MySQL中字符串拼接要使用字符串函数CONCAT()实现）</strong></li>
</ul>
</blockquote>
<p>乘法与除法运算符结论:</p>
<blockquote>
<ul>
<li>一个数乘以整数1和除以整数1后仍得原数；</li>
<li>一个数乘以浮点数1和除以浮点数1后变成浮点数，数值与原数相等；</li>
<li><strong>一个数除以整数后，不管是否能除尽，结果都为一个浮点数</strong>；</li>
<li>一个数除以另一个数，除不尽时，结果为一个浮点数，并保留到小数点后4位；</li>
<li>乘法和除法的优先级相同，进行先乘后除操作与先除后乘操作，得出的结果相同。</li>
<li><strong>在数学运算中，0不能用作除数，在MySQL中，一个数除以0为NULL。</strong> </li>
</ul>
</blockquote>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 取模运算： <span class="operator">%</span> mod</span><br><span class="line"><span class="keyword">SELECT</span> <span class="number">12</span> <span class="operator">%</span> <span class="number">3</span>,<span class="number">12</span> <span class="operator">%</span> <span class="number">5</span>, <span class="number">12</span> MOD <span class="number">-5</span>,<span class="number">-12</span> <span class="operator">%</span> <span class="number">5</span>,<span class="number">-12</span> <span class="operator">%</span> <span class="number">-5</span></span><br><span class="line"><span class="keyword">FROM</span> DUAL; # 结果的符号只与被模数有关</span><br><span class="line"><span class="operator">+</span><span class="comment">--------+--------+-----------+---------+----------+</span></span><br><span class="line"><span class="operator">|</span> <span class="number">12</span> <span class="operator">%</span> <span class="number">3</span> <span class="operator">|</span> <span class="number">12</span> <span class="operator">%</span> <span class="number">5</span> <span class="operator">|</span> <span class="number">12</span> MOD <span class="number">-5</span> <span class="operator">|</span> <span class="number">-12</span> <span class="operator">%</span> <span class="number">5</span> <span class="operator">|</span> <span class="number">-12</span> <span class="operator">%</span> <span class="number">-5</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------+--------+-----------+---------+----------+</span></span><br><span class="line"><span class="operator">|</span>      <span class="number">0</span> <span class="operator">|</span>      <span class="number">2</span> <span class="operator">|</span>         <span class="number">2</span> <span class="operator">|</span>      <span class="number">-2</span> <span class="operator">|</span>       <span class="number">-2</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------+--------+-----------+---------+----------+</span></span><br></pre></td></tr></table></figure>

<h4 id="2-比较运算符"><a href="#2-比较运算符" class="headerlink" title="2. 比较运算符"></a><strong>2.</strong> <strong>比较运算符</strong></h4><p>比较运算符用来对表达式左边的操作数和右边的操作数进行比较，比较的结果为真则返回1，比较的结果为假则返回0，其他情况则返回NULL。</p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>名称</th>
<th>作用</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td>=</td>
<td>等于运算符</td>
<td>判断两个值、字符串或表达式是否相等</td>
<td>SELECT C FROM TABLE WHERE A = B</td>
</tr>
<tr>
<td>&lt;=&gt;</td>
<td>安全等于运算符</td>
<td>安全地判断两个值、字符串或表达式是否相等</td>
<td>SELECT C FROM TABLE WHERE A &lt;=&gt; B</td>
</tr>
<tr>
<td>&lt;&gt; 或 !=</td>
<td>不等于运算符</td>
<td>判断两个值、字符串或表达式是否不相等</td>
<td>SELECT C FROM TABLE WHERE A &lt;&gt; B</td>
</tr>
<tr>
<td>&lt;</td>
<td>小于运算符</td>
<td>判断前面的值、字符串或表达式是否小于后面的值、字符串或表达式</td>
<td>SELECT C FROM TABLE WHERE A &lt; B</td>
</tr>
<tr>
<td>&lt;=</td>
<td>小于等于运算符</td>
<td>判断前面的值、字符串或表达式是否小于等于后面的值、字符串或表达式</td>
<td>SELECT C FROM TABLE WHERE A &lt;= B</td>
</tr>
<tr>
<td>&gt;</td>
<td>大于运算符</td>
<td>判断前面的值、字符串或表达式是否大于后面的值、字符串或表达式</td>
<td>SELECT C FROM TABLE WHERE A &gt; B</td>
</tr>
<tr>
<td>&gt;=</td>
<td>大于等于运算符</td>
<td>判断前面的值、字符串或表达式是否大于等于后面的值、字符串或表达式</td>
<td>SELECT C FROM TABLE WHERE A &gt;= B</td>
</tr>
</tbody></table>
<p><strong>等号运算符</strong></p>
<ul>
<li>等号运算符（=）判断等号两边的值、字符串或表达式是否相等，如果相等则返回1，不相等则返回0。</li>
<li>在使用等号运算符时，遵循如下规则：<ul>
<li>如果等号两边的值、字符串或表达式都为字符串，则MySQL会按照字符串进行比较，其比较的是每个字符串中字符的ANSI编码是否相等。</li>
<li>如果等号两边的值都是整数，则MySQL会按照整数来比较两个值的大小。</li>
<li>如果等号两边的值一个是整数，另一个是字符串，则MySQL会将字符串转化为数字进行比较。</li>
<li>如果等号两边的值、字符串或表达式中有一个为NULL，则比较结果为NULL。</li>
</ul>
</li>
</ul>
<p><strong>安全等于运算符（为NULL而生）</strong></p>
<p>安全等于运算符（&lt;=&gt;）与等于运算符（=）的作用是相似的， <strong>唯一的区别</strong>是‘&lt;=&gt;’可以用来对NULL进行判断。在两个操作数均为NULL时，其返回值为1，而不为NULL；当一个操作数为NULL时，其返回值为0，而不为NULL。</p>
<p><strong>不等于运算符</strong></p>
<p>不等于运算符（&lt;&gt;和!=）用于判断两边的数字、字符串或者表达式的值是否不相等，如果不相等则返回1，相等则返回0。不等于运算符不能判断NULL值。如果两边的值有任意一个为NULL，或两边都为NULL，则结果为NULL。</p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>名称</th>
<th>作用</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td>IS NULL</td>
<td>为空运算符</td>
<td>判断值、字符串或表达式是否为空</td>
<td>SELECT B FROM TABLE WHERE A IS NULL</td>
</tr>
<tr>
<td>IS NOTNULL</td>
<td>不为空运算符</td>
<td>判断值、字符串或表达式是否不为空</td>
<td>SELECT B FROM TABLE WHERE A IS NOT NULL</td>
</tr>
<tr>
<td>LEAST</td>
<td>最小值运算符</td>
<td>在多个值中返回最小值</td>
<td>SELECT D FROM TABLE WHERE C LEAST(A, B)</td>
</tr>
<tr>
<td>GREATEST</td>
<td>最大值运算符</td>
<td>在多个值中返回最大值</td>
<td>SELECT D FROM TABLE WHERE C GREATEST(A, B)</td>
</tr>
<tr>
<td>BETWEEN … AND …</td>
<td>两值之间的运算符</td>
<td>判断一个值是否在两个值之间</td>
<td>SELECT D FROM TABLE WHERE C BETWEEN A AND B</td>
</tr>
<tr>
<td>ISNULL</td>
<td>为空运算符</td>
<td>判断一个值、字符串或表达式是否为空</td>
<td>SELECT B FROM TABLE WHERE A ISNULL</td>
</tr>
<tr>
<td>IN</td>
<td>属于运算符</td>
<td>判断一个值是否为列表中的任意一个值</td>
<td>SELECT D FROM TABLE WHERE C IN(A, B)</td>
</tr>
<tr>
<td>NOT IN</td>
<td>不属于运算符</td>
<td>判断一个值是否不是一个列表中的任意一个值</td>
<td>SELECT D FROM TABLE WHERE C NOT IN(A, B)</td>
</tr>
<tr>
<td>LIKE</td>
<td>模糊匹配运算符</td>
<td>判断一个值是否符合模糊匹配规则</td>
<td>SELECT C FROM TABLE WHERE A LIKE B</td>
</tr>
<tr>
<td>REGEXP</td>
<td>正则表达式运算符</td>
<td>判断一个值是否符合正则表达式的规则</td>
<td>SELECT C FROM TABLE WHERE A REGEXPB</td>
</tr>
<tr>
<td>RLIKE</td>
<td>正则表达式运算符</td>
<td>判断一个值是否符合正则表达式的规则</td>
<td>SELECT C FROM TABLE WHERE A RLIKEB</td>
</tr>
</tbody></table>
<p><strong>空运算符</strong></p>
<p>空运算符（IS NULL或者ISNULL）判断一个值是否为NULL，如果为NULL则返回1，否则返回0。</p>
<p><strong>非空运算符</strong></p>
<p>非空运算符（IS NOT NULL）判断一个值是否不为NULL，如果不为NULL则返回1，否则返回0。</p>
<p><strong>最小值运算符</strong></p>
<p>语法格式为：LEAST(值1，值2，…，值n)。其中，“值n”表示参数列表中有n个值。在有两个或多个参数的情况下，返回最小值。</p>
<p>当参数是整数或者浮点数时，LEAST将返回其中最小的值；当参数为字符串时，返回字母表中顺序最靠前的字符；当比较值列表中有NULL时，不能判断大小，返回值为NULL。</p>
<p><strong>最大值运算符</strong></p>
<p>语法格式为：GREATEST(值1，值2，…，值n)。其中，n表示参数列表中有n个值。当有两个或多个参数时，返回值为最大值。假如任意一个自变量为NULL，则GREATEST()的返回值为NULL。</p>
<p>当参数中是整数或者浮点数时，GREATEST将返回其中最大的值；当参数为字符串时，返回字母表中顺序最靠后的字符；当比较值列表中有NULL时，不能判断大小，返回值为NULL。</p>
<p><strong>BETWEEN AND运算符</strong> </p>
<p>BETWEEN运算符使用的格式通常为SELECT D FROM TABLE WHERE C BETWEEN A AND B，此时，当C大于或等于A，并且C小于或等于B时，结果为1，否则结果为0。</p>
<p><strong>IN运算符</strong> </p>
<p>IN运算符用于判断给定的值是否是IN列表中的一个值，如果是则返回1，否则返回0。如果给定的值为NULL，或者IN列表中存在NULL，则结果为NULL。</p>
<p><strong>NOT IN运算符</strong></p>
<p>NOT IN运算符用于判断给定的值是否不是IN列表中的一个值，如果不是IN列表中的一个值，则返回1，否则返回0。列表中存在NULL，则结果为NULL。</p>
<p><strong>LIKE运算符</strong> </p>
<p>LIKE运算符主要用来匹配字符串，通常用于模糊匹配，如果满足条件则返回1，否则返回0。如果给定的值或者匹配条件为NULL，则返回结果为NULL。 </p>
<p>LIKE运算符通常使用如下通配符：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">“<span class="operator">%</span>”：匹配<span class="number">0</span>个或多个字符。</span><br><span class="line">“_”：只能匹配一个字符。</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#练习：查询last_name中包含字符<span class="string">&#x27;a&#x27;</span>的员工信息</span><br><span class="line"><span class="keyword">SELECT</span> last_name</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> last_name <span class="keyword">LIKE</span> <span class="string">&#x27;%a%&#x27;</span>;</span><br><span class="line">#练习：查询last_name中以字符<span class="string">&#x27;a&#x27;</span>开头的员工信息</span><br><span class="line"><span class="keyword">SELECT</span> last_name</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> last_name <span class="keyword">LIKE</span> <span class="string">&#x27;a%&#x27;</span>;</span><br><span class="line">#练习：查询第<span class="number">3</span>个字符是<span class="string">&#x27;a&#x27;</span>的员工信息</span><br><span class="line"><span class="keyword">SELECT</span> last_name</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> last_name <span class="keyword">LIKE</span> <span class="string">&#x27;__a%&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p><strong>ESCAPE</strong></p>
<ul>
<li>回避特殊符号的：<strong>使用转义符</strong>。</li>
<li>如果使用\表示转义，要省略ESCAPE。如果不是\，则要加上ESCAPE。</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#练习：查询第<span class="number">2</span>个字符是_且第<span class="number">3</span>个字符是<span class="string">&#x27;a&#x27;</span>的员工信息</span><br><span class="line">#需要使用转义字符: \ </span><br><span class="line"><span class="keyword">SELECT</span> last_name</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> last_name <span class="keyword">LIKE</span> <span class="string">&#x27;_\_a%&#x27;</span>;</span><br><span class="line">#或者  (了解)</span><br><span class="line"><span class="keyword">SELECT</span> last_name</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> last_name <span class="keyword">LIKE</span> <span class="string">&#x27;_$_a%&#x27;</span> <span class="keyword">ESCAPE</span> <span class="string">&#x27;$&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p><strong>REGEXP运算符</strong></p>
<p>REGEXP运算符用来匹配字符串，语法格式为：<code>expr REGEXP 匹配条件</code>。如果expr满足匹配条件，返回1；如果不满足，则返回0。若expr或匹配条件任意一个为NULL，则结果NULL。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">（1）‘^’匹配以该字符后面的字符开头的字符串。</span><br><span class="line">（2）‘$’匹配以该字符前面的字符结尾的字符串。</span><br><span class="line">（3）‘.’匹配任何一个单字符。</span><br><span class="line">（4）“[...]”匹配在方括号内的任何字符。例如，“[abc]”匹配“a”或“b”或“c”。为了命名字符的范围，使用一 个‘-’。“[a-z]”匹配任何字母，而“[0-9]”匹配任何数字。</span><br><span class="line">（5）‘*’匹配零个或多个在它前面的字符。例如，“x*”匹配任何数量的‘x’字符，“[0-9]*”匹配任何数量的数字， 而“*”匹配任何数量的任何字符。</span><br></pre></td></tr></table></figure>

<h4 id="3-逻辑运算符"><a href="#3-逻辑运算符" class="headerlink" title="3. 逻辑运算符"></a><strong>3.</strong> <strong>逻辑运算符</strong></h4><table>
<thead>
<tr>
<th>运算符</th>
<th>作用</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td>NOT 或 !</td>
<td>逻辑非</td>
<td>SELECT NOT A</td>
</tr>
<tr>
<td>AND 或 &amp;&amp;</td>
<td>逻辑与</td>
<td>SELECT A AND B</td>
</tr>
<tr>
<td>OR 或 ||</td>
<td>逻辑或</td>
<td>SELECT A OR B</td>
</tr>
<tr>
<td>XOR</td>
<td>逻辑异或</td>
<td>SELECT A XOR B</td>
</tr>
</tbody></table>
<p><strong>逻辑非运算符</strong></p>
<p>逻辑非（NOT或!）运算符表示当给定的值为0时返回1；当给定的值为非0值时返回0；当给定的值为NULL时，返回NULL。</p>
<p><strong>逻辑与运算符</strong></p>
<p>逻辑与（AND或&amp;&amp;）运算符是当给定的所有值均为非0值，并且都不为NULL时，返回1；当给定的一个值或者多个值为0时则返回0；否则返回NULL。 </p>
<p><strong>逻辑或运算符</strong></p>
<p>逻辑或（OR或||）运算符是当给定的值都不为NULL，并且任何一个值为非0值时，则返回1，否则返回0；当一个值为NULL，并且另一个值为非0值时，返回1，否则返回NULL；当两个值都为NULL时，返回NULL。</p>
<blockquote>
<p>注意：OR可以和AND一起使用，但是在使用时要注意两者的优先级，由于AND的优先级高于OR，因此先对AND两边的操作数进行操作，再与OR中的操作数结合。</p>
</blockquote>
<p><strong>逻辑异或运算符</strong></p>
<p>逻辑异或（XOR）运算符是当给定的值中任意一个值为NULL时，则返回NULL；如果两个非NULL的值都是0或者都不等于0时，则返回0；如果一个值为0，另一个值不为0时，则返回1。</p>
<h4 id="4-位运算符"><a href="#4-位运算符" class="headerlink" title="4. 位运算符"></a><strong>4.</strong> <strong>位运算符</strong></h4><table>
<thead>
<tr>
<th>运算符</th>
<th>作用</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td>&amp;</td>
<td>按位与（位AND）</td>
<td>SELECT A &amp; B</td>
</tr>
<tr>
<td>|</td>
<td>按位或（位OR）</td>
<td>SELECT A | B</td>
</tr>
<tr>
<td>^</td>
<td>按位异或（为XOR）</td>
<td>SELECT A ^ B</td>
</tr>
<tr>
<td>~</td>
<td>按位取反</td>
<td>SELECT  ~A</td>
</tr>
<tr>
<td>&gt;&gt;</td>
<td>按位右移</td>
<td>SELECT  A &gt;&gt; 2</td>
</tr>
<tr>
<td>&lt;&lt;</td>
<td>按位左移</td>
<td>SELECT  B &lt;&lt; 2</td>
</tr>
</tbody></table>
<p><strong>按位与运算符</strong></p>
<p>按位与（&amp;）运算符将给定值对应的二进制数逐位进行逻辑与运算。当给定值对应的二进制位的数值都为1时，则该位返回1，否则返回0。</p>
<p><strong>按位或运算符</strong></p>
<p>按位或（|）运算符将给定的值对应的二进制数逐位进行逻辑或运算。当给定值对应的二进制位的数值有一个或两个为1时，则该位返回1，否则返回0。</p>
<p><strong>按位取反运算符</strong></p>
<p>按位取反（~）运算符将给定的值的二进制数逐位进行取反操作，即将1变为0，将0变为1。</p>
<p><strong>按位右移运算符</strong></p>
<p>按位右移（&gt;&gt;）运算符将给定的值的二进制数的所有位右移指定的位数。右移指定的位数后，右边低位的数值被移出并丢弃，左边高位空出的位置用0补齐。</p>
<p><strong>按位左移运算符</strong></p>
<p>按位左移（&lt;&lt;）运算符将给定的值的二进制数的所有位左移指定的位数。左移指定的位数后，左边高位的数值被移出并丢弃，右边低位空出的位置用0补齐。</p>
<h3 id="第05章-排序与分页"><a href="#第05章-排序与分页" class="headerlink" title="第05章 排序与分页"></a>第05章 排序与分页</h3><h4 id="1-排序数据"><a href="#1-排序数据" class="headerlink" title="1. 排序数据"></a><strong>1.</strong> <strong>排序数据</strong></h4><h5 id="1-1-排序规则"><a href="#1-1-排序规则" class="headerlink" title="1.1 排序规则"></a><strong>1.1</strong> <strong>排序规则</strong></h5><ul>
<li>使用 ORDER BY 子句排序<ul>
<li><strong>ASC（ascend）:升序</strong></li>
<li><strong>DESC（descend）:降序</strong></li>
</ul>
</li>
<li><strong>ORDER BY子句在SELECT语句的结尾。</strong></li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 单列排序</span><br><span class="line"><span class="keyword">SELECT</span> employee_id,last_name,salary</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> salary; # 如果在<span class="keyword">ORDER</span> <span class="keyword">BY</span> 后没有显式指名排序的方式的话，则默认按照升序排列。</span><br><span class="line"># 我们可以使用列的别名，进行排序</span><br><span class="line"><span class="keyword">SELECT</span> employee_id,salary,salary <span class="operator">*</span> <span class="number">12</span> annual_sal</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> annual_sal;</span><br><span class="line"># 多列排序</span><br><span class="line"><span class="keyword">SELECT</span> employee_id,salary,department_id</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> department_id <span class="keyword">DESC</span>,salary <span class="keyword">ASC</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>可以使用不在SELECT列表中的列排序。</li>
<li>在对多列进行排序的时候，首先排序的第一列必须有相同的列值，才会对第二列进行排序。如果第一列数据中所有值都是唯一的，将不再对第二列进行排序。</li>
</ul>
<h4 id="2-分页"><a href="#2-分页" class="headerlink" title="2. 分页"></a><strong>2.</strong> <strong>分页</strong></h4><h5 id="2-1-实现规则"><a href="#2-1-实现规则" class="headerlink" title="2.1 实现规则"></a><strong>2.1</strong> <strong>实现规则</strong></h5><ul>
<li><strong>MySQL中使用LIMIT实现分页</strong></li>
<li>格式：</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">LIMIT [位置偏移量,] 行数</span><br></pre></td></tr></table></figure>

<ul>
<li>“偏移量”参数指示MySQL从哪一行开始显示，是一个可选参数，如果不指定“位置偏移量”，将会从表中的第一条记录开始（第一条记录的位置偏移量是0，第二条记录的位置偏移量是1，以此类推）；第二个参数“行数”指示返回的记录条数。</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 前10条记录： </span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> 表名 LIMIT <span class="number">0</span>,<span class="number">10</span>; </span><br><span class="line">或者</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> 表名 LIMIT <span class="number">10</span>;</span><br><span class="line"><span class="comment">-- 第11至20条记录： </span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> 表名 LIMIT <span class="number">10</span>,<span class="number">10</span>;</span><br><span class="line"><span class="comment">-- 第21至30条记录： </span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> 表名 LIMIT <span class="number">20</span>,<span class="number">10</span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>MySQL 8.0中可以使用“LIMIT 3 OFFSET 4”，意思是获取从第5条记录开始后面的3条记录，和“LIMIT 4,3;”返回的结果相同。</p>
</blockquote>
<ul>
<li>分页显式公式：<strong>（当前页数-1）*每页条数，每页条数</strong></li>
<li><strong>注意：LIMIT子句必须放在整个SELECT语句的最后！</strong></li>
</ul>
<h3 id="第06章-多表查询"><a href="#第06章-多表查询" class="headerlink" title="第06章 多表查询"></a>第06章 多表查询</h3><h4 id="1-一个案例引发的多表连接"><a href="#1-一个案例引发的多表连接" class="headerlink" title="1. 一个案例引发的多表连接"></a><strong>1.</strong> <strong>一个案例引发的多表连接</strong></h4><h5 id="1-1-笛卡尔积（或交叉连接）的理解"><a href="#1-1-笛卡尔积（或交叉连接）的理解" class="headerlink" title="1.1 笛卡尔积（或交叉连接）的理解"></a><strong>1.1</strong> <strong>笛卡尔积（或交叉连接）的理解</strong></h5><p>笛卡尔乘积是一个数学运算。假设我有两个集合 X 和 Y，那么 X 和 Y 的笛卡尔积就是 X 和 Y 的所有可能组合，也就是第一个对象来自于 X，第二个对象来自于 Y 的所有可能。组合的个数即为两个集合中元素个数的乘积数。</p>
<p>SQL92中，笛卡尔积也称为<code>交叉连接</code>，英文是<code>CROSS JOIN</code>。在 SQL99 中也是使用 CROSS JOIN表示交叉连接。它的作用就是可以把任意表进行连接，即使这两张表不相关。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#查询员工姓名和所在部门名称 </span><br><span class="line"><span class="keyword">SELECT</span> last_name,department_name <span class="keyword">FROM</span> employees,departments; </span><br><span class="line"><span class="keyword">SELECT</span> last_name,department_name <span class="keyword">FROM</span> employees <span class="keyword">CROSS</span> <span class="keyword">JOIN</span> departments;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>笛卡尔积的错误会在下面条件下产生</strong>：<ul>
<li>省略多个表的连接条件（或关联条件）</li>
<li>连接条件（或关联条件）无效</li>
<li>所有表中的所有行互相连接</li>
</ul>
</li>
<li>为了避免笛卡尔积， 可以<strong>在WHERE加入有效的连接条件。</strong></li>
</ul>
<h4 id="2-多表查询分类讲解"><a href="#2-多表查询分类讲解" class="headerlink" title="2. 多表查询分类讲解"></a><strong>2.</strong> <strong>多表查询分类讲解</strong></h4><p><strong>分类1：等值连接vs非等值连接</strong></p>
<p><strong>拓展1：区分重复的列名</strong></p>
<ul>
<li><strong>多个表中有相同列时，必须在列名之前加上表名前缀。</strong></li>
</ul>
<p><strong>拓展2：表的别名</strong></p>
<ul>
<li>使用别名可以简化查询。</li>
<li>列名前使用表名前缀可以提高查询效率。</li>
</ul>
<blockquote>
<p>需要注意的是，如果我们使用了表的别名，在查询字段中、过滤条件中就只能使用别名进行代替，不能使用原有的表名，否则就会报错。</p>
</blockquote>
<p><strong>拓展3：连接多个表</strong></p>
<ul>
<li><strong>连接n个表,至少需要n-1个连接条件。</strong></li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#非等值连接的例子</span><br><span class="line"><span class="keyword">SELECT</span> e.last_name,e.salary,j.grade_level</span><br><span class="line"><span class="keyword">FROM</span> employees e,job_grades j</span><br><span class="line">#<span class="keyword">where</span> e.`salary` <span class="keyword">between</span> j.`lowest_sal` <span class="keyword">and</span> j.`highest_sal`;</span><br><span class="line"><span class="keyword">WHERE</span> e.`salary` <span class="operator">&gt;=</span> j.`lowest_sal` <span class="keyword">AND</span> e.`salary` <span class="operator">&lt;=</span> j.`highest_sal`;</span><br></pre></td></tr></table></figure>

<p><strong>分类2：自连接vs非自连接</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#自连接的例子：</span><br><span class="line">#练习：查询员工id,员工姓名及其管理者的id和姓名</span><br><span class="line"><span class="keyword">SELECT</span> emp.employee_id,emp.last_name,mgr.employee_id,mgr.last_name</span><br><span class="line"><span class="keyword">FROM</span> employees emp ,employees mgr</span><br><span class="line"><span class="keyword">WHERE</span> emp.`manager_id` <span class="operator">=</span> mgr.`employee_id`;</span><br></pre></td></tr></table></figure>

<p><strong>分类3：内连接  vs  外连接</strong></p>
<ul>
<li><p>内连接: 合并具有同一列的两个以上的表的行, <strong>结果集中不包含一个表与另一个表不匹配的行</strong></p>
</li>
<li><p>外连接: 两个表在连接过程中除了返回满足连接条件的行以外<strong>还返回左（或右）表中不满足条件的行 ，这种连接称为左（或右） 外连接</strong>。没有匹配的行时, 结果表中相应的列为空(NULL)。</p>
<ul>
<li>如果是左外连接，则连接条件中左边的表也称为<code>主表</code>，右边的表称为<code>从表</code>。</li>
<li>如果是右外连接，则连接条件中右边的表也称为<code>主表</code>，左边的表称为<code>从表</code>。 </li>
</ul>
</li>
</ul>
<h4 id="3-SQL99语法实现多表查询"><a href="#3-SQL99语法实现多表查询" class="headerlink" title="3. SQL99语法实现多表查询"></a>3. SQL99语法实现多表查询</h4><h5 id="3-1-基本语法"><a href="#3-1-基本语法" class="headerlink" title="3.1 基本语法"></a><strong>3.1</strong> <strong>基本语法</strong></h5><ul>
<li>使用JOIN…ON子句创建连接的语法结构：</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> table1.column, table2.column, table3.column</span><br><span class="line"><span class="keyword">FROM</span> table1 <span class="keyword">JOIN</span> table2</span><br><span class="line"><span class="keyword">ON</span> table1 和 table2 的连接条件</span><br><span class="line"><span class="keyword">JOIN</span> table3</span><br><span class="line"><span class="keyword">ON</span> table2 和 table3 的连接条件</span><br></pre></td></tr></table></figure>

<h5 id="3-2-内连接-INNER-JOIN-的实现"><a href="#3-2-内连接-INNER-JOIN-的实现" class="headerlink" title="3.2 内连接(INNER JOIN)的实现"></a><strong>3.2</strong> <strong>内连接(INNER JOIN)的实现</strong></h5><ul>
<li>语法</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 字段列表</span><br><span class="line"><span class="keyword">FROM</span> A表 <span class="keyword">INNER</span> <span class="keyword">JOIN</span> B表</span><br><span class="line"><span class="keyword">ON</span> 关联条件</span><br><span class="line"><span class="keyword">WHERE</span> 等其他子句;</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> last_name,department_name</span><br><span class="line"><span class="keyword">FROM</span> employees e <span class="keyword">INNER</span> <span class="keyword">JOIN</span> departments d</span><br><span class="line"><span class="keyword">ON</span> e.`department_id` <span class="operator">=</span> d.`department_id`;</span><br></pre></td></tr></table></figure>

<h5 id="3-3-外连接-OUTER-JOIN-的实现"><a href="#3-3-外连接-OUTER-JOIN-的实现" class="headerlink" title="3.3 外连接(OUTER JOIN)的实现"></a><strong>3.3</strong> <strong>外连接(OUTER JOIN)的实现</strong></h5><h6 id="3-3-1-左外连接-LEFT-OUTER-JOIN"><a href="#3-3-1-左外连接-LEFT-OUTER-JOIN" class="headerlink" title="3.3.1 左外连接(LEFT OUTER JOIN)"></a><strong>3.3.1</strong> <strong>左外连接(LEFT OUTER JOIN)</strong></h6><ul>
<li>语法：</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 字段列表</span><br><span class="line"><span class="keyword">FROM</span> A表 <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> B表</span><br><span class="line"><span class="keyword">ON</span> 关联条件</span><br><span class="line"><span class="keyword">WHERE</span> 等其他子句;</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> last_name,department_name</span><br><span class="line"><span class="keyword">FROM</span> employees e <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> departments d</span><br><span class="line"><span class="keyword">ON</span> e.`department_id` <span class="operator">=</span> d.`department_id`;</span><br></pre></td></tr></table></figure>

<h6 id="3-3-2-右外连接-RIGHT-OUTER-JOIN"><a href="#3-3-2-右外连接-RIGHT-OUTER-JOIN" class="headerlink" title="3.3.2 右外连接(RIGHT OUTER JOIN)"></a><strong>3.3.2</strong> <strong>右外连接(RIGHT OUTER JOIN)</strong></h6><ul>
<li>语法：</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 字段列表 </span><br><span class="line"><span class="keyword">FROM</span> A表 <span class="keyword">RIGHT</span> <span class="keyword">JOIN</span> B表</span><br><span class="line"><span class="keyword">ON</span> 关联条件</span><br><span class="line"><span class="keyword">WHERE</span> 等其他子句;</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> last_name,department_name</span><br><span class="line"><span class="keyword">FROM</span> employees e <span class="keyword">RIGHT</span> <span class="keyword">OUTER</span> <span class="keyword">JOIN</span> departments d</span><br><span class="line"><span class="keyword">ON</span> e.`department_id` <span class="operator">=</span> d.`department_id`;</span><br></pre></td></tr></table></figure>

<h4 id="4-UNION的使用"><a href="#4-UNION的使用" class="headerlink" title="4. UNION的使用"></a><strong>4. UNION的使用</strong></h4><p><strong>UNION操作符</strong></p>
<p>UNION 操作符返回两个查询的结果集的并集，去除重复记录。</p>
<p><strong>UNION ALL操作符</strong></p>
<p>UNION ALL操作符返回两个查询的结果集的并集。对于两个结果集的重复部分，不去重。</p>
<blockquote>
<p>如果明确知道合并数据后的结果数据不存在重复数据，或者不需要去除重复的数据，则尽量使用UNION ALL语句，以提高数据查询的效率。</p>
</blockquote>
<h4 id="5-7种SQL-JOINS的实现"><a href="#5-7种SQL-JOINS的实现" class="headerlink" title="5. 7种SQL JOINS的实现"></a><strong>5. 7种SQL JOINS的实现</strong></h4><h5 id="5-1-举例"><a href="#5-1-举例" class="headerlink" title="5.1 举例"></a><strong>5.1 举例</strong></h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 中图：内连接</span><br><span class="line"><span class="keyword">SELECT</span> employee_id,department_name</span><br><span class="line"><span class="keyword">FROM</span> employees e <span class="keyword">JOIN</span> departments d</span><br><span class="line"><span class="keyword">ON</span> e.`department_id` <span class="operator">=</span> d.`department_id`;</span><br><span class="line"># 左上图：左外连接</span><br><span class="line"><span class="keyword">SELECT</span> employee_id,department_name</span><br><span class="line"><span class="keyword">FROM</span> employees e <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> departments d</span><br><span class="line"><span class="keyword">ON</span> e.`department_id` <span class="operator">=</span> d.`department_id`;</span><br><span class="line"># 右上图：右外连接</span><br><span class="line"><span class="keyword">SELECT</span> employee_id,department_name</span><br><span class="line"><span class="keyword">FROM</span> employees e <span class="keyword">RIGHT</span> <span class="keyword">JOIN</span> departments d</span><br><span class="line"><span class="keyword">ON</span> e.`department_id` <span class="operator">=</span> d.`department_id`;</span><br><span class="line"># 左中图：</span><br><span class="line"><span class="keyword">SELECT</span> employee_id,department_name</span><br><span class="line"><span class="keyword">FROM</span> employees e <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> departments d</span><br><span class="line"><span class="keyword">ON</span> e.`department_id` <span class="operator">=</span> d.`department_id`</span><br><span class="line"><span class="keyword">WHERE</span> d.`department_id` <span class="keyword">IS</span> <span class="keyword">NULL</span>;</span><br><span class="line"># 右中图：</span><br><span class="line"><span class="keyword">SELECT</span> employee_id,department_name</span><br><span class="line"><span class="keyword">FROM</span> employees e <span class="keyword">RIGHT</span> <span class="keyword">JOIN</span> departments d</span><br><span class="line"><span class="keyword">ON</span> e.`department_id` <span class="operator">=</span> d.`department_id`</span><br><span class="line"><span class="keyword">WHERE</span> e.`department_id` <span class="keyword">IS</span> <span class="keyword">NULL</span>;</span><br><span class="line"># 左下图：满外连接</span><br><span class="line"># 方式<span class="number">1</span>：左上图 <span class="keyword">UNION</span> <span class="keyword">ALL</span> 右中图</span><br><span class="line"><span class="keyword">SELECT</span> employee_id,department_name</span><br><span class="line"><span class="keyword">FROM</span> employees e <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> departments d</span><br><span class="line"><span class="keyword">ON</span> e.`department_id` <span class="operator">=</span> d.`department_id`</span><br><span class="line"><span class="keyword">UNION</span> <span class="keyword">ALL</span></span><br><span class="line"><span class="keyword">SELECT</span> employee_id,department_name</span><br><span class="line"><span class="keyword">FROM</span> employees e <span class="keyword">RIGHT</span> <span class="keyword">JOIN</span> departments d</span><br><span class="line"><span class="keyword">ON</span> e.`department_id` <span class="operator">=</span> d.`department_id`</span><br><span class="line"><span class="keyword">WHERE</span> e.`department_id` <span class="keyword">IS</span> <span class="keyword">NULL</span>;</span><br><span class="line"># 方式<span class="number">2</span>：左中图 <span class="keyword">UNION</span> <span class="keyword">ALL</span> 右上图</span><br><span class="line"><span class="keyword">SELECT</span> employee_id,department_name</span><br><span class="line"><span class="keyword">FROM</span> employees e <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> departments d</span><br><span class="line"><span class="keyword">ON</span> e.`department_id` <span class="operator">=</span> d.`department_id`</span><br><span class="line"><span class="keyword">WHERE</span> d.`department_id` <span class="keyword">IS</span> <span class="keyword">NULL</span></span><br><span class="line"><span class="keyword">UNION</span> <span class="keyword">ALL</span></span><br><span class="line"><span class="keyword">SELECT</span> employee_id,department_name</span><br><span class="line"><span class="keyword">FROM</span> employees e <span class="keyword">RIGHT</span> <span class="keyword">JOIN</span> departments d</span><br><span class="line"><span class="keyword">ON</span> e.`department_id` <span class="operator">=</span> d.`department_id`;</span><br><span class="line"># 右下图：左中图  <span class="keyword">UNION</span> <span class="keyword">ALL</span> 右中图</span><br><span class="line"><span class="keyword">SELECT</span> employee_id,department_name</span><br><span class="line"><span class="keyword">FROM</span> employees e <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> departments d</span><br><span class="line"><span class="keyword">ON</span> e.`department_id` <span class="operator">=</span> d.`department_id`</span><br><span class="line"><span class="keyword">WHERE</span> d.`department_id` <span class="keyword">IS</span> <span class="keyword">NULL</span></span><br><span class="line"><span class="keyword">UNION</span> <span class="keyword">ALL</span></span><br><span class="line"><span class="keyword">SELECT</span> employee_id,department_name</span><br><span class="line"><span class="keyword">FROM</span> employees e <span class="keyword">RIGHT</span> <span class="keyword">JOIN</span> departments d</span><br><span class="line"><span class="keyword">ON</span> e.`department_id` <span class="operator">=</span> d.`department_id`</span><br><span class="line"><span class="keyword">WHERE</span> e.`department_id` <span class="keyword">IS</span> <span class="keyword">NULL</span>;</span><br></pre></td></tr></table></figure>

<h5 id="5-2-语法格式小结"><a href="#5-2-语法格式小结" class="headerlink" title="5.2 语法格式小结"></a><strong>5.2 语法格式小结</strong></h5><ul>
<li>左中图</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#实现A <span class="operator">-</span> A∩B</span><br><span class="line"><span class="keyword">select</span> 字段列表</span><br><span class="line"><span class="keyword">from</span> A表 <span class="keyword">left</span> <span class="keyword">join</span> B表</span><br><span class="line"><span class="keyword">on</span> 关联条件</span><br><span class="line"><span class="keyword">where</span> 从表关联字段 <span class="keyword">is</span> <span class="keyword">null</span> <span class="keyword">and</span> 等其他子句;</span><br></pre></td></tr></table></figure>

<ul>
<li>右中图</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#实现B <span class="operator">-</span> A∩B</span><br><span class="line"><span class="keyword">select</span> 字段列表</span><br><span class="line"><span class="keyword">from</span> A表 <span class="keyword">right</span> <span class="keyword">join</span> B表</span><br><span class="line"><span class="keyword">on</span> 关联条件</span><br><span class="line"><span class="keyword">where</span> 从表关联字段 <span class="keyword">is</span> <span class="keyword">null</span> <span class="keyword">and</span> 等其他子句;</span><br></pre></td></tr></table></figure>

<ul>
<li>左下图</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#实现查询结果是A∪B</span><br><span class="line">#用左外的A，<span class="keyword">union</span> 右外的B</span><br><span class="line"><span class="keyword">select</span> 字段列表</span><br><span class="line"><span class="keyword">from</span> A表 <span class="keyword">left</span> <span class="keyword">join</span> B表</span><br><span class="line"><span class="keyword">on</span> 关联条件</span><br><span class="line"><span class="keyword">where</span> 等其他子句</span><br><span class="line"><span class="keyword">union</span></span><br><span class="line"><span class="keyword">select</span> 字段列表</span><br><span class="line"><span class="keyword">from</span> A表 <span class="keyword">right</span> <span class="keyword">join</span> B表</span><br><span class="line"><span class="keyword">on</span> 关联条件</span><br><span class="line"><span class="keyword">where</span> 等其他子句;</span><br></pre></td></tr></table></figure>

<ul>
<li>右下图</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#实现A∪B <span class="operator">-</span> A∩B 或 (A <span class="operator">-</span> A∩B) ∪ （B <span class="operator">-</span> A∩B）</span><br><span class="line">#使用左外的 (A <span class="operator">-</span> A∩B) <span class="keyword">union</span> 右外的（B <span class="operator">-</span> A∩B）</span><br><span class="line"><span class="keyword">select</span> 字段列表</span><br><span class="line"><span class="keyword">from</span> A表 <span class="keyword">left</span> <span class="keyword">join</span> B表</span><br><span class="line"><span class="keyword">on</span> 关联条件</span><br><span class="line"><span class="keyword">where</span> 从表关联字段 <span class="keyword">is</span> <span class="keyword">null</span> <span class="keyword">and</span> 等其他子句</span><br><span class="line"><span class="keyword">union</span></span><br><span class="line"><span class="keyword">select</span> 字段列表</span><br><span class="line"><span class="keyword">from</span> A表 <span class="keyword">right</span> <span class="keyword">join</span> B表</span><br><span class="line"><span class="keyword">on</span> 关联条件</span><br><span class="line"><span class="keyword">where</span> 从表关联字段 <span class="keyword">is</span> <span class="keyword">null</span> <span class="keyword">and</span> 等其他子句</span><br></pre></td></tr></table></figure>

<h4 id="6-SQL99语法新特性"><a href="#6-SQL99语法新特性" class="headerlink" title="6. SQL99语法新特性"></a><strong>6. SQL99语法新特性</strong></h4><h5 id="6-1-自然连接"><a href="#6-1-自然连接" class="headerlink" title="6.1 自然连接"></a><strong>6.1</strong> <strong>自然连接</strong></h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> employee_id,last_name,department_name</span><br><span class="line"><span class="keyword">FROM</span> employees e <span class="keyword">JOIN</span> departments d</span><br><span class="line"><span class="keyword">ON</span> e.`department_id` <span class="operator">=</span> d.`department_id`</span><br><span class="line"><span class="keyword">AND</span> e.`manager_id` <span class="operator">=</span> d.`manager_id`;</span><br><span class="line"># <span class="keyword">NATURAL</span> <span class="keyword">JOIN</span> : 它会帮你自动查询两张连接表中`所有相同的字段`，然后进行`等值连接`。</span><br><span class="line"><span class="keyword">SELECT</span> employee_id,last_name,department_name</span><br><span class="line"><span class="keyword">FROM</span> employees e <span class="keyword">NATURAL</span> <span class="keyword">JOIN</span> departments d;</span><br></pre></td></tr></table></figure>

<h5 id="6-2-USING连接"><a href="#6-2-USING连接" class="headerlink" title="6.2 USING连接"></a><strong>6.2 USING连接</strong></h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> employee_id,last_name,department_name</span><br><span class="line"><span class="keyword">FROM</span> employees e <span class="keyword">JOIN</span> departments d</span><br><span class="line"><span class="keyword">ON</span> e.department_id <span class="operator">=</span> d.department_id;</span><br><span class="line"># 指定数据表里的同名字段进行等值连接，只能配合<span class="keyword">JOIN</span>一起使用。</span><br><span class="line"><span class="keyword">SELECT</span> employee_id,last_name,department_name</span><br><span class="line"><span class="keyword">FROM</span> employees e <span class="keyword">JOIN</span> departments d</span><br><span class="line"><span class="keyword">USING</span> (department_id);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>【强制】超过三个表禁止 join。需要 join 的字段，数据类型保持绝对一致；多表关联查询时，保证被关联的字段需要有索引。</p>
<p>说明：即使双表 join 也要注意表索引、SQL 性能。</p>
</blockquote>
<h3 id="第07章-单行函数"><a href="#第07章-单行函数" class="headerlink" title="第07章 单行函数"></a>第07章 单行函数</h3><h4 id="1-数值函数"><a href="#1-数值函数" class="headerlink" title="1. 数值函数"></a><strong>1.</strong> <strong>数值函数</strong></h4><h5 id="1-1-基本函数"><a href="#1-1-基本函数" class="headerlink" title="1.1 基本函数"></a><strong>1.1</strong> <strong>基本函数</strong></h5><table>
<thead>
<tr>
<th>函数</th>
<th>用法</th>
</tr>
</thead>
<tbody><tr>
<td>ABS(x)</td>
<td>返回x的绝对值</td>
</tr>
<tr>
<td>SIGN(X)</td>
<td>返回X的符号。正数返回1，负数返回-1，0返回0</td>
</tr>
<tr>
<td>PI()</td>
<td>返回圆周率的值</td>
</tr>
<tr>
<td>CEIL(x)，CEILING(x)</td>
<td>返回大于或等于某个值的最小整数</td>
</tr>
<tr>
<td>FLOOR(x)</td>
<td>返回小于或等于某个值的最大整数</td>
</tr>
<tr>
<td>LEAST(e1,e2,e3…)</td>
<td>返回列表中的最小值</td>
</tr>
<tr>
<td>GREATEST(e1,e2,e3…)</td>
<td>返回列表中的最大值</td>
</tr>
<tr>
<td>MOD(x,y)</td>
<td>返回X除以Y后的余数</td>
</tr>
<tr>
<td>RAND()</td>
<td>返回0~1的随机值</td>
</tr>
<tr>
<td>RAND(x)</td>
<td>返回0~1的随机值，其中x的值用作种子值，相同的X值会产生相同的随机</td>
</tr>
<tr>
<td>ROUND(x)</td>
<td>返回一个对x的值进行四舍五入后，最接近于X的整数</td>
</tr>
<tr>
<td>ROUND(x,y)</td>
<td>返回一个对x的值进行四舍五入后最接近X的值，并保留到小数点后面Y位</td>
</tr>
<tr>
<td>TRUNCATE(x,y)</td>
<td>返回数字x截断为y位小数的结果</td>
</tr>
<tr>
<td>SQRT(x)</td>
<td>返回x的平方根。当X的值为负数时，返回NULL</td>
</tr>
</tbody></table>
<h5 id="1-2-角度与弧度"><a href="#1-2-角度与弧度" class="headerlink" title="1.2 角度与弧度"></a><strong>1.2</strong> <strong>角度与弧度</strong></h5><table>
<thead>
<tr>
<th>函数</th>
<th>用法</th>
</tr>
</thead>
<tbody><tr>
<td>RADIANS(x)</td>
<td>将角度转化为弧度，其中，参数x为角度值</td>
</tr>
<tr>
<td>DEGREES(x)</td>
<td>将弧度转化为角度，其中，参数x为弧度值</td>
</tr>
</tbody></table>
<h5 id="1-3-三角函数"><a href="#1-3-三角函数" class="headerlink" title="1.3 三角函数"></a><strong>1.3</strong> <strong>三角函数</strong></h5><table>
<thead>
<tr>
<th>函数</th>
<th>用法</th>
</tr>
</thead>
<tbody><tr>
<td>SIN(x)</td>
<td>返回x的正弦值，其中，参数x为弧度值</td>
</tr>
<tr>
<td>ASIN(x)</td>
<td>返回x的反正弦值，即获取正弦为x的值。如果x的值不在-1到1之间，则返回NULL</td>
</tr>
<tr>
<td>COS(x)</td>
<td>返回x的余弦值，其中，参数x为弧度值</td>
</tr>
<tr>
<td>ACOS(x)</td>
<td>返回x的反余弦值，即获取余弦为x的值。如果x的值不在-1到1之间，则返回NULL</td>
</tr>
<tr>
<td>TAN(x)</td>
<td>返回x的正切值，其中，参数x为弧度值</td>
</tr>
<tr>
<td>ATAN(x)</td>
<td>返回x的反正切值，即返回正切值为x的值</td>
</tr>
<tr>
<td>ATAN2(m,n)</td>
<td>返回两个参数的反正切值</td>
</tr>
<tr>
<td>COT(x)</td>
<td>返回x的余切值，其中，X为弧度值</td>
</tr>
</tbody></table>
<h5 id="1-4-指数与对数"><a href="#1-4-指数与对数" class="headerlink" title="1.4 指数与对数"></a><strong>1.4</strong> <strong>指数与对数</strong></h5><table>
<thead>
<tr>
<th>函数</th>
<th>用法</th>
</tr>
</thead>
<tbody><tr>
<td>POW(x,y)，POWER(X,Y)</td>
<td>返回x的y次方</td>
</tr>
<tr>
<td>EXP(X)</td>
<td>返回e的X次方，其中e是一个常数，2.718281828459045</td>
</tr>
<tr>
<td>LN(X)，LOG(X)</td>
<td>返回以e为底的X的对数，当X &lt;= 0 时，返回的结果为NULL</td>
</tr>
<tr>
<td>LOG10(X)</td>
<td>返回以10为底的X的对数，当X &lt;= 0 时，返回的结果为NULL</td>
</tr>
<tr>
<td>LOG2(X)</td>
<td>返回以2为底的X的对数，当X &lt;= 0 时，返回NULL</td>
</tr>
</tbody></table>
<h5 id="1-5-进制间的转换"><a href="#1-5-进制间的转换" class="headerlink" title="1.5 进制间的转换"></a><strong>1.5</strong> <strong>进制间的转换</strong></h5><table>
<thead>
<tr>
<th>函数</th>
<th>用法</th>
</tr>
</thead>
<tbody><tr>
<td>BIN(x)</td>
<td>返回x的二进制编码</td>
</tr>
<tr>
<td>HEX(x)</td>
<td>返回x的十六进制编码</td>
</tr>
<tr>
<td>OCT(x)</td>
<td>返回x的八进制编码</td>
</tr>
<tr>
<td>CONV(x,f1,f2)</td>
<td>返回f1进制数变成f2进制数</td>
</tr>
</tbody></table>
<h4 id="2-字符串函数"><a href="#2-字符串函数" class="headerlink" title="2. 字符串函数"></a><strong>2.</strong> <strong>字符串函数</strong></h4><table>
<thead>
<tr>
<th>函数</th>
<th>用法</th>
</tr>
</thead>
<tbody><tr>
<td>ASCII(S)</td>
<td>返回字符串S中的第一个字符的ASCII码值</td>
</tr>
<tr>
<td>CHAR_LENGTH(s)</td>
<td>返回字符串s的字符数。作用与CHARACTER_LENGTH(s)相同</td>
</tr>
<tr>
<td>LENGTH(s)</td>
<td>返回字符串s的字节数，和字符集有关</td>
</tr>
<tr>
<td>CONCAT(s1,s2,……,sn)</td>
<td>连接s1,s2,……,sn为一个字符串</td>
</tr>
<tr>
<td>CONCAT_WS(x,s1,s2,……,sn)</td>
<td>同CONCAT(s1,s2,…)函数，但是每个字符串之间要加上x</td>
</tr>
<tr>
<td>INSERT(str, idx, len,replacestr)</td>
<td>将字符串str从第idx位置开始，len个字符长的子串替换为字符串replacestr</td>
</tr>
<tr>
<td>REPLACE(str, a, b)</td>
<td>用字符串b替换字符串str中所有出现的字符串a</td>
</tr>
<tr>
<td>UPPER(s) 或 UCASE(s)</td>
<td>将字符串s的所有字母转成大写字母</td>
</tr>
<tr>
<td>LOWER(s) 或LCASE(s)</td>
<td>将字符串s的所有字母转成小写字母</td>
</tr>
<tr>
<td>LEFT(str,n)</td>
<td>返回字符串str最左边的n个字符</td>
</tr>
<tr>
<td>RIGHT(str,n)</td>
<td>返回字符串str最右边的n个字符</td>
</tr>
<tr>
<td>LPAD(str, len, pad)</td>
<td>用字符串pad对str最左边进行填充，直到str的长度为len个字符，实现右对齐效果</td>
</tr>
<tr>
<td>RPAD(str ,len, pad)</td>
<td>用字符串pad对str最右边进行填充，直到str的长度为len个字符，实现左对齐效果</td>
</tr>
<tr>
<td>LTRIM(s)</td>
<td>去掉字符串s左侧的空格</td>
</tr>
<tr>
<td>RTRIM(s)</td>
<td>去掉字符串s右侧的空格</td>
</tr>
<tr>
<td>TRIM(s)</td>
<td>去掉字符串s开始与结尾的空格</td>
</tr>
<tr>
<td>TRIM(s1 FROM s)</td>
<td>去掉字符串s开始与结尾的s1</td>
</tr>
<tr>
<td>TRIM(LEADING s1 FROM s)</td>
<td>去掉字符串s开始处的s1</td>
</tr>
<tr>
<td>TRIM(TRAILING s1 FROM s)</td>
<td>去掉字符串s结尾处的s1</td>
</tr>
<tr>
<td>REPEAT(str, n)</td>
<td>返回str重复n次的结果</td>
</tr>
<tr>
<td>SPACE(n)</td>
<td>返回n个空格</td>
</tr>
<tr>
<td>STRCMP(s1,s2)</td>
<td>比较字符串s1,s2的ASCII码值的大小</td>
</tr>
<tr>
<td>SUBSTR(s,index,len)</td>
<td>返回从字符串s的index位置其len个字符，作用与SUBSTRING(s,n,len)、MID(s,n,len)相同</td>
</tr>
<tr>
<td>LOCATE(substr,str)</td>
<td>返回字符串substr在字符串str中首次出现的位置，作用于POSITION(substr IN str)、INSTR(str,substr)相同。未找到，返回0</td>
</tr>
<tr>
<td>ELT(m,s1,s2,…,sn)</td>
<td>返回指定位置的字符串，如果m=1，则返回s1，如果m=2，则返回s2，如果m=n，则返回sn</td>
</tr>
<tr>
<td>FIELD(s,s1,s2,…,sn)</td>
<td>返回字符串s在字符串列表中第一次出现的位置</td>
</tr>
<tr>
<td>FIND_IN_SET(s1,s2)</td>
<td>返回字符串s1在字符串s2中出现的位置。其中，字符串s2是一个以逗号分隔的字符串</td>
</tr>
<tr>
<td>REVERSE(s)</td>
<td>返回s反转后的字符串</td>
</tr>
<tr>
<td>NULLIF(value1,value2)</td>
<td>比较两个字符串，如果value1与value2相等，则返回NULL，否则返回value1</td>
</tr>
</tbody></table>
<blockquote>
<p>注意：MySQL中，字符串的位置是从1开始的。</p>
</blockquote>
<h4 id="3-日期和时间函数"><a href="#3-日期和时间函数" class="headerlink" title="3. 日期和时间函数"></a><strong>3.</strong> <strong>日期和时间函数</strong></h4><h5 id="3-1-获取日期、时间"><a href="#3-1-获取日期、时间" class="headerlink" title="3.1 获取日期、时间"></a><strong>3.1</strong> <strong>获取日期、时间</strong></h5><table>
<thead>
<tr>
<th>函数</th>
<th>用法</th>
</tr>
</thead>
<tbody><tr>
<td><strong>CURDATE()</strong> ，CURRENT_DATE()</td>
<td>返回当前日期，只包含年、月、日</td>
</tr>
<tr>
<td><strong>CURTIME()</strong> ， CURRENT_TIME()</td>
<td>返回当前时间，只包含时、分、秒</td>
</tr>
<tr>
<td><strong>NOW()</strong> / SYSDATE() / CURRENT_TIMESTAMP() / LOCALTIME() / LOCALTIMESTAMP()</td>
<td>返回当前系统日期和时间</td>
</tr>
<tr>
<td>UTC_DATE()</td>
<td>返回UTC（世界标准时间）日期</td>
</tr>
<tr>
<td>UTC_TIME()</td>
<td>返回UTC（世界标准时间）时间</td>
</tr>
</tbody></table>
<h5 id="3-2-日期与时间戳的转换"><a href="#3-2-日期与时间戳的转换" class="headerlink" title="3.2 日期与时间戳的转换"></a><strong>3.2</strong> <strong>日期与时间戳的转换</strong></h5><table>
<thead>
<tr>
<th>函数</th>
<th>用法</th>
</tr>
</thead>
<tbody><tr>
<td>UNIX_TIMESTAMP()</td>
<td>以UNIX时间戳的形式返回当前时间。SELECT UNIX_TIMESTAMP() -&gt;1634348884</td>
</tr>
<tr>
<td>UNIX_TIMESTAMP(date)</td>
<td>将时间date以UNIX时间戳的形式返回。</td>
</tr>
<tr>
<td>FROM_UNIXTIME(timestamp)</td>
<td>将UNIX时间戳的时间转换为普通格式的时间</td>
</tr>
</tbody></table>
<h5 id="3-3-获取月份、星期、星期数、天数等函数"><a href="#3-3-获取月份、星期、星期数、天数等函数" class="headerlink" title="3.3 获取月份、星期、星期数、天数等函数"></a><strong>3.3</strong> <strong>获取月份、星期、星期数、天数等函数</strong></h5><table>
<thead>
<tr>
<th>函数</th>
<th>用法</th>
</tr>
</thead>
<tbody><tr>
<td>YEAR(date) / MONTH(date) / DAY(date)</td>
<td>返回具体的日期值</td>
</tr>
<tr>
<td>HOUR(time) / MINUTE(time) / SECOND(time)</td>
<td>返回具体的时间值</td>
</tr>
<tr>
<td>MONTHNAME(date)</td>
<td>返回月份：January，…</td>
</tr>
<tr>
<td>DAYNAME(date)</td>
<td>返回星期几：MONDAY，TUESDAY…..SUNDAY</td>
</tr>
<tr>
<td>WEEKDAY(date)</td>
<td>返回周几，注意，周1是0，周2是1，。。。周日是6</td>
</tr>
<tr>
<td>QUARTER(date)</td>
<td>返回日期对应的季度，范围为1～4</td>
</tr>
<tr>
<td>WEEK(date) ， WEEKOFYEAR(date)</td>
<td>返回一年中的第几周</td>
</tr>
<tr>
<td>DAYOFYEAR(date)</td>
<td>返回日期是一年中的第几天</td>
</tr>
<tr>
<td>DAYOFMONTH(date)</td>
<td>返回日期位于所在月份的第几天</td>
</tr>
<tr>
<td>DAYOFWEEK(date)</td>
<td>返回周几，注意：周日是1，周一是2，。。。周六是7</td>
</tr>
</tbody></table>
<h5 id="3-4-日期的操作函数"><a href="#3-4-日期的操作函数" class="headerlink" title="3.4 日期的操作函数"></a><strong>3.4</strong> <strong>日期的操作函数</strong></h5><table>
<thead>
<tr>
<th>函数</th>
<th>用法</th>
</tr>
</thead>
<tbody><tr>
<td>EXTRACT(type FROM date)</td>
<td>返回指定日期中特定的部分，type指定返回的值</td>
</tr>
</tbody></table>
<p>EXTRACT(type FROM date)函数中type的取值与含义：</p>
<table>
<thead>
<tr>
<th align="left">type取值</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td align="left">MICROSECOND</td>
<td>返回毫秒数</td>
</tr>
<tr>
<td align="left">SECOND</td>
<td>返回秒数</td>
</tr>
<tr>
<td align="left">MINUTE</td>
<td>返回分钟数</td>
</tr>
<tr>
<td align="left">HOUR</td>
<td>返回小时数</td>
</tr>
<tr>
<td align="left">DAY</td>
<td>返回天数</td>
</tr>
<tr>
<td align="left">WEEK</td>
<td>返回日期在一年中的第几个星期</td>
</tr>
<tr>
<td align="left">MONTH</td>
<td>返回日期在一年中的第几个月</td>
</tr>
<tr>
<td align="left">QUARTER</td>
<td>返回日期在一年中的第几个季度</td>
</tr>
<tr>
<td align="left">YEAR</td>
<td>返回日期的年份</td>
</tr>
<tr>
<td align="left">SECOND_MICROSECOND</td>
<td>返回秒和毫秒值</td>
</tr>
<tr>
<td align="left">MINUTE_MICROSECOND</td>
<td>返回分钟和毫秒值</td>
</tr>
<tr>
<td align="left">MINUTE_SECOND</td>
<td>返回分钟和秒值</td>
</tr>
<tr>
<td align="left">HOUR_MICROSECOND</td>
<td>返回小时和毫秒值</td>
</tr>
<tr>
<td align="left">HOUR_SECOND</td>
<td>返回小时和秒值</td>
</tr>
<tr>
<td align="left">HOUR_MINUTE</td>
<td>返回小时和分钟值</td>
</tr>
<tr>
<td align="left">DAY_MICROSECOND</td>
<td>返回天和毫秒值</td>
</tr>
<tr>
<td align="left">DAY_SECOND</td>
<td>返回天和秒值</td>
</tr>
<tr>
<td align="left">DAY_MINUTE</td>
<td>返回天和分钟值</td>
</tr>
<tr>
<td align="left">DAY_HOUR</td>
<td>返回天和小时</td>
</tr>
<tr>
<td align="left">YEAR_MONTH</td>
<td>返回年和月</td>
</tr>
</tbody></table>
<h5 id="3-5-时间和秒钟转换的函数"><a href="#3-5-时间和秒钟转换的函数" class="headerlink" title="3.5 时间和秒钟转换的函数"></a><strong>3.5</strong> <strong>时间和秒钟转换的函数</strong></h5><table>
<thead>
<tr>
<th>函数</th>
<th>用法</th>
</tr>
</thead>
<tbody><tr>
<td>TIME_TO_SEC(time)</td>
<td>将 time 转化为秒并返回结果值。转化的公式为： 小时*3600+分钟*60+秒</td>
</tr>
<tr>
<td>SEC_TO_TIME(seconds)</td>
<td>将 seconds 描述转化为包含小时、分钟和秒的时间</td>
</tr>
</tbody></table>
<h5 id="3-6-计算日期和时间的函数"><a href="#3-6-计算日期和时间的函数" class="headerlink" title="3.6 计算日期和时间的函数"></a><strong>3.6</strong> <strong>计算日期和时间的函数</strong></h5><table>
<thead>
<tr>
<th>函数</th>
<th>用法</th>
</tr>
</thead>
<tbody><tr>
<td>DATE_ADD(datetime, INTERVAL expr type)，ADDDATE(date,INTERVAL expr type)</td>
<td>返回与给定日期时间相差INTERVAL时间段的日期时间</td>
</tr>
<tr>
<td>DATE_SUB(date,INTERVAL expr type)，SUBDATE(date,INTERVAL expr type)</td>
<td>返回与date相差INTERVAL时间间隔的日期</td>
</tr>
</tbody></table>
<p>上述函数中type的取值：</p>
<table>
<thead>
<tr>
<th>间隔类型</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>HOUR</td>
<td>小时</td>
</tr>
<tr>
<td>MINUTE</td>
<td>分钟</td>
</tr>
<tr>
<td>SECOND</td>
<td>秒</td>
</tr>
<tr>
<td>YEAR</td>
<td>年</td>
</tr>
<tr>
<td>MONTH</td>
<td>月</td>
</tr>
<tr>
<td>DAY</td>
<td>日</td>
</tr>
<tr>
<td>YEAR_MONTH</td>
<td>年和月</td>
</tr>
<tr>
<td>DAY_HOUR</td>
<td>日和小时</td>
</tr>
<tr>
<td>DAY_MINUTE</td>
<td>日和分钟</td>
</tr>
<tr>
<td>DAY_SECOND</td>
<td>日和秒</td>
</tr>
<tr>
<td>HOUR_MINUTE</td>
<td>小时和分钟</td>
</tr>
<tr>
<td>HOUR_SECOND</td>
<td>小时和秒</td>
</tr>
<tr>
<td>MINUTE_SECOND</td>
<td>分钟和秒</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>函数</th>
<th>用法</th>
</tr>
</thead>
<tbody><tr>
<td>ADDTIME(time1,time2)</td>
<td>返回time1加上time2的时间。当time2为一个数字时，代表的是秒 ，可以为负数</td>
</tr>
<tr>
<td>SUBTIME(time1,time2)</td>
<td>返回time1减去time2后的时间。当time2为一个数字时，代表的是秒，可以为负数</td>
</tr>
<tr>
<td>DATEDIFF(date1,date2)</td>
<td>返回date1 - date2的日期间隔天数</td>
</tr>
<tr>
<td>TIMEDIFF(time1, time2)</td>
<td>返回time1 - time2的时间间隔</td>
</tr>
<tr>
<td>FROM_DAYS(N)</td>
<td>返回从0000年1月1日起，N天以后的日期</td>
</tr>
<tr>
<td>TO_DAYS(date)</td>
<td>返回日期date距离0000年1月1日的天数</td>
</tr>
<tr>
<td>LAST_DAY(date)</td>
<td>返回date所在月份的最后一天的日期</td>
</tr>
<tr>
<td>MAKEDATE(year,n)</td>
<td>针对给定年份与所在年份中的天数返回一个日期</td>
</tr>
<tr>
<td>MAKETIME(hour,minute,second)</td>
<td>将给定的小时、分钟和秒组合成时间并返回</td>
</tr>
<tr>
<td>PERIOD_ADD(time,n)</td>
<td>返回time加上n后的时间</td>
</tr>
</tbody></table>
<h5 id="3-7-日期的格式化与解析"><a href="#3-7-日期的格式化与解析" class="headerlink" title="3.7 日期的格式化与解析"></a><strong>3.7</strong> <strong>日期的格式化与解析</strong></h5><table>
<thead>
<tr>
<th>函数</th>
<th>用法</th>
</tr>
</thead>
<tbody><tr>
<td>DATE_FORMAT(date,fmt)</td>
<td>按照字符串fmt格式化日期date值</td>
</tr>
<tr>
<td>TIME_FORMAT(time,fmt)</td>
<td>按照字符串fmt格式化时间time值</td>
</tr>
<tr>
<td>GET_FORMAT(date_type,format_type)</td>
<td>返回日期字符串的显示格式</td>
</tr>
<tr>
<td>STR_TO_DATE(str, fmt)</td>
<td>按照字符串fmt对str进行解析，解析为一个日期</td>
</tr>
</tbody></table>
<p>上述<code>非GET_FORMAT</code>函数中fmt参数常用的格式符：</p>
<table>
<thead>
<tr>
<th>格式符</th>
<th>说明</th>
<th>格式符</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>%Y</td>
<td>4位数字表示年份</td>
<td>%y</td>
<td>表示两位数字表示年份</td>
</tr>
<tr>
<td>%M</td>
<td>月名表示月份（January,….）</td>
<td>%m</td>
<td>两位数字表示月份（01,02,03。。。）</td>
</tr>
<tr>
<td>%b</td>
<td>缩写的月名（Jan.，Feb.，….）</td>
<td>%c</td>
<td>数字表示月份（1,2,3,…）</td>
</tr>
<tr>
<td>%D</td>
<td>英文后缀表示月中的天数（1st,2nd,3rd,…）</td>
<td>%d</td>
<td>两位数字表示月中的天数(01,02…)</td>
</tr>
<tr>
<td>%e</td>
<td>数字形式表示月中的天数（1,2,3,4,5…..）</td>
<td></td>
<td></td>
</tr>
<tr>
<td>%H</td>
<td>两位数字表示小数，24小时制（01,02..）</td>
<td>%h和%I</td>
<td>两位数字表示小时，12小时制（01,02..）</td>
</tr>
<tr>
<td>%k</td>
<td>数字形式的小时，24小时制(1,2,3)</td>
<td>%l</td>
<td>数字形式表示小时，12小时制（1,2,3,4….）</td>
</tr>
<tr>
<td>%i</td>
<td>两位数字表示分钟（00,01,02）</td>
<td>%S和%s</td>
<td>两位数字表示秒(00,01,02…)</td>
</tr>
<tr>
<td>%W</td>
<td>一周中的星期名称（Sunday…）</td>
<td>%a</td>
<td>一周中的星期缩写（Sun.，Mon.,Tues.，..）</td>
</tr>
<tr>
<td>%w</td>
<td>以数字表示周中的天数(0=Sunday,1=Monday….)</td>
<td></td>
<td></td>
</tr>
<tr>
<td>%j</td>
<td>以3位数字表示年中的天数(001,002…)</td>
<td>%U</td>
<td>以数字表示年中的第几周，（1,2,3。。）其中Sunday为周中第一天</td>
</tr>
<tr>
<td>%u</td>
<td>以数字表示年中的第几周，（1,2,3。。）其中Monday为周中第一天</td>
<td></td>
<td></td>
</tr>
<tr>
<td>%T</td>
<td>24小时制</td>
<td>%r</td>
<td>12小时制</td>
</tr>
<tr>
<td>%p</td>
<td>AM或PM</td>
<td>%%</td>
<td>表示%</td>
</tr>
</tbody></table>
<p>GET_FORMAT函数中date_type和format_type参数取值如下：</p>
<table>
<thead>
<tr>
<th>日期类型</th>
<th>格式化类型</th>
<th>返回的格式化字符串</th>
</tr>
</thead>
<tbody><tr>
<td>DATE</td>
<td>USA</td>
<td>%m.%d.%Y</td>
</tr>
<tr>
<td>DATE</td>
<td>JIS</td>
<td>%Y-%m-%d</td>
</tr>
<tr>
<td>DATE</td>
<td>ISO</td>
<td>%Y-%m-%d</td>
</tr>
<tr>
<td>DATE</td>
<td>EUR</td>
<td>%d.%m.%Y</td>
</tr>
<tr>
<td>DATE</td>
<td>INTERNAL</td>
<td>%Y%m%d</td>
</tr>
<tr>
<td>TIME</td>
<td>USA</td>
<td>%h:%i:%s %P</td>
</tr>
<tr>
<td>TIME</td>
<td>JIS</td>
<td>%H:%i:%s</td>
</tr>
<tr>
<td>TIME</td>
<td>ISO</td>
<td>%H:%i:%s</td>
</tr>
<tr>
<td>TIME</td>
<td>EUR</td>
<td>%H.%i.%s</td>
</tr>
<tr>
<td>TIME</td>
<td>INTERNAL</td>
<td>%H%i%s</td>
</tr>
<tr>
<td>DATETIME</td>
<td>USA</td>
<td>%Y-%m-%d %H.%i.%s</td>
</tr>
<tr>
<td>DATETIME</td>
<td>JIS</td>
<td>%Y-%m-%d %H:%i:%s</td>
</tr>
<tr>
<td>DATETIME</td>
<td>ISO</td>
<td>%Y-%m-%d %H:%i:%s</td>
</tr>
<tr>
<td>DATETIME</td>
<td>EUR</td>
<td>%Y-%m-%d %H.%i.%s</td>
</tr>
<tr>
<td>DATETIME</td>
<td>INTERNAL</td>
<td>%Y%m%d%H%i%s</td>
</tr>
</tbody></table>
<h4 id="4-流程控制函数"><a href="#4-流程控制函数" class="headerlink" title="4. 流程控制函数"></a><strong>4.</strong> <strong>流程控制函数</strong></h4><table>
<thead>
<tr>
<th>函数</th>
<th>用法</th>
</tr>
</thead>
<tbody><tr>
<td>IF(value,value1,value2)</td>
<td>如果value的值为TRUE，返回value1，否则返回value2</td>
</tr>
<tr>
<td>IFNULL(value1, value2)</td>
<td>如果value1不为NULL，返回value1，否则返回value2</td>
</tr>
<tr>
<td>CASE WHEN 条件1 THEN 结果1 WHEN 条件2 THEN 结果2…. [ELSE resultn] END</td>
<td>相当于Java的if…else if…else…</td>
</tr>
<tr>
<td>CASE expr WHEN 常量值1 THEN 值1 WHEN 常量值1 THEN 值1 …. [ELSE 值n] END</td>
<td>相当于Java的switch…case…</td>
</tr>
</tbody></table>
<h4 id="5-加密与解密函数"><a href="#5-加密与解密函数" class="headerlink" title="5. 加密与解密函数"></a><strong>5.</strong> <strong>加密与解密函数</strong></h4><table>
<thead>
<tr>
<th>函数</th>
<th>用法</th>
</tr>
</thead>
<tbody><tr>
<td>PASSWORD(str)</td>
<td>返回字符串str的加密版本，41位长的字符串。加密结果不可逆，常用于用户的密码加密。<strong>在mysql8.0中已弃用。</strong></td>
</tr>
<tr>
<td>MD5(str)</td>
<td>返回字符串str的md5加密后的值，也是一种加密方式。若参数为NULL，则会返回NULL</td>
</tr>
<tr>
<td>SHA(str)</td>
<td>从原明文密码str计算并返回加密后的密码字符串，当参数为NULL时，返回NULL。 SHA加密算法比MD5更加安全 。</td>
</tr>
<tr>
<td>ENCODE(value,password_seed)</td>
<td>返回使用password_seed作为加密密码加密value，<strong>在mysql8.0中已弃用。</strong></td>
</tr>
<tr>
<td>DECODE(value,password_seed)</td>
<td>返回使用password_seed作为加密密码解密value，<strong>在mysql8.0中已弃用。</strong></td>
</tr>
</tbody></table>
<h4 id="6-MySQL信息函数"><a href="#6-MySQL信息函数" class="headerlink" title="6. MySQL信息函数"></a><strong>6. MySQL信息函数</strong></h4><table>
<thead>
<tr>
<th>函数</th>
<th>用法</th>
</tr>
</thead>
<tbody><tr>
<td>VERSION()</td>
<td>返回当前MySQL的版本号</td>
</tr>
<tr>
<td>CONNECTION_ID()</td>
<td>返回当前MySQL服务器的连接数</td>
</tr>
<tr>
<td>DATABASE()，SCHEMA()</td>
<td>返回MySQL命令行当前所在的数据库</td>
</tr>
<tr>
<td>USER()，CURRENT_USER()、SYSTEM_USER()，SESSION_USER()</td>
<td>返回当前连接MySQL的用户名，返回结果格式为“主机名@用户名”</td>
</tr>
<tr>
<td>CHARSET(value)</td>
<td>返回字符串value自变量的字符集</td>
</tr>
<tr>
<td>COLLATION(value)</td>
<td>返回字符串value的比较规则</td>
</tr>
</tbody></table>
<h4 id="7-其他函数"><a href="#7-其他函数" class="headerlink" title="7. 其他函数"></a><strong>7.</strong> <strong>其他函数</strong></h4><table>
<thead>
<tr>
<th>函数</th>
<th>用法</th>
</tr>
</thead>
<tbody><tr>
<td>FORMAT(value,n)</td>
<td>返回对数字value进行格式化后的结果数据。n表示<code>四舍五入</code>后保留到小数点后n位</td>
</tr>
<tr>
<td>CONV(value,from,to)</td>
<td>将value的值进行不同进制之间的转换</td>
</tr>
<tr>
<td>INET_ATON(ipvalue)</td>
<td>将以点分隔的IP地址转化为一个数字</td>
</tr>
<tr>
<td>INET_NTOA(value)</td>
<td>将数字形式的IP地址转化为以点分隔的IP地址</td>
</tr>
<tr>
<td>BENCHMARK(n,expr)</td>
<td>将表达式expr重复执行n次。用于测试MySQL处理expr表达式所耗费的时间</td>
</tr>
<tr>
<td>CONVERT(value USING char_code)</td>
<td>将value所使用的字符编码修改为char_code</td>
</tr>
</tbody></table>
<h3 id="第08章-聚合函数"><a href="#第08章-聚合函数" class="headerlink" title="第08章 聚合函数"></a>第08章 聚合函数</h3><h4 id="1-聚合函数介绍"><a href="#1-聚合函数介绍" class="headerlink" title="1. 聚合函数介绍"></a><strong>1.</strong> <strong>聚合函数介绍</strong></h4><h5 id="1-1-AVG和SUM函数"><a href="#1-1-AVG和SUM函数" class="headerlink" title="1.1 AVG和SUM函数"></a><strong>1.1 AVG和SUM函数</strong></h5><p>可以对<strong>数值型数据</strong>使用AVG 和 SUM 函数。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="built_in">AVG</span>(salary), <span class="built_in">MAX</span>(salary),<span class="built_in">MIN</span>(salary), <span class="built_in">SUM</span>(salary)</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">FROM</span> employees</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">WHERE</span> job_id <span class="keyword">LIKE</span> <span class="string">&#x27;%REP%&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">-------------+-------------+-------------+-------------+</span></span><br><span class="line"><span class="operator">|</span> <span class="built_in">AVG</span>(salary) <span class="operator">|</span> <span class="built_in">MAX</span>(salary) <span class="operator">|</span> <span class="built_in">MIN</span>(salary) <span class="operator">|</span> <span class="built_in">SUM</span>(salary) <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------------+-------------+-------------+-------------+</span></span><br><span class="line"><span class="operator">|</span> <span class="number">8272.727273</span> <span class="operator">|</span>    <span class="number">11500.00</span> <span class="operator">|</span>     <span class="number">6000.00</span> <span class="operator">|</span>   <span class="number">273000.00</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------------+-------------+-------------+-------------+</span></span><br></pre></td></tr></table></figure>

<h5 id="1-2-MIN和MAX函数"><a href="#1-2-MIN和MAX函数" class="headerlink" title="1.2 MIN和MAX函数"></a><strong>1.2 MIN和MAX函数</strong></h5><p>可以对<strong>任意数据类型</strong>的数据使用 MIN 和 MAX 函数。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="built_in">MIN</span>(hire_date), <span class="built_in">MAX</span>(hire_date)</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">FROM</span> employees;</span><br><span class="line"><span class="operator">+</span><span class="comment">----------------+----------------+</span></span><br><span class="line"><span class="operator">|</span> <span class="built_in">MIN</span>(hire_date) <span class="operator">|</span> <span class="built_in">MAX</span>(hire_date) <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----------------+----------------+</span></span><br><span class="line"><span class="operator">|</span> <span class="number">1987</span><span class="number">-06</span><span class="number">-17</span>     <span class="operator">|</span> <span class="number">2000</span><span class="number">-04</span><span class="number">-21</span>     <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----------------+----------------+</span></span><br></pre></td></tr></table></figure>

<h5 id="1-3-COUNT函数"><a href="#1-3-COUNT函数" class="headerlink" title="1.3 COUNT函数"></a><strong>1.3 COUNT函数</strong></h5><ul>
<li>COUNT(*)返回表中记录总数，适用于<strong>任意数据类型</strong>。</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>)</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">FROM</span> employees</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">WHERE</span> department_id <span class="operator">=</span> <span class="number">50</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">----------+</span></span><br><span class="line"><span class="operator">|</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----------+</span></span><br><span class="line"><span class="operator">|</span>       <span class="number">45</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----------+</span></span><br></pre></td></tr></table></figure>

<ul>
<li>COUNT(expr) 返回<strong>expr不为NULL</strong>的记录总数。</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(commission_pct)</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">FROM</span> employees</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">WHERE</span> department_id <span class="operator">=</span> <span class="number">50</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">-----------------------+</span></span><br><span class="line"><span class="operator">|</span> <span class="built_in">COUNT</span>(commission_pct) <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----------------------+</span></span><br><span class="line"><span class="operator">|</span>                     <span class="number">0</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----------------------+</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>问题：用count(*)，count(1)，count(列名)谁好呢?</strong></li>
</ul>
<p>其实，对于MyISAM引擎的表是没有区别的。这种引擎内部有一计数器在维护着行数。</p>
<p>Innodb引擎的表用count(*),count(1)直接读行数，复杂度是O(n)，因为innodb真的要去数一遍。但好于具体的count(列名)。</p>
<ul>
<li><strong>问题：能不能使用count(列名)替换count(*)?</strong></li>
</ul>
<p>不要使用 count(列名)来替代<code>count(*)</code>，<code>count(*) </code>是 SQL92 定义的标准统计行数的语法，跟数据库无关，跟 NULL 和非 NULL 无关。</p>
<p>说明：count(*)会统计值为 NULL 的行，而 count(列名)不会统计此列为 NULL 值的行。</p>
<h4 id="2-GROUP-BY"><a href="#2-GROUP-BY" class="headerlink" title="2. GROUP BY"></a><strong>2. GROUP BY</strong></h4><h5 id="2-1-基本使用"><a href="#2-1-基本使用" class="headerlink" title="2.1 基本使用"></a><strong>2.1</strong> <strong>基本使用</strong></h5><p><strong>可以使用GROUP BY子句将表中的数据分成若干组</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">column</span>, group_function(<span class="keyword">column</span>)</span><br><span class="line"><span class="keyword">FROM</span> <span class="keyword">table</span> </span><br><span class="line">[<span class="keyword">WHERE</span> <span class="keyword">condition</span>]</span><br><span class="line">[<span class="keyword">GROUP</span> <span class="keyword">BY</span> group_by_expression]</span><br><span class="line">[<span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="keyword">column</span>];</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>明确：WHERE一定放在FROM后面</strong></p>
</blockquote>
<p><strong>在SELECT列表中所有未包含在组函数中的列都应该包含在GROUP BY子句中</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> department_id, <span class="built_in">AVG</span>(salary)</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> department_id;</span><br></pre></td></tr></table></figure>

<p>包含在 GROUP BY 子句中的列不必包含在SELECT 列表中</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">AVG</span>(salary) </span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> department_id;</span><br></pre></td></tr></table></figure>

<h5 id="2-2-使用多个列分组"><a href="#2-2-使用多个列分组" class="headerlink" title="2.2 使用多个列分组"></a><strong>2.2</strong> <strong>使用多个列分组</strong></h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> department_id dept_id, job_id, <span class="built_in">SUM</span>(salary)</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> department_id, job_id;</span><br></pre></td></tr></table></figure>

<p><strong>2.3 GROUP BY中使用WITH ROLLUP</strong></p>
<p>使用<code>WITH ROLLUP</code>关键字之后，在所有查询出的分组记录之后增加一条记录，该记录计算查询出的所有记录的总和，即统计记录数量。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> department_id,<span class="built_in">AVG</span>(salary)</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> department_id <span class="operator">&gt;</span> <span class="number">80</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> department_id <span class="keyword">WITH</span> <span class="keyword">ROLLUP</span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：</p>
<p>当使用ROLLUP时，不能同时使用ORDER BY子句进行结果排序，即ROLLUP和ORDER BY是互相排斥的。</p>
</blockquote>
<h4 id="3-HAVING"><a href="#3-HAVING" class="headerlink" title="3. HAVING"></a><strong>3. HAVING</strong></h4><h5 id="3-1-基本使用"><a href="#3-1-基本使用" class="headerlink" title="3.1 基本使用"></a><strong>3.1</strong> <strong>基本使用</strong></h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> department_id, <span class="built_in">MAX</span>(salary)</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> department_id</span><br><span class="line"><span class="keyword">HAVING</span> <span class="built_in">MAX</span>(salary)<span class="operator">&gt;</span><span class="number">10000</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>非法使用聚合函数 ： 不能在</strong> <strong>WHERE</strong> <strong>子句中使用聚合函数。</strong></li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> department_id, <span class="built_in">AVG</span>(salary)</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">FROM</span> employees</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">WHERE</span> <span class="built_in">AVG</span>(salary) <span class="operator">&gt;</span> <span class="number">8000</span></span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">GROUP</span> <span class="keyword">BY</span> department_id;</span><br><span class="line">ERROR <span class="number">1111</span> (HY000): Invalid use <span class="keyword">of</span> <span class="keyword">group</span> <span class="keyword">function</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>结论：</p>
<p>当过滤条件中有聚合函数时，则此过滤条件必须声明在HAVING中。</p>
<p>当过滤条件中没有聚合函数时，则此过滤条件声明在WHERE中或HAVING中都可以。但是，建议大家声明在WHERE中。</p>
</blockquote>
<h5 id="3-2-WHERE和HAVING的对比"><a href="#3-2-WHERE和HAVING的对比" class="headerlink" title="3.2 WHERE和HAVING的对比"></a><strong>3.2 WHERE和HAVING的对比</strong></h5><table>
<thead>
<tr>
<th></th>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody><tr>
<td>WHERE</td>
<td>先筛选数据再关联，执行效率高</td>
<td>不能使用分组中的计算函数进行筛选</td>
</tr>
<tr>
<td>HAVING</td>
<td>可以使用分组中的计算函数</td>
<td>在最后的结果集中进行筛选，执行效率较低</td>
</tr>
</tbody></table>
<h4 id="4-SELECT的执行过程"><a href="#4-SELECT的执行过程" class="headerlink" title="4. SELECT的执行过程"></a><strong>4. SELECT的执行过程</strong></h4><h5 id="4-1-查询的结构"><a href="#4-1-查询的结构" class="headerlink" title="4.1 查询的结构"></a><strong>4.1</strong> <strong>查询的结构</strong></h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#方式<span class="number">1</span>： </span><br><span class="line"><span class="keyword">SELECT</span> ...,....,...</span><br><span class="line"><span class="keyword">FROM</span> ...,...,....</span><br><span class="line"><span class="keyword">WHERE</span> 多表的连接条件</span><br><span class="line"><span class="keyword">AND</span> 不包含组函数的过滤条件</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> ...,...</span><br><span class="line"><span class="keyword">HAVING</span> 包含组函数的过滤条件</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> ... <span class="keyword">ASC</span><span class="operator">/</span><span class="keyword">DESC</span></span><br><span class="line">LIMIT ...,... </span><br><span class="line"></span><br><span class="line">#方式<span class="number">2</span>：</span><br><span class="line"><span class="keyword">SELECT</span> ...,....,...</span><br><span class="line"><span class="keyword">FROM</span> ... <span class="keyword">JOIN</span> ...</span><br><span class="line"><span class="keyword">ON</span> 多表的连接条件</span><br><span class="line"><span class="keyword">JOIN</span> ...</span><br><span class="line"><span class="keyword">ON</span> ...</span><br><span class="line"><span class="keyword">WHERE</span> 不包含组函数的过滤条件</span><br><span class="line"><span class="keyword">AND</span><span class="operator">/</span><span class="keyword">OR</span> 不包含组函数的过滤条件</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> ...,...</span><br><span class="line"><span class="keyword">HAVING</span> 包含组函数的过滤条件</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> ... <span class="keyword">ASC</span><span class="operator">/</span><span class="keyword">DESC</span></span><br><span class="line">LIMIT ...,...</span><br><span class="line"></span><br><span class="line">#其中： </span><br><span class="line">#（<span class="number">1</span>）<span class="keyword">from</span>：从哪些表中筛选 </span><br><span class="line">#（<span class="number">2</span>）<span class="keyword">on</span>：关联多表查询时，去除笛卡尔积 </span><br><span class="line">#（<span class="number">3</span>）<span class="keyword">where</span>：从表中筛选的条件</span><br><span class="line">#（<span class="number">4</span>）<span class="keyword">group</span> <span class="keyword">by</span>：分组依据 </span><br><span class="line">#（<span class="number">5</span>）<span class="keyword">having</span>：在统计结果中再次筛选 </span><br><span class="line">#（<span class="number">6</span>）<span class="keyword">order</span> <span class="keyword">by</span>：排序 </span><br><span class="line">#（<span class="number">7</span>）limit：分页</span><br></pre></td></tr></table></figure>

<h5 id="4-2-SELECT执行顺序"><a href="#4-2-SELECT执行顺序" class="headerlink" title="4.2 SELECT执行顺序"></a><strong>4.2 SELECT执行顺序</strong></h5><p>你需要记住 SELECT 查询时的两个顺序：</p>
<p><strong>1.</strong> <strong>关键字的顺序是不能颠倒的：</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> ... <span class="keyword">FROM</span> ... <span class="keyword">WHERE</span> ... <span class="keyword">GROUP</span> <span class="keyword">BY</span> ... <span class="keyword">HAVING</span> ... <span class="keyword">ORDER</span> <span class="keyword">BY</span> ... LIMIT...</span><br></pre></td></tr></table></figure>

<p><strong>2.SELECT</strong> <strong>语句的执行顺序</strong>（在 MySQL 和 Oracle 中，SELECT 执行顺序基本相同）：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#<span class="keyword">FROM</span> ...,...<span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">ON</span> <span class="operator">-</span><span class="operator">&gt;</span> (<span class="keyword">LEFT</span><span class="operator">/</span>RIGNT  <span class="keyword">JOIN</span>) <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">WHERE</span> <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">HAVING</span> <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">DISTINCT</span> <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="operator">-</span><span class="operator">&gt;</span> LIMIT</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> player_id, player_name, <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">as</span> num # 顺序 <span class="number">5</span></span><br><span class="line"><span class="keyword">FROM</span> player <span class="keyword">JOIN</span> team <span class="keyword">ON</span> player.team_id <span class="operator">=</span> team.team_id # 顺序 <span class="number">1</span></span><br><span class="line"><span class="keyword">WHERE</span> height <span class="operator">&gt;</span> <span class="number">1.80</span> # 顺序 <span class="number">2</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> player.team_id # 顺序 <span class="number">3</span></span><br><span class="line"><span class="keyword">HAVING</span> num <span class="operator">&gt;</span> <span class="number">2</span> # 顺序 <span class="number">4</span> </span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> num <span class="keyword">DESC</span> # 顺序 <span class="number">6</span></span><br><span class="line">LIMIT <span class="number">2</span> # 顺序 <span class="number">7</span></span><br></pre></td></tr></table></figure>

<p>在 SELECT 语句执行这些步骤的时候，每个步骤都会产生一个<code>虚拟表</code>，然后将这个虚拟表传入下一个步骤中作为输入。需要注意的是，这些步骤隐含在 SQL 的执行过程中，对于我们来说是不可见的。</p>
<h5 id="4-3-SQL-的执行原理"><a href="#4-3-SQL-的执行原理" class="headerlink" title="4.3 SQL 的执行原理"></a><strong>4.3 SQL</strong> <strong>的执行原理</strong></h5><p>SELECT 是先执行 FROM 这一步的。在这个阶段，如果是多张表联查，还会经历下面的几个步骤：</p>
<ol>
<li><p>首先先通过 CROSS JOIN 求笛卡尔积，相当于得到虚拟表 vt（virtual table）1-1； </p>
</li>
<li><p>通过 ON 进行筛选，在虚拟表 vt1-1 的基础上进行筛选，得到虚拟表 vt1-2； </p>
</li>
<li><p>添加外部行。如果我们使用的是左连接、右连接或者全连接，就会涉及到外部行，也就是在虚拟表 vt1-2 的基础上增加外部行，得到虚拟表 vt1-3。</p>
</li>
</ol>
<p>当然如果我们操作的是两张以上的表，还会重复上面的步骤，直到所有表都被处理完为止。这个过程得到是我们的原始数据。</p>
<p>当我们拿到了查询数据表的原始数据，也就是最终的虚拟表<code>vt1</code>，就可以在此基础上再进行<code>WHERE</code>阶段 。在这个阶段中，会根据 vt1 表的结果进行筛选过滤，得到虚拟表<code>vt2</code>。</p>
<p>然后进入第三步和第四步，也就是<code>GROUP</code>和<code>HAVING</code>阶段 。在这个阶段中，实际上是在虚拟表 vt2 的基础上进行分组和分组过滤，得到中间的虚拟表<code>vt3</code>和<code>vt4</code>。</p>
<p>当我们完成了条件筛选部分之后，就可以筛选表中提取的字段，也就是进入到<code>SELECT</code>和<code>DISTINCT</code>阶段 。</p>
<p>首先在 SELECT 阶段会提取想要的字段，然后在 DISTINCT 阶段过滤掉重复的行，分别得到中间的虚拟表<code>vt5-1</code>和<code>vt5-2</code>。</p>
<p>当我们提取了想要的字段数据之后，就可以按照指定的字段进行排序，也就是<code>ORDER BY</code>阶段 ，得到虚拟表<code>vt6</code>。</p>
<p>最后在 vt6 的基础上，取出指定行的记录，也就是<code>LIMIT</code>阶段 ，得到最终的结果，对应的是虚拟表<code>vt7</code>。</p>
<p>当然我们在写 SELECT 语句的时候，不一定存在所有的关键字，相应的阶段就会省略。</p>
<p>同时因为 SQL 是一门类似英语的结构化查询语言，所以我们在写 SELECT 语句的时候，还要注意相应的关键字顺序，<strong>所谓底层运行的原理，就是我们刚才讲到的执行顺序。</strong></p>
<h3 id="第09章-子查询"><a href="#第09章-子查询" class="headerlink" title="第09章 子查询"></a>第09章 子查询</h3><h4 id="1-需求分析与问题解决"><a href="#1-需求分析与问题解决" class="headerlink" title="1. 需求分析与问题解决"></a><strong>1.</strong> <strong>需求分析与问题解决</strong></h4><h5 id="1-1-实际问题"><a href="#1-1-实际问题" class="headerlink" title="1.1 实际问题"></a><strong>1.1</strong> <strong>实际问题</strong></h5><p><strong>题目：谁的工资比Abel高？</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#方式一：</span><br><span class="line"><span class="keyword">SELECT</span> salary</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> last_name <span class="operator">=</span> <span class="string">&#x27;Abel&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> last_name,salary</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> salary <span class="operator">&gt;</span> <span class="number">11000</span>;</span><br><span class="line"></span><br><span class="line">#方式二：自连接</span><br><span class="line"><span class="keyword">SELECT</span> e2.last_name,e2.salary </span><br><span class="line"><span class="keyword">FROM</span> employees e1,employees e2 </span><br><span class="line"><span class="keyword">WHERE</span> e1.last_name <span class="operator">=</span> <span class="string">&#x27;Abel&#x27;</span> </span><br><span class="line"><span class="keyword">AND</span> e1.`salary` <span class="operator">&lt;</span> e2.`salary`</span><br><span class="line"></span><br><span class="line">#方式三：子查询 </span><br><span class="line"><span class="keyword">SELECT</span> last_name,salary </span><br><span class="line"><span class="keyword">FROM</span> employees </span><br><span class="line"><span class="keyword">WHERE</span> salary <span class="operator">&gt;</span> ( </span><br><span class="line">    <span class="keyword">SELECT</span> salary </span><br><span class="line">    <span class="keyword">FROM</span> employees </span><br><span class="line">    <span class="keyword">WHERE</span> last_name <span class="operator">=</span> <span class="string">&#x27;Abel&#x27;</span> </span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h5 id="1-2-子查询的基本使用"><a href="#1-2-子查询的基本使用" class="headerlink" title="1.2 子查询的基本使用"></a><strong>1.2</strong> <strong>子查询的基本使用</strong></h5><ul>
<li>子查询（内查询）在主查询之前一次执行完成。</li>
<li>子查询的结果被主查询（外查询）使用 。</li>
<li><strong>注意事项</strong><ul>
<li>子查询要包含在括号内</li>
<li>将子查询放在比较条件的右侧</li>
<li>单行操作符对应单行子查询，多行操作符对应多行子查询</li>
</ul>
</li>
</ul>
<h5 id="1-3-子查询的分类"><a href="#1-3-子查询的分类" class="headerlink" title="1.3 子查询的分类"></a><strong>1.3</strong> <strong>子查询的分类</strong></h5><p><strong>分类方式1：</strong></p>
<p>我们按内查询的结果返回一条还是多条记录，将子查询分为<code>单行子查询</code>、<code>多行子查询</code>。</p>
<p><strong>分类方式2：</strong></p>
<p>我们按内查询是否被执行多次，将子查询划分为<code>相关(或关联)子查询</code>和<code>不相关(或非关联)子查询</code>。</p>
<h4 id="2-单行子查询"><a href="#2-单行子查询" class="headerlink" title="2. 单行子查询"></a><strong>2.</strong> <strong>单行子查询</strong></h4><h5 id="2-1-单行比较操作符"><a href="#2-1-单行比较操作符" class="headerlink" title="2.1 单行比较操作符"></a><strong>2.1</strong> <strong>单行比较操作符</strong></h5><table>
<thead>
<tr>
<th>操作符</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>=</td>
<td>equal to</td>
</tr>
<tr>
<td>&gt;</td>
<td>greater than</td>
</tr>
<tr>
<td>&gt;=</td>
<td>greater than or equal to</td>
</tr>
<tr>
<td>&lt;</td>
<td>less than</td>
</tr>
<tr>
<td>&lt;=</td>
<td>less than or equal to</td>
</tr>
<tr>
<td>&lt;&gt;</td>
<td>not equal to</td>
</tr>
</tbody></table>
<h5 id="2-2-代码示例"><a href="#2-2-代码示例" class="headerlink" title="2.2 代码示例"></a><strong>2.2</strong> <strong>代码示例</strong></h5><p><strong>题目：返回公司工资最少的员工的last_name,job_id和salary</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> last_name, job_id, salary </span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> salary <span class="operator">=</span> (</span><br><span class="line">    <span class="keyword">SELECT</span> <span class="built_in">MIN</span>(salary)</span><br><span class="line">    <span class="keyword">FROM</span> employees</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h5 id="2-3-HAVING-中的子查询"><a href="#2-3-HAVING-中的子查询" class="headerlink" title="2.3 HAVING 中的子查询"></a><strong>2.3 HAVING</strong> <strong>中的子查询</strong></h5><p><strong>题目：查询最低工资大于50号部门最低工资的部门id和其最低工资</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> department_id, <span class="built_in">MIN</span>(salary)</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> department_id</span><br><span class="line"><span class="keyword">HAVING</span> <span class="built_in">MIN</span>(salary) <span class="operator">&gt;</span> (</span><br><span class="line">    <span class="keyword">SELECT</span> <span class="built_in">MIN</span>(salary)</span><br><span class="line">    <span class="keyword">FROM</span> employees</span><br><span class="line">    <span class="keyword">WHERE</span> department_id <span class="operator">=</span> <span class="number">50</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h5 id="2-4-CASE中的子查询"><a href="#2-4-CASE中的子查询" class="headerlink" title="2.4 CASE中的子查询"></a><strong>2.4 CASE中的子查询</strong></h5><p><strong>题目：显示员工的employee_id,last_name和location。其中，若员工department_id与location_id为1800的department_id相同，则location为’Canada’，其余则为’USA’。</strong> </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> employee_id, last_name, (</span><br><span class="line">    <span class="keyword">CASE</span> department_id </span><br><span class="line">    <span class="keyword">WHEN</span> (</span><br><span class="line">        <span class="keyword">SELECT</span> department_id</span><br><span class="line">        <span class="keyword">FROM</span> departments</span><br><span class="line">        <span class="keyword">WHERE</span> location_id <span class="operator">=</span> <span class="number">1800</span></span><br><span class="line">    ) <span class="keyword">THEN</span> <span class="string">&#x27;Canada&#x27;</span> <span class="keyword">ELSE</span> <span class="string">&#x27;USA&#x27;</span> <span class="keyword">END</span></span><br><span class="line">) location</span><br><span class="line"><span class="keyword">FROM</span> employees;</span><br></pre></td></tr></table></figure>

<h5 id="2-5-子查询中的空值问题"><a href="#2-5-子查询中的空值问题" class="headerlink" title="2.5 子查询中的空值问题"></a><strong>2.5</strong> <strong>子查询中的空值问题</strong></h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> last_name, job_id</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">FROM</span> employees</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">WHERE</span> job_id <span class="operator">=</span> (</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span>     <span class="keyword">SELECT</span> job_id</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span>     <span class="keyword">FROM</span> employees</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span>     <span class="keyword">WHERE</span> last_name <span class="operator">=</span> <span class="string">&#x27;Haas&#x27;</span></span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> );</span><br><span class="line"><span class="keyword">Empty</span> <span class="keyword">set</span> (<span class="number">0.01</span> sec)</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>子查询不返回任何行</strong></p>
</blockquote>
<h5 id="2-6-非法使用子查询"><a href="#2-6-非法使用子查询" class="headerlink" title="2.6 非法使用子查询"></a><strong>2.6</strong> <strong>非法使用子查询</strong></h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> employee_id, last_name</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">FROM</span> employees</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">WHERE</span> salary <span class="operator">=</span> ( # 多行子查询使用单行比较符</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span>     <span class="keyword">SELECT</span> <span class="built_in">MIN</span>(salary)</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span>     <span class="keyword">FROM</span> employees</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span>     <span class="keyword">GROUP</span> <span class="keyword">BY</span> department_id</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> );</span><br><span class="line">ERROR <span class="number">1242</span> (<span class="number">21000</span>): Subquery <span class="keyword">returns</span> more than <span class="number">1</span> <span class="type">row</span></span><br></pre></td></tr></table></figure>

<h4 id="3-多行子查询"><a href="#3-多行子查询" class="headerlink" title="3. 多行子查询"></a><strong>3.</strong> <strong>多行子查询</strong></h4><h5 id="3-1-多行比较操作符"><a href="#3-1-多行比较操作符" class="headerlink" title="3.1 多行比较操作符"></a><strong>3.1</strong> <strong>多行比较操作符</strong></h5><table>
<thead>
<tr>
<th>操作符</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>IN</td>
<td>等于列表中的<strong>任意一个</strong></td>
</tr>
<tr>
<td>ANY</td>
<td>需要和单行比较操作符一起使用，和子查询返回的<strong>某一个</strong>值比较</td>
</tr>
<tr>
<td>ALL</td>
<td>需要和单行比较操作符一起使用，和子查询返回的<strong>所有</strong>值比较</td>
</tr>
<tr>
<td>SOME</td>
<td>实际上是ANY的别名，作用相同，一般常使用ANY</td>
</tr>
</tbody></table>
<h5 id="3-2-代码示例"><a href="#3-2-代码示例" class="headerlink" title="3.2 代码示例"></a><strong>3.2</strong> <strong>代码示例</strong></h5><p><strong>题目：查询平均工资最低的部门id</strong> </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#方式<span class="number">1</span>：</span><br><span class="line"><span class="keyword">SELECT</span> department_id </span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> department_id</span><br><span class="line"><span class="keyword">HAVING</span> <span class="built_in">AVG</span>(salary) <span class="operator">=</span> (</span><br><span class="line">    <span class="keyword">SELECT</span> <span class="built_in">MIN</span>(avg_sal) </span><br><span class="line">    <span class="keyword">FROM</span> (</span><br><span class="line">        <span class="keyword">SELECT</span> <span class="built_in">AVG</span>(salary) avg_sal </span><br><span class="line">        <span class="keyword">FROM</span> employees </span><br><span class="line">        <span class="keyword">GROUP</span> <span class="keyword">BY</span> department_id </span><br><span class="line">    ) dept_avg_sal </span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">#方式<span class="number">2</span>：</span><br><span class="line"><span class="keyword">SELECT</span> department_id </span><br><span class="line"><span class="keyword">FROM</span> employees </span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> department_id</span><br><span class="line"><span class="keyword">HAVING</span> <span class="built_in">AVG</span>(salary) <span class="operator">&lt;=</span> <span class="keyword">ALL</span> (</span><br><span class="line">    <span class="keyword">SELECT</span> <span class="built_in">AVG</span>(salary) avg_sal</span><br><span class="line">    <span class="keyword">FROM</span> employees</span><br><span class="line">    <span class="keyword">GROUP</span> <span class="keyword">BY</span> department_id </span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>MySQL中聚合函数是不能嵌套使用的。</p>
</blockquote>
<h5 id="3-3-空值问题"><a href="#3-3-空值问题" class="headerlink" title="3.3 空值问题"></a><strong>3.3</strong> <strong>空值问题</strong></h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> last_name</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">FROM</span> employees</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">WHERE</span> employee_id <span class="keyword">NOT</span> <span class="keyword">IN</span> (</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span>     <span class="keyword">SELECT</span> manager_id</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span>     <span class="keyword">FROM</span> employees</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> );</span><br><span class="line"><span class="keyword">Empty</span> <span class="keyword">set</span> (<span class="number">0.01</span> sec)</span><br></pre></td></tr></table></figure>

<h4 id="4-相关子查询"><a href="#4-相关子查询" class="headerlink" title="4. 相关子查询"></a><strong>4.</strong> <strong>相关子查询</strong></h4><h5 id="4-1-相关子查询执行流程"><a href="#4-1-相关子查询执行流程" class="headerlink" title="4.1 相关子查询执行流程"></a><strong>4.1</strong> <strong>相关子查询执行流程</strong></h5><p>如果子查询的执行依赖于外部查询，通常情况下都是因为子查询中的表用到了外部的表，并进行了条件关联，因此每执行一次外部查询，子查询都要重新计算一次，这样的子查询就称之为<code>关联子查询</code>。</p>
<h5 id="4-2-代码示例"><a href="#4-2-代码示例" class="headerlink" title="4.2 代码示例"></a><strong>4.2</strong> <strong>代码示例</strong></h5><p><strong>题目：查询员工中工资大于本部门平均工资的员工的last_name,salary和其department_id</strong></p>
<p><strong>方式一：相关子查询</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> last_name, salary, department_id</span><br><span class="line"><span class="keyword">FROM</span> employees e</span><br><span class="line"><span class="keyword">WHERE</span> salary <span class="operator">&gt;</span> (</span><br><span class="line">	<span class="keyword">SELECT</span> <span class="built_in">AVG</span>(salary)</span><br><span class="line">    <span class="keyword">FROM</span> employees</span><br><span class="line">    <span class="keyword">WHERE</span> department_id <span class="operator">=</span> e.department_id</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p><strong>方式二：在</strong> <strong>FROM</strong> <strong>中使用子查询</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> last_name,salary,e1.department_id</span><br><span class="line"><span class="keyword">FROM</span> employees e1,(</span><br><span class="line">    <span class="keyword">SELECT</span> department_id,<span class="built_in">AVG</span>(salary) dept_avg_sal</span><br><span class="line">    <span class="keyword">FROM</span> employees</span><br><span class="line">    <span class="keyword">GROUP</span> <span class="keyword">BY</span> department_id</span><br><span class="line">) e2 </span><br><span class="line"><span class="keyword">WHERE</span> e1.`department_id` <span class="operator">=</span> e2.department_id </span><br><span class="line"><span class="keyword">AND</span> e2.dept_avg_sal <span class="operator">&lt;</span> e1.`salary`;</span><br></pre></td></tr></table></figure>

<p>在ORDER BY 中使用子查询：</p>
<p><strong>题目：查询员工的id,salary,按照department_name排序</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> employee_id,salary</span><br><span class="line"><span class="keyword">FROM</span> employees e</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> (</span><br><span class="line">    <span class="keyword">SELECT</span> department_name </span><br><span class="line">    <span class="keyword">FROM</span> departments d</span><br><span class="line">    <span class="keyword">WHERE</span> e.`department_id` <span class="operator">=</span> d.`department_id` </span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>结论：在SELECT中，除了GROUP BY 和 LIMIT之外，其他位置都可以声明子查询！</p>
</blockquote>
<h5 id="4-3-EXISTS与NOT-EXISTS关键字"><a href="#4-3-EXISTS与NOT-EXISTS关键字" class="headerlink" title="4.3 EXISTS与NOT EXISTS关键字"></a><strong>4.3 EXISTS与NOT EXISTS关键字</strong></h5><ul>
<li>关联子查询通常也会和 EXISTS操作符一起来使用，用来检查在子查询中是否存在满足条件的行。</li>
<li><strong>如果在子查询中不存在满足条件的行：</strong><ul>
<li>条件返回 FALSE</li>
<li>继续在子查询中查找</li>
</ul>
</li>
<li><strong>如果在子查询中存在满足条件的行：</strong><ul>
<li>不在子查询中继续查找</li>
<li>条件返回 TRUE</li>
</ul>
</li>
<li>NOT EXISTS关键字表示如果不存在某种条件，则返回TRUE，否则返回FALSE。</li>
</ul>
<p><strong>题目：查询公司管理者的employee_id，last_name，job_id，department_id信息</strong></p>
<p>方式一：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> employee_id, last_name, job_id, department_id</span><br><span class="line"><span class="keyword">FROM</span> employees e1</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">EXISTS</span> ( </span><br><span class="line">    <span class="keyword">SELECT</span> <span class="operator">*</span> </span><br><span class="line">    <span class="keyword">FROM</span> employees e2 </span><br><span class="line">    <span class="keyword">WHERE</span> e2.manager_id <span class="operator">=</span> e1.employee_id</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>方式二：自连接</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> e1.employee_id, e1.last_name, e1.job_id, e1.department_id</span><br><span class="line"><span class="keyword">FROM</span> employees e1 <span class="keyword">JOIN</span> employees e2 </span><br><span class="line"><span class="keyword">WHERE</span> e1.employee_id <span class="operator">=</span> e2.manager_id;</span><br></pre></td></tr></table></figure>

<p>方式三：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> employee_id,last_name,job_id,department_id</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> employee_id <span class="keyword">IN</span> ( </span><br><span class="line">    <span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> manager_id </span><br><span class="line">    <span class="keyword">FROM</span> employees </span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p><strong>题目：查询departments表中，不存在于employees表中的部门的department_id和department_name</strong> </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> department_id,department_name</span><br><span class="line"><span class="keyword">FROM</span> departments d</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> (</span><br><span class="line">		<span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line">		<span class="keyword">FROM</span> employees e</span><br><span class="line">		<span class="keyword">WHERE</span> d.`department_id` <span class="operator">=</span> e.`department_id`</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>题目中可以使用子查询，也可以使用自连接。一般情况建议你使用自连接，因为在许多 DBMS 的处理过程中，对于自连接的处理速度要比子查询快得多。</p>
</blockquote>
<h3 id="第10章-创建和管理表"><a href="#第10章-创建和管理表" class="headerlink" title="第10章 创建和管理表"></a>第10章 创建和管理表</h3><h4 id="1-基础知识"><a href="#1-基础知识" class="headerlink" title="1. 基础知识"></a><strong>1.</strong> <strong>基础知识</strong></h4><h5 id="1-1-标识符命名规则"><a href="#1-1-标识符命名规则" class="headerlink" title="1.1 标识符命名规则"></a><strong>1.1</strong> <strong>标识符命名规则</strong></h5><ul>
<li>数据库名、表名不得超过30个字符，变量名限制为29个</li>
<li>必须只能包含 A–Z, a–z, 0–9, _共63个字符</li>
<li>数据库名、表名、字段名等对象名中间不要包含空格</li>
<li>同一个MySQL软件中，数据库不能同名；同一个库中，表不能重名；同一个表中，字段不能重名</li>
<li>必须保证你的字段没有和保留字、数据库系统或常用方法冲突。如果坚持使用，请在SQL语句中使用`（着重号）引起来</li>
<li>保持字段名和类型的一致性：在命名字段并为其指定数据类型的时候一定要保证一致性，假如数据类型在一个表里是整数，那在另一个表里可就别变成字符型了</li>
</ul>
<h4 id="2-创建和管理数据库"><a href="#2-创建和管理数据库" class="headerlink" title="2. 创建和管理数据库"></a><strong>2.</strong> <strong>创建和管理数据库</strong></h4><h5 id="2-1-创建数据库"><a href="#2-1-创建数据库" class="headerlink" title="2.1 创建数据库"></a><strong>2.1</strong> <strong>创建数据库</strong></h5><ul>
<li>方式1：创建数据库</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> DATABASE 数据库名;</span><br></pre></td></tr></table></figure>

<ul>
<li>方式2：创建数据库并指定字符集</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> DATABASE 数据库名 <span class="type">CHARACTER</span> <span class="keyword">SET</span> 字符集;</span><br></pre></td></tr></table></figure>

<ul>
<li>方式3：判断数据库是否已经存在，不存在则创建数据库（<code>推荐</code>）</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> DATABASE IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> 数据库名;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：DATABASE 不能改名。一些可视化工具可以改名，它是建新库，把所有表复制到新库，再删旧库完成的</p>
</blockquote>
<h5 id="2-2-使用数据库"><a href="#2-2-使用数据库" class="headerlink" title="2.2 使用数据库"></a><strong>2.2</strong> <strong>使用数据库</strong></h5><ul>
<li>查看当前所有的数据库</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> DATABASES; #有一个S，代表多个数据库</span><br></pre></td></tr></table></figure>

<ul>
<li>查看当前正在使用的数据库</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> DATABASE(); #使用的一个 mysql 中的全局函数</span><br></pre></td></tr></table></figure>

<ul>
<li>查看指定库下所有的表</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> TABLES <span class="keyword">FROM</span> 数据库名;</span><br></pre></td></tr></table></figure>

<ul>
<li>查看数据库的创建信息</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">CREATE</span> DATABASE 数据库名;</span><br><span class="line">或者： </span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">CREATE</span> DATABASE 数据库名\G</span><br></pre></td></tr></table></figure>

<ul>
<li>使用/切换数据库</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">USE 数据库名;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：要操作表格和数据之前必须先说明是对哪个数据库进行操作，否则就要对所有对象加上“数据库名.”。</p>
</blockquote>
<h5 id="2-3-修改数据库"><a href="#2-3-修改数据库" class="headerlink" title="2.3 修改数据库"></a><strong>2.3</strong> <strong>修改数据库</strong></h5><ul>
<li>更改数据库字符集</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> DATABASE 数据库名 <span class="type">CHARACTER</span> <span class="keyword">SET</span> 字符集; #比如：gbk、utf8等</span><br></pre></td></tr></table></figure>

<h5 id="2-4-删除数据库"><a href="#2-4-删除数据库" class="headerlink" title="2.4 删除数据库"></a><strong>2.4</strong> <strong>删除数据库</strong></h5><ul>
<li>方式1：删除指定的数据库</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> DATABASE 数据库名;</span><br></pre></td></tr></table></figure>

<ul>
<li>方式2：删除指定的数据库（<code>推荐</code>） </li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> DATABASE IF <span class="keyword">EXISTS</span> 数据库名;</span><br></pre></td></tr></table></figure>

<h4 id="3-创建表"><a href="#3-创建表" class="headerlink" title="3. 创建表"></a><strong>3.</strong> <strong>创建表</strong></h4><h5 id="3-1-创建方式1"><a href="#3-1-创建方式1" class="headerlink" title="3.1 创建方式1"></a><strong>3.1</strong> <strong>创建方式1</strong></h5><ul>
<li><strong>必须具备：</strong><ul>
<li>CREATE TABLE权限</li>
<li>存储空间</li>
</ul>
</li>
<li><strong>语法格式：</strong></li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> [IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span>] 表名( </span><br><span class="line">    字段<span class="number">1</span> 数据类型 [约束条件] [默认值], </span><br><span class="line">    字段<span class="number">2</span> 数据类型 [约束条件] [默认值], </span><br><span class="line">    字段<span class="number">3</span> 数据类型 [约束条件] [默认值], </span><br><span class="line">    ……</span><br><span class="line">    [表约束条件] </span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>加上了IF NOT EXISTS关键字，则表示：如果当前数据库中不存在要创建的数据表，则创建数据表；如果当前数据库中已经存在要创建的数据表，则忽略建表语句，不再创建数据表。</p>
</blockquote>
<h5 id="3-2-创建方式2"><a href="#3-2-创建方式2" class="headerlink" title="3.2 创建方式2"></a><strong>3.2</strong> <strong>创建方式2</strong></h5><ul>
<li>使用 AS subquery 选项，<strong>将创建表和插入数据结合起来</strong></li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="keyword">table</span> [(<span class="keyword">column</span>, column...)]</span><br><span class="line"><span class="keyword">AS</span> subquery;</span><br></pre></td></tr></table></figure>

<ul>
<li>指定的列和子查询中的列要一一对应</li>
<li>通过列名和默认值定义列</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> emp1 <span class="keyword">AS</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> employees; </span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> emp2 <span class="keyword">AS</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> employees <span class="keyword">WHERE</span> <span class="number">1</span><span class="operator">=</span><span class="number">2</span>; <span class="comment">-- 创建的emp2是空表</span></span><br></pre></td></tr></table></figure>

<h5 id="3-3-查看数据表结构"><a href="#3-3-查看数据表结构" class="headerlink" title="3.3 查看数据表结构"></a><strong>3.3</strong> <strong>查看数据表结构</strong></h5><p>在MySQL中创建好数据表之后，可以查看数据表的结构。MySQL支持使用<code>DESCRIBE/DESC </code>语句查看数据表结构，也支持使用<code>SHOW CREATE TABLE</code>语句查看数据表结构。</p>
<p>语法格式如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> 表名\G</span><br></pre></td></tr></table></figure>

<p>使用SHOW CREATE TABLE语句不仅可以查看表创建时的详细语句，还可以查看存储引擎和字符编码。</p>
<h4 id="4-修改表"><a href="#4-修改表" class="headerlink" title="4. 修改表"></a><strong>4.</strong> <strong>修改表</strong></h4><h5 id="4-1-追加一个列"><a href="#4-1-追加一个列" class="headerlink" title="4.1 追加一个列"></a><strong>4.1</strong> <strong>追加一个列</strong></h5><p>语法格式如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名</span><br><span class="line"><span class="keyword">ADD</span> [<span class="keyword">COLUMN</span>] 字段名 字段类型 [<span class="keyword">FIRST</span><span class="operator">|</span>AFTER 字段名];</span><br></pre></td></tr></table></figure>

<h5 id="4-2-修改一个列"><a href="#4-2-修改一个列" class="headerlink" title="4.2 修改一个列"></a><strong>4.2</strong> <strong>修改一个列</strong></h5><ul>
<li>修改字段数据类型、长度、默认值、位置的语法格式如下：</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名</span><br><span class="line">MODIFY [<span class="keyword">COLUMN</span>] 字段名<span class="number">1</span> 字段类型 [<span class="keyword">DEFAULT</span> 默认值][<span class="keyword">FIRST</span><span class="operator">|</span>AFTER 字段名 <span class="number">2</span>];</span><br></pre></td></tr></table></figure>

<ul>
<li>对默认值的修改只影响今后对表的修改</li>
</ul>
<h5 id="4-3-重命名一个列"><a href="#4-3-重命名一个列" class="headerlink" title="4.3 重命名一个列"></a><strong>4.3</strong> <strong>重命名一个列</strong></h5><ul>
<li>语法格式如下：</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名</span><br><span class="line">CHANGE [<span class="keyword">column</span>] 列名 新列名 新数据类型;</span><br></pre></td></tr></table></figure>

<h5 id="4-4-删除一个列"><a href="#4-4-删除一个列" class="headerlink" title="4.4 删除一个列"></a><strong>4.4</strong> <strong>删除一个列</strong></h5><ul>
<li>语法格式如下：</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名 </span><br><span class="line"><span class="keyword">DROP</span> [<span class="keyword">COLUMN</span>] 字段名;</span><br></pre></td></tr></table></figure>

<h4 id="5-重命名表"><a href="#5-重命名表" class="headerlink" title="5. 重命名表"></a><strong>5.</strong> <strong>重命名表</strong></h4><ul>
<li>方式一：使用RENAME（<code>推荐</code>）</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">RENAME <span class="keyword">TABLE</span> emp <span class="keyword">TO</span> myemp;</span><br></pre></td></tr></table></figure>

<ul>
<li>方式二：</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">table</span> dept</span><br><span class="line">RENAME [<span class="keyword">TO</span>] detail_dept; <span class="comment">-- [TO]可以省略</span></span><br></pre></td></tr></table></figure>

<h4 id="6-删除表"><a href="#6-删除表" class="headerlink" title="6. 删除表"></a><strong>6.</strong> <strong>删除表</strong></h4><ul>
<li>在MySQL中，当一张数据表<code>没有与其他任何数据表形成关联关系</code>时，可以将当前数据表直接删除。</li>
<li>数据和结构都被删除</li>
<li>所有正在运行的相关事务被提交</li>
<li>所有相关索引被删除</li>
<li>语法格式：</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> [IF <span class="keyword">EXISTS</span>] 数据表<span class="number">1</span> [, 数据表<span class="number">2</span>, …, 数据表n];</span><br></pre></td></tr></table></figure>

<p><code>IF EXISTS</code>的含义为：如果当前数据库中存在相应的数据表，则删除数据表；如果当前数据库中不存在相应的数据表，则忽略删除语句，不再执行删除数据表的操作。</p>
<ul>
<li>DROP TABLE 语句不能回滚</li>
</ul>
<h4 id="7-清空表"><a href="#7-清空表" class="headerlink" title="7. 清空表"></a><strong>7.</strong> <strong>清空表</strong></h4><ul>
<li>TRUNCATE TABLE语句：<ul>
<li>删除表中所有的数据</li>
<li>释放表的存储空间</li>
</ul>
</li>
<li>举例：</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">TRUNCATE</span> <span class="keyword">TABLE</span> detail_dept;</span><br></pre></td></tr></table></figure>

<ul>
<li>TRUNCATE语句<strong>不能回滚</strong>，而使用 DELETE 语句删除数据，可以回滚</li>
<li>COMMIT:提交数据。一旦执行COMMIT，则数据就被永久的保存在了数据库中，意味着数据不可以回滚。</li>
<li>ROLLBACK:回滚数据。一旦执行ROLLBACK,则可以实现数据的回滚。回滚到最近的一次COMMIT之后。</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SET</span> autocommit <span class="operator">=</span> <span class="literal">FALSE</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> emp2;</span><br><span class="line">#<span class="keyword">TRUNCATE</span> <span class="keyword">TABLE</span> emp2; </span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> emp2;</span><br><span class="line"><span class="keyword">ROLLBACK</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> emp2;</span><br></pre></td></tr></table></figure>

<p><strong>DDL 和 DML 的说明</strong></p>
<ul>
<li><p>DDL的操作一旦执行，就不可回滚。指令SET autocommit = FALSE对DDL操作失效。(因为在执行完DDL操作之后，一定会执行一次COMMIT。而此COMMIT操作不受SET autocommit = FALSE影响的。)</p>
</li>
<li><p>DML的操作默认情况，一旦执行，也是不可回滚的。但是，如果在执行DML之前，执行了 SET autocommit = FALSE，则执行的DML操作就可以实现回滚。</p>
</li>
</ul>
<blockquote>
<p>阿里开发规范：</p>
<p>【参考】TRUNCATE TABLE 比 DELETE 速度快，且使用的系统和事务日志资源少，但 TRUNCATE 无事务且不触发 TRIGGER，有可能造成事故，故不建议在开发代码中使用此语句。</p>
<p>说明：TRUNCATE TABLE 在功能上与不带 WHERE 子句的 DELETE 语句相同。</p>
</blockquote>
<h4 id="8-内容拓展"><a href="#8-内容拓展" class="headerlink" title="8. 内容拓展"></a><strong>8.</strong> <strong>内容拓展</strong></h4><p><strong>拓展1：阿里巴巴《Java开发手册》之MySQL字段命名</strong></p>
<ul>
<li><p>【<code>强制</code>】表名、字段名必须使用小写字母或数字，禁止出现数字开头，禁止两个下划线中间只出现数字。数据库字段名的修改代价很大，因为无法进行预发布，所以字段名称需要慎重考虑。</p>
<ul>
<li>正例：aliyun_admin，rdc_config，level3_name</li>
<li>反例：AliyunAdmin，rdcConfig，level_3_name </li>
</ul>
</li>
<li><p>【<code>强制</code>】禁用保留字，如 desc、range、match、delayed 等，请参考 MySQL 官方保留字。</p>
</li>
<li><p>【<code>强制</code>】表必备三字段：id, gmt_create, gmt_modified。</p>
<ul>
<li>说明：其中 id 必为主键，类型为BIGINT UNSIGNED、单表时自增、步长为 1。gmt_create, gmt_modified 的类型均为 DATETIME 类型，前者现在时表示主动式创建，后者过去分词表示被动式更新</li>
</ul>
</li>
<li><p>【<code>推荐</code>】表的命名最好是遵循 “业务名称_表的作用”。</p>
<ul>
<li>正例：alipay_task 、 force_project、 trade_config </li>
</ul>
</li>
<li><p>【<code>推荐</code>】库名与应用名称尽量一致。</p>
</li>
<li><p>【参考】合适的字符存储长度，不但节约数据库表空间、节约索引存储，更重要的是提升检索速度。</p>
</li>
</ul>
<p><strong>拓展2：如何理解清空表、删除表等操作需谨慎？！</strong> </p>
<p><code>表删除</code>操作将把表的定义和表中的数据一起删除，并且MySQL在执行删除操作时，不会有任何的确认信息提示，因此执行删除操作时应当慎重。在删除表前，最好对表中的数据进行<code>备份</code>，这样当操作失误时可以对数据进行恢复，以免造成无法挽回的后果。</p>
<p>同样的，在使用<code>ALTER TABLE</code>进行表的基本修改操作时，在执行操作过程之前，也应该确保对数据进行完整的<code>备份</code>，因为数据库的改变是<code>无法撤销</code>的，如果添加了一个不需要的字段，可以将其删除；相同的，如果删除了一个需要的列，该列下面的所有数据都将会丢失。</p>
<p><strong>拓展3：MySQL8新特性—DDL的原子化</strong></p>
<p>在MySQL 8.0版本中，InnoDB表的DDL支持事务完整性，即<code>DDL操作要么成功要么回滚</code>。DDL操作回滚日志写入到data dictionary数据字典表mysql.innodb_ddl_log（该表是隐藏的表，通过show tables无法看到）中，用于回滚操作。通过设置参数，可将DDL操作日志打印输出到MySQL错误日志中。</p>
<h3 id="第11章-数据处理之增删改"><a href="#第11章-数据处理之增删改" class="headerlink" title="第11章 数据处理之增删改"></a>第11章 数据处理之增删改</h3><h4 id="1-插入数据"><a href="#1-插入数据" class="headerlink" title="1. 插入数据"></a><strong>1.</strong> <strong>插入数据</strong></h4><h5 id="1-1-方式1：VALUES的方式添加"><a href="#1-1-方式1：VALUES的方式添加" class="headerlink" title="1.1 方式1：VALUES的方式添加"></a><strong>1.1</strong> <strong>方式1：VALUES的方式添加</strong></h5><p>使用这种语法一次只能向表中插入<strong>一条</strong>数据。</p>
<p><strong>情况1：为表的所有字段按默认顺序插入数据</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> 表名 </span><br><span class="line"><span class="keyword">VALUES</span> (value1,value2,....);</span><br></pre></td></tr></table></figure>

<p>值列表中需要为表的每一个字段指定值，并且值的顺序必须和数据表中字段定义时的顺序相同。</p>
<p><strong>情况2：为表的指定字段插入数据（推荐）</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> 表名(column1 [, column2, …, columnn]) </span><br><span class="line"><span class="keyword">VALUES</span> (value1 [,value2, …, valuen]);</span><br></pre></td></tr></table></figure>

<p>为表的指定字段插入数据，就是在INSERT语句中只向部分字段中插入值，而其他字段的值为表定义时的默认值。</p>
<p><strong>情况3：同时插入多条记录（推荐）</strong></p>
<p>INSERT语句可以同时向数据表中插入多条记录，插入时指定多个值列表，每个值列表之间用逗号分隔开，基本语法格式如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> table_name </span><br><span class="line"><span class="keyword">VALUES</span> </span><br><span class="line">(value1 [,value2, …, valuen]), </span><br><span class="line">(value1 [,value2, …, valuen]), </span><br><span class="line">……</span><br><span class="line">(value1 [,value2, …, valuen]);</span><br></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> table_name(column1 [, column2, …, columnn]) </span><br><span class="line"><span class="keyword">VALUES</span> </span><br><span class="line">(value1 [,value2, …, valuen]), </span><br><span class="line">(value1 [,value2, …, valuen]), </span><br><span class="line">……</span><br><span class="line">(value1 [,value2, …, valuen]);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>一个同时插入多行记录的INSERT语句等同于多个单行插入的INSERT语句，但是多行的INSERT语句在处理过程中<code>效率更高</code>。因为MySQL执行单条INSERT语句插入多行数据比使用多条INSERT语句快，所以在插入多条记录时最好选择使用单条INSERT语句的方式插入。</p>
<p>VALUES 也可以写成 VALUE ，但是VALUES是标准写法。</p>
</blockquote>
<h5 id="1-2-方式2：将查询结果插入到表中"><a href="#1-2-方式2：将查询结果插入到表中" class="headerlink" title="1.2 方式2：将查询结果插入到表中"></a><strong>1.2</strong> <strong>方式2：将查询结果插入到表中</strong></h5><p>INSERT还可以将SELECT语句查询的结果插入到表中，此时不需要把每一条记录的值一个一个输入，只需要使用一条INSERT语句和一条SELECT语句组成的组合语句即可快速地从一个或多个表中向一个表中插入多行。</p>
<p>基本语法格式如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> 目标表名 (tar_column1 [, tar_column2, …, tar_columnn]) </span><br><span class="line"><span class="keyword">SELECT</span> (src_column1 [, src_column2, …, src_columnn]) </span><br><span class="line"><span class="keyword">FROM</span> 源表名</span><br><span class="line">[<span class="keyword">WHERE</span> <span class="keyword">condition</span>]</span><br></pre></td></tr></table></figure>

<ul>
<li>在 INSERT 语句中加入子查询。</li>
<li><strong>不必书写</strong> <strong>VALUES</strong> <strong>子句。</strong></li>
<li>子查询中的值列表应与 INSERT 子句中的列名对应。</li>
</ul>
<p>举例：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> emp2 </span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> </span><br><span class="line"><span class="keyword">FROM</span> employees </span><br><span class="line"><span class="keyword">WHERE</span> department_id <span class="operator">=</span> <span class="number">90</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> sales_reps(id, name, salary, commission_pct) </span><br><span class="line"><span class="keyword">SELECT</span> employee_id, last_name, salary, commission_pct </span><br><span class="line"><span class="keyword">FROM</span> employees </span><br><span class="line"><span class="keyword">WHERE</span> job_id <span class="keyword">LIKE</span> <span class="string">&#x27;%REP%&#x27;</span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>说明：emp2表中要添加数据的字段的长度不能低于employees表中查询的字段的长度。</p>
<p>如果emp2表中要添加数据的字段的长度低于employees表中查询的字段的长度的话，就有添加不成功的风险。</p>
</blockquote>
<h4 id="2-更新数据"><a href="#2-更新数据" class="headerlink" title="2. 更新数据"></a><strong>2.</strong> <strong>更新数据</strong></h4><ul>
<li>使用 UPDATE 语句更新数据。语法如下：</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">UPDATE table_name </span><br><span class="line"><span class="keyword">SET</span> column1<span class="operator">=</span>value1, column2<span class="operator">=</span>value2, … , <span class="keyword">column</span><span class="operator">=</span>valuen </span><br><span class="line">[<span class="keyword">WHERE</span> <span class="keyword">condition</span>]</span><br></pre></td></tr></table></figure>

<ul>
<li>可以一次更新<strong>多条</strong>数据。</li>
<li>如果需要回滚数据，需要保证在DML前，进行设置：<strong>SET AUTOCOMMIT = FALSE;</strong></li>
<li>使用 <strong>WHERE</strong> 子句指定需要更新的数据。</li>
<li>如果省略 WHERE 子句，则表中的所有数据都将被更新。</li>
</ul>
<h4 id="3-删除数据"><a href="#3-删除数据" class="headerlink" title="3. 删除数据"></a><strong>3.</strong> <strong>删除数据</strong></h4><ul>
<li>使用 DELETE 语句从表中删除数据</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> table_name [<span class="keyword">WHERE</span> <span class="operator">&lt;</span><span class="keyword">condition</span><span class="operator">&gt;</span>];</span><br></pre></td></tr></table></figure>

<ul>
<li>使用 WHERE 子句删除指定的记录。</li>
<li>如果省略 WHERE 子句，则表中的全部数据将被删除</li>
</ul>
<h4 id="4-MySQL8新特性：计算列"><a href="#4-MySQL8新特性：计算列" class="headerlink" title="4. MySQL8新特性：计算列"></a><strong>4. MySQL8新特性：计算列</strong></h4><p>什么叫计算列呢？简单来说就是某一列的值是通过别的列计算得来的。例如，a列值为1、b列值为2，c列不需要手动插入，定义a+b的结果为c的值，那么c就是计算列，是通过别的列计算得来的。</p>
<p>在MySQL 8.0中，CREATE TABLE 和 ALTER TABLE 中都支持增加计算列。下面以CREATE TABLE为例进行讲解。</p>
<p>举例：定义数据表tb1，然后定义字段id、字段a、字段b和字段c，其中字段c为计算列，用于计算a+b的值。 首先创建测试表tb1，语句如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> tb1( </span><br><span class="line">    id <span class="type">INT</span>, </span><br><span class="line">    a <span class="type">INT</span>, </span><br><span class="line">    b <span class="type">INT</span>, </span><br><span class="line">    c <span class="type">INT</span> GENERATED ALWAYS <span class="keyword">AS</span> (a <span class="operator">+</span> b) VIRTUAL </span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>插入演示数据，语句如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> tb1(a,b) <span class="keyword">VALUES</span> (<span class="number">100</span>,<span class="number">200</span>);</span><br></pre></td></tr></table></figure>

<p>查询数据表tb1中的数据，结果如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> tb1;</span><br><span class="line"><span class="operator">+</span><span class="comment">------+------+------+------+</span></span><br><span class="line"><span class="operator">|</span> id   <span class="operator">|</span> a    <span class="operator">|</span> b    <span class="operator">|</span> c    <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------+------+------+------+</span></span><br><span class="line"><span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span>  <span class="number">100</span> <span class="operator">|</span>  <span class="number">200</span> <span class="operator">|</span>  <span class="number">300</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------+------+------+------+</span></span><br></pre></td></tr></table></figure>

<p>更新数据中的数据，语句如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> UPDATE tb1 <span class="keyword">SET</span> a <span class="operator">=</span> <span class="number">500</span>;</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> tb1;</span><br><span class="line"><span class="operator">+</span><span class="comment">------+------+------+------+</span></span><br><span class="line"><span class="operator">|</span> id   <span class="operator">|</span> a    <span class="operator">|</span> b    <span class="operator">|</span> c    <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------+------+------+------+</span></span><br><span class="line"><span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span>  <span class="number">500</span> <span class="operator">|</span>  <span class="number">200</span> <span class="operator">|</span>  <span class="number">700</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------+------+------+------+</span></span><br></pre></td></tr></table></figure>

<h3 id="第12章-MySQL数据类型精讲"><a href="#第12章-MySQL数据类型精讲" class="headerlink" title="第12章 MySQL数据类型精讲"></a>第12章 MySQL数据类型精讲</h3><h4 id="1-MySQL中的数据类型"><a href="#1-MySQL中的数据类型" class="headerlink" title="1. MySQL中的数据类型"></a><strong>1. MySQL中的数据类型</strong></h4><table>
<thead>
<tr>
<th>类型</th>
<th>类型举例</th>
</tr>
</thead>
<tbody><tr>
<td>整数类型</td>
<td>TINYINT、SMALLINT、MEDIUMINT、**INT(或INTEGER)**、BIGINT</td>
</tr>
<tr>
<td>浮点类型</td>
<td>FLOAT、DOUBLE</td>
</tr>
<tr>
<td>定点数类型</td>
<td><strong>DECIMAL</strong></td>
</tr>
<tr>
<td>位类型</td>
<td>BIT</td>
</tr>
<tr>
<td>日期时间类型</td>
<td>YEAR、TIME、DATE、<strong>DATETIME</strong>、TIMESTAMP</td>
</tr>
<tr>
<td>文本字符串类型</td>
<td>CHAR、<strong>VARCHAR</strong>、TINYTEXT、TEXT、MEDIUMTEXT、LONGTEXT</td>
</tr>
<tr>
<td>枚举类型</td>
<td>ENUM</td>
</tr>
<tr>
<td>集合类型</td>
<td>SET</td>
</tr>
<tr>
<td>二进制字符串类</td>
<td>BINARY、VARBINARY、TINYBLOB、BLOB、MEDIUMBLOB、LONGBLOB</td>
</tr>
<tr>
<td>JSON类型</td>
<td>JSON对象、JSON数组</td>
</tr>
<tr>
<td>空间数据类型</td>
<td>单值：GEOMETRY、POINT、LINESTRING、POLYGON；<br />集合：MULTIPOINT、MULTILINESTRING、MULTIPOLYGON、GEOMETRYCOLLECTION</td>
</tr>
</tbody></table>
<p>常见数据类型的属性，如下：</p>
<table>
<thead>
<tr>
<th>MySQL关键字</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>NULL</td>
<td>数据列可包含NULL值</td>
</tr>
<tr>
<td>NOT NULL</td>
<td>数据列不允许包含NULL值</td>
</tr>
<tr>
<td>DEFAULT</td>
<td>默认值</td>
</tr>
<tr>
<td>PRIMARY KEY</td>
<td>主键</td>
</tr>
<tr>
<td>AUTO_INCREMENT</td>
<td>自动递增，适用于整数类型</td>
</tr>
<tr>
<td>UNSIGNED</td>
<td>无符号</td>
</tr>
<tr>
<td>CHARACTER SET name</td>
<td>指定一个字符集</td>
</tr>
</tbody></table>
<h4 id="2-整数类型"><a href="#2-整数类型" class="headerlink" title="2. 整数类型"></a><strong>2.</strong> <strong>整数类型</strong></h4><h5 id="2-1-类型介绍"><a href="#2-1-类型介绍" class="headerlink" title="2.1 类型介绍"></a><strong>2.1</strong> <strong>类型介绍</strong></h5><p>整数类型一共有 5 种，包括 TINYINT、SMALLINT、MEDIUMINT、INT（INTEGER）和 BIGINT。</p>
<table>
<thead>
<tr>
<th>整数类型</th>
<th>字节</th>
<th>有符号数取值范围</th>
<th>无符号数取值范围</th>
</tr>
</thead>
<tbody><tr>
<td>TINYINT</td>
<td>1</td>
<td>-128~127</td>
<td>0~255</td>
</tr>
<tr>
<td>SMALLINT</td>
<td>2</td>
<td>-32768~32767</td>
<td>0~65535</td>
</tr>
<tr>
<td>MEDIUMINT</td>
<td>3</td>
<td>-8388608~8388607</td>
<td>0~16777215</td>
</tr>
<tr>
<td>INT、INTEGER</td>
<td>4</td>
<td>-2147483648~2147483647</td>
<td>0~4294967295</td>
</tr>
<tr>
<td>BIGINT</td>
<td>8</td>
<td>-9223372036854775808~9223372036854775807</td>
<td>0~18446744073709551615</td>
</tr>
</tbody></table>
<h5 id="2-2-可选属性"><a href="#2-2-可选属性" class="headerlink" title="2.2 可选属性"></a><strong>2.2</strong> <strong>可选属性</strong></h5><p><strong>整数类型的可选属性有三个：</strong></p>
<h6 id="2-2-1-M"><a href="#2-2-1-M" class="headerlink" title="2.2.1 M"></a><strong>2.2.1 M</strong></h6><p><code>M</code>: 表示显示宽度，M的取值范围是(0, 255)。例如，int(5)：当数据宽度小于5位的时候在数字前面需要用字符填满宽度。该项功能需要配合“<code>ZEROFILL</code>”使用，表示用“0”填满宽度，否则指定显示宽度无效。</p>
<p>如果设置了显示宽度，那么插入的数据宽度超过显示宽度限制，会不会截断或插入失败？</p>
<p>答案：不会对插入的数据有任何影响，还是按照类型的实际宽度进行保存，即<code>显示宽度与类型可以存储的值范围无关</code>。<strong>从MySQL 8.0.17开始，整数数据类型不推荐使用显示宽度属性。</strong></p>
<h6 id="2-2-2-UNSIGNED"><a href="#2-2-2-UNSIGNED" class="headerlink" title="2.2.2 UNSIGNED"></a><strong>2.2.2 UNSIGNED</strong></h6><p><code>UNSIGNED</code>: 无符号类型（非负），所有的整数类型都有一个可选的属性UNSIGNED（无符号属性），无符号整数类型的最小取值为0。所以，如果需要在MySQL数据库中保存非负整数值时，可以将整数类型设置为无符号类型。</p>
<blockquote>
<p>int类型默认显示宽度为int(11)，无符号int类型默认显示宽度为int(10)。因为负号占了一个数字位。</p>
</blockquote>
<h6 id="2-2-3-ZEROFILL"><a href="#2-2-3-ZEROFILL" class="headerlink" title="2.2.3 ZEROFILL"></a><strong>2.2.3 ZEROFILL</strong></h6><p><code>ZEROFILL</code>: 0填充,（如果某列是ZEROFILL，那么MySQL会自动为当前列添加UNSIGNED属性），如果指定了ZEROFILL只是表示不够M位时，用0在左边填充，如果超过M位，只要不超过数据存储范围即可。</p>
<h5 id="2-3-适用场景"><a href="#2-3-适用场景" class="headerlink" title="2.3 适用场景"></a><strong>2.3</strong> <strong>适用场景</strong></h5><p><code>TINYINT</code>：一般用于枚举数据，比如系统设定取值范围很小且固定的场景。</p>
<p><code>SMALLINT</code>：可以用于较小范围的统计数据，比如统计工厂的固定资产库存数量等。</p>
<p><code>MEDIUMINT</code>：用于较大整数的计算，比如车站每日的客流量等。</p>
<p><code>INT、INTEGER</code>：取值范围足够大，一般情况下不用考虑超限问题，用得最多。比如商品编号。</p>
<p><code>BIGINT</code>：只有当你处理特别巨大的整数时才会用到。比如双十一的交易量、大型门户网站点击量、证券公司衍生产品持仓等。</p>
<h5 id="2-4-如何选择？"><a href="#2-4-如何选择？" class="headerlink" title="2.4 如何选择？"></a><strong>2.4</strong> <strong>如何选择？</strong></h5><p>在评估用哪种整数类型的时候，你需要考虑<code>存储空间</code>和<code>可靠性</code>的平衡问题：一方 面，用占用字节数少的整数类型可以节省存储空间；另一方面，要是为了节省存储空间，使用的整数类型取值范围太小，一旦遇到超出取值范围的情况，就可能引起<code>系统错误</code>，影响可靠性。</p>
<p>举个例子，商品编号采用的数据类型是 INT。原因就在于，客户门店中流通的商品种类较多，而且，每天都有旧商品下架，新商品上架，这样不断迭代，日积月累。</p>
<p>如果使用 SMALLINT 类型，虽然占用字节数比 INT 类型的整数少，但是却不能保证数据不会超出范围65535。相反，使用 INT，就能确保有足够大的取值范围，不用担心数据超出范围影响可靠性的问题。</p>
<p>你要注意的是，在实际工作中，<strong>系统故障产生的成本远远超过增加几个字段存储空间所产生的成本</strong>。因此，我建议你首先确保数据不会超过取值范围，在这个前提之下，再去考虑如何节省存储空间。</p>
<h4 id="3-浮点类型"><a href="#3-浮点类型" class="headerlink" title="3. 浮点类型"></a><strong>3.</strong> <strong>浮点类型</strong></h4><h5 id="3-1-类型介绍"><a href="#3-1-类型介绍" class="headerlink" title="3.1 类型介绍"></a><strong>3.1</strong> <strong>类型介绍</strong></h5><p>浮点数和定点数类型的特点是可以<code>处理小数</code>，你可以把整数看成小数的一个特例。</p>
<ul>
<li>FLOAT 表示单精度浮点数；</li>
<li>DOUBLE 表示双精度浮点数；</li>
</ul>
<table>
<thead>
<tr>
<th>类型</th>
<th>占用字节数</th>
</tr>
</thead>
<tbody><tr>
<td>FLOAT</td>
<td>4</td>
</tr>
<tr>
<td>DOUBLE</td>
<td>8</td>
</tr>
</tbody></table>
<ul>
<li>REAL默认就是 DOUBLE。如果你把 SQL 模式设定为启用“<code>REAL_AS_FLOAT</code>”，那 么，MySQL 就认为REAL 是 FLOAT。如果要启用“REAL_AS_FLOAT”，可以通过以下 SQL 语句实现：</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SET</span> sql_mode <span class="operator">=</span> “REAL_AS_FLOAT”;</span><br></pre></td></tr></table></figure>

<p><strong>问题1：</strong>FLOAT 和 DOUBLE 这两种数据类型的区别是啥呢？</p>
<p>FLOAT 占用字节数少，取值范围小；DOUBLE 占用字节数多，取值范围也大。</p>
<p><strong>问题2</strong>：为什么浮点数类型的无符号数取值范围，只相当于有符号数取值范围的一半，也就是只相当于有符号数取值范围大于等于零的部分呢？</p>
<p>MySQL 存储浮点数的格式为：<code>符号(S) 、 尾数(M) 和 阶码(E)</code>。因此，无论有没有符号，MySQL 的浮点数都会存储表示符号的部分。因此， 所谓的无符号数取值范围，其实就是有符号数取值范围大于等于零的部分。</p>
<h5 id="3-2-数据精度说明"><a href="#3-2-数据精度说明" class="headerlink" title="3.2 数据精度说明"></a><strong>3.2</strong> <strong>数据精度说明</strong></h5><p>对于浮点类型，在MySQL中单精度值使用<code>4</code>个字节，双精度值使用<code>8</code>个字节。</p>
<ul>
<li><p>MySQL允许使用<code>非标准语法</code>（其他数据库未必支持，因此如果涉及到数据迁移，则最好不要这么用）：<code>FLOAT(M,D)</code>或<code>DOUBLE(M,D)</code>。这里，M称为<code>精度</code>，D称为<code>标度</code>。(M,D)中 M=整数位+小数位，D=小数位。 D&lt;=M&lt;=255，0&lt;=D&lt;=30。</p>
<p>例如，定义为FLOAT(5,2)的一个列可以显示为-999.99-999.99。如果超过这个范围会报错。</p>
</li>
<li><p>FLOAT和DOUBLE类型在不指定(M,D)时，默认会按照实际的精度（由实际的硬件和操作系统决定）来显示。</p>
</li>
<li><p>说明：浮点类型，也可以加<code>UNSIGNED</code>，但是不会改变数据范围，例如：FLOAT(3,2) UNSIGNED仍然只能表示0-9.99的范围。</p>
</li>
<li><p>不管是否显式设置了精度(M,D)，这里MySQL的处理方案如下：</p>
<ul>
<li>如果存储时，整数部分超出了范围，MySQL就会报错，不允许存这样的值</li>
<li>如果存储时，小数点部分若超出范围，就分以下情况：<ul>
<li>若四舍五入后，整数部分没有超出范围，则只警告，但能成功操作并四舍五入删除多余的小数位后保存。例如在FLOAT(5,2)列内插入999.009，近似结果是999.01。</li>
<li>若四舍五入后，整数部分超出范围，则MySQL报错，并拒绝处理。如FLOAT(5,2)列内插入999.995和-999.995都会报错。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>从MySQL 8.0.17开始，FLOAT(M,D)和DOUBLE(M,D)用法在官方文档中已经明确不推荐使用</strong>，将来可能被移除。另外，关于浮点型FLOAT和DOUBLE的UNSIGNED也不推荐使用了，将来也可能被移除。</p>
</li>
</ul>
<blockquote>
<p>在编程中，如果用到浮点数，要特别注意误差问题，<strong>因为浮点数是不准确的，所以我们要避免使用“=”来判断两个数是否相等。</strong></p>
</blockquote>
<h4 id="4-定点数类型"><a href="#4-定点数类型" class="headerlink" title="4. 定点数类型"></a><strong>4.</strong> <strong>定点数类型</strong></h4><h5 id="4-1-类型介绍"><a href="#4-1-类型介绍" class="headerlink" title="4.1 类型介绍"></a><strong>4.1</strong> <strong>类型介绍</strong></h5><ul>
<li>MySQL中的定点数类型只有 DECIMAL 一种类型。</li>
</ul>
<table>
<thead>
<tr>
<th>数据类型</th>
<th>字节数</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>DECIMAL(M,D),DEC,NUMERIC</td>
<td>M+2字节</td>
<td>有效范围由M和D决定</td>
</tr>
</tbody></table>
<p>使用 DECIMAL(M,D) 的方式表示高精度小数。其中，M被称为精度，D被称为标度。0&lt;=M&lt;=65， 0&lt;=D&lt;=30，D&lt;M。例如，定义DECIMAL（5,2）的类型，表示该列取值范围是-999.99~999.99。</p>
<ul>
<li><p><strong>DECIMAL(M,D)的最大取值范围与DOUBLE类型一样</strong>，但是有效的数据范围是由M和D决定的。</p>
</li>
<li><p>定点数在MySQL内部是以 字符串 的形式进行存储，这就决定了它一定是精准的。</p>
</li>
<li><p>当DECIMAL类型不指定精度和标度时，其默认为DECIMAL(10,0)。当数据的精度超出了定点数类型的精度范围时，则MySQL同样会进行四舍五入处理。</p>
</li>
<li><p><strong>浮点数</strong> <strong>vs</strong> <strong>定点数</strong></p>
<ul>
<li>浮点数相对于定点数的优点是在长度一定的情况下，浮点类型取值范围大，但是不精准，适用于需要取值范围大，又可以容忍微小误差的科学计算场景（比如计算化学、分子建模、流体动力学等）</li>
<li>定点数类型取值范围相对小，但是精准，没有误差，适合于对精度要求极高的场景 （比如涉及金额计算的场景）</li>
</ul>
</li>
</ul>
<h5 id="4-2-开发中经验"><a href="#4-2-开发中经验" class="headerlink" title="4.2 开发中经验"></a><strong>4.2</strong> <strong>开发中经验</strong></h5><blockquote>
<p>“由于 DECIMAL 数据类型的精准性，在我们的项目中，除了极少数（比如商品编号）用到整数类型外，其他的数值都用的是 DECIMAL，原因就是这个项目所处的零售行业，要求精准，一分钱也不能差。 ” ——来自某项目经理</p>
</blockquote>
<h4 id="5-位类型：BIT"><a href="#5-位类型：BIT" class="headerlink" title="5. 位类型：BIT"></a><strong>5.</strong> <strong>位类型：BIT</strong></h4><p>BIT类型中存储的是二进制值，类似010110。</p>
<table>
<thead>
<tr>
<th>二进制字符串类型</th>
<th>长度</th>
<th>长度范围</th>
<th>占用空间</th>
</tr>
</thead>
<tbody><tr>
<td>BIT(M)</td>
<td>M</td>
<td>1 &lt;= M &lt;= 64</td>
<td>约为(M + 7)/8个字节</td>
</tr>
</tbody></table>
<p>BIT类型，如果没有指定(M)，默认是1位。这个1位，表示只能存1位的二进制值。这里(M)是表示二进制的位数，位数最小值为1，最大值为64。</p>
<blockquote>
<p>使用b+0查询数据时，可以直接查询出存储的十进制数据的值。</p>
</blockquote>
<h4 id="6-日期与时间类型"><a href="#6-日期与时间类型" class="headerlink" title="6. 日期与时间类型"></a><strong>6.</strong> <strong>日期与时间类型</strong></h4><p>MySQL有多种表示日期和时间的数据类型，不同的版本可能有所差异，MySQL8.0版本支持的日期和时间类型主要有：YEAR类型、TIME类型、DATE类型、DATETIME类型和TIMESTAMP类型。</p>
<ul>
<li><code>YEAR</code>类型通常用来表示年</li>
<li><code>DATE</code>类型通常用来表示年、月、日</li>
<li><code>TIME</code>类型通常用来表示时、分、秒</li>
<li><code>DATETIME</code>类型通常用来表示年、月、日、时、分、秒</li>
<li><code>TIMESTAMP</code>类型通常用来表示带时区的年、月、日、时、分、秒</li>
</ul>
<table>
<thead>
<tr>
<th>类型</th>
<th>名称</th>
<th>字节</th>
<th>日期格式</th>
<th>最小值</th>
<th>最大值</th>
</tr>
</thead>
<tbody><tr>
<td>YEAR</td>
<td>年</td>
<td>1</td>
<td>YYYY或YY</td>
<td>1901</td>
<td>2155</td>
</tr>
<tr>
<td>TIME</td>
<td>时间</td>
<td>3</td>
<td>HH:MM:SS</td>
<td>-838:59:59</td>
<td>838:59:59</td>
</tr>
<tr>
<td>DATE</td>
<td>日期</td>
<td>3</td>
<td>YYYY-MM-DD</td>
<td>1000-01-01</td>
<td>9999-12-03</td>
</tr>
<tr>
<td>DATETIME</td>
<td>日期时间</td>
<td>8</td>
<td>YYYY-MM-DD HH:MM:SS</td>
<td>1000-01-01  00:00:00</td>
<td>9999-12-31 23:59:59</td>
</tr>
<tr>
<td>TIMESTAMP</td>
<td>日期时间</td>
<td>4</td>
<td>YYYY-MM-DD HH:MM:SS</td>
<td>1970-01-01 00:00:00 UTC</td>
<td>2038-01-19 03:14:07UTC</td>
</tr>
</tbody></table>
<h5 id="6-1-YEAR类型"><a href="#6-1-YEAR类型" class="headerlink" title="6.1 YEAR类型"></a><strong>6.1 YEAR类型</strong></h5><p>YEAR类型用来表示年份，在所有的日期时间类型中所占用的存储空间最小，只需要<code>1个字节 </code>的存储空间。</p>
<p>在MySQL中，YEAR有以下几种存储格式：</p>
<ul>
<li>以4位字符串或数字格式表示YEAR类型，其格式为YYYY，最小值为1901，最大值为2155。</li>
<li>以2位字符串格式表示YEAR类型，最小值为00，最大值为99。<ul>
<li>当取值为01到69时，表示2001到2069；</li>
<li>当取值为70到99时，表示1970到1999；</li>
<li>当取值整数的0或00添加的话，那么是0000年；</li>
<li>当取值是日期/字符串的’0’添加的话，是2000年。</li>
</ul>
</li>
</ul>
<p><strong>从MySQL5.5.27开始，2位格式的YEAR已经不推荐使用</strong>。</p>
<h5 id="6-2-DATE类型"><a href="#6-2-DATE类型" class="headerlink" title="6.2 DATE类型"></a><strong>6.2 DATE类型</strong></h5><p>DATE类型表示日期，没有时间部分，格式为<code>YYYY-MM-DD</code>，其中，YYYY表示年份，MM表示月份，DD表示日期。需要<code>3个字节</code>的存储空间。在向DATE类型的字段插入数据时，同样需要满足一定的格式条件。</p>
<ul>
<li>以<code>YYYY-MM-DD</code>格式或者<code>YYYYMMDD</code>格式表示的字符串日期，其最小取值为1000-01-01，最大取值为9999-12-03。YYYYMMDD格式会被转化为YYYY-MM-DD格式。</li>
<li>以<code>YY-MM-DD</code>格式或者<code>YYMMDD</code>格式表示的字符串日期，此格式中，年份为两位数值或字符串满足YEAR类型的格式条件为：当年份取值为00到69时，会被转化为2000到2069；当年份取值为70到99时，会被转化为1970到1999。</li>
<li>使用<code>CURRENT_DATE()</code>或者<code>NOW()</code>函数，会插入当前系统的日期。</li>
</ul>
<h5 id="6-3-TIME类型"><a href="#6-3-TIME类型" class="headerlink" title="6.3 TIME类型"></a><strong>6.3 TIME类型</strong></h5><p>TIME类型用来表示时间，不包含日期部分。在MySQL中，需要<code>3个字节</code>的存储空间来存储TIME类型的数据，可以使用“HH:MM:SS”格式来表示TIME类型，其中，HH表示小时，MM表示分钟，SS表示秒。</p>
<p>在MySQL中，向TIME类型的字段插入数据时，也可以使用几种不同的格式。 （1）可以使用带有冒号的字符串，比如’<code>D HH:MM:SS</code>‘、’<code>HH:MM:SS</code>‘、’<code>HH:MM</code>‘、’<code>D HH:MM</code>‘、’<code>D HH</code>‘或’<code>SS</code>‘格式，都能被正确地插入TIME类型的字段中。其中D表示天，其最小值为0，最大值为34。如果使用带有D格式的字符串插入TIME类型的字段时，D会被转化为小时，计算格式为D*24+HH。当使用带有冒号并且不带D的字符串表示时间时，表示当天的时间，比如12:10表示12:10:00，而不是00:12:10。 （2）可以使用不带有冒号的字符串或者数字，格式为’<code>HHMMSS</code>‘或者<code>HHMMSS</code>。如果插入一个不合法的字符串或者数字，MySQL在存储数据时，会将其自动转化为00:00:00进行存储。比如1210，MySQL会将最右边的两位解析成秒，表示00:12:10，而不是12:10:00。 （3）使用<code>CURRENT_TIME()</code>或者<code>NOW()</code>，会插入当前系统的时间。</p>
<p><strong>6.4 DATETIME类型</strong> </p>
<p>DATETIME类型在所有的日期时间类型中占用的存储空间最大，总共需要<code>8</code>个字节的存储空间。在格式上为DATE类型和TIME类型的组合，可以表示为<code>YYYY-MM-DD HH:MM:SS</code>，其中YYYY表示年份，MM表示月份，DD表示日期，HH表示小时，MM表示分钟，SS表示秒。</p>
<p>在向DATETIME类型的字段插入数据时，同样需要满足一定的格式条件。</p>
<ul>
<li>以<code>YYYY-MM-DD HH:MM:SS</code>格式或者<code>YYYYMMDDHHMMSS</code>格式的字符串插入DATETIME类型的字段时，最小值为1000-01-01 00:00:00，最大值为9999-12-03 23:59:59。 <ul>
<li>以YYYYMMDDHHMMSS格式的数字插入DATETIME类型的字段时，会被转化为YYYY-MM-DD HH:MM:SS格式。</li>
<li>以 YY-MM-DD HH:MM:SS 格式或者 YYMMDDHHMMSS 格式的字符串插入DATETIME类型的字段时，两位数的年份规则符合YEAR类型的规则，00到69表示2000到2069；70到99表示1970到1999。</li>
</ul>
</li>
<li>使用函数<code>CURRENT_TIMESTAMP()</code>和<code>NOW()</code>，可以向DATETIME类型的字段插入系统的当前日期和时间。</li>
</ul>
<h5 id="6-5-TIMESTAMP类型"><a href="#6-5-TIMESTAMP类型" class="headerlink" title="6.5 TIMESTAMP类型"></a><strong>6.5 TIMESTAMP类型</strong></h5><p>TIMESTAMP类型也可以表示日期时间，其显示格式与DATETIME类型相同，都是<code>YYYY-MM-DD HH:MM:SS</code>，需要4个字节的存储空间。但是TIMESTAMP存储的时间范围比DATETIME要小很多，只能存储“1970-01-01 00:00:01 UTC”到“2038-01-19 03:14:07 UTC”之间的时间。其中，UTC表示世界统一时间，也叫作世界标准时间。</p>
<ul>
<li><strong>存储数据的时候需要对当前时间所在的时区进行转换，查询数据的时候再将时间转换回当前的时区。因此，使用TIMESTAMP存储的同一个时间值，在不同的时区查询时会显示不同的时间。</strong></li>
</ul>
<p><strong>TIMESTAMP和DATETIME的区别：</strong></p>
<ul>
<li>TIMESTAMP存储空间比较小，表示的日期时间范围也比较小</li>
<li>底层存储方式不同，TIMESTAMP底层存储的是毫秒值，距离1970-1-1 0:0:0 0毫秒的毫秒值。</li>
<li>两个日期比较大小或日期计算时，TIMESTAMP更方便、更快。</li>
<li>TIMESTAMP和时区有关。TIMESTAMP会根据用户的时区不同，显示不同的结果。而DATETIME则只能反映出插入时当地的时区，其他时区的人查看数据必然会有误差的。</li>
</ul>
<h5 id="6-6-开发中经验"><a href="#6-6-开发中经验" class="headerlink" title="6.6 开发中经验"></a><strong>6.6</strong> <strong>开发中经验</strong></h5><p>用得最多的日期时间类型，就是<code>DATETIME</code>。虽然 MySQL 也支持 YEAR（年）、 TIME（时间）、DATE（日期），以及 TIMESTAMP 类型，但是在实际项目中，尽量用 DATETIME 类型。因为这个数据类型包括了完整的日期和时间信息，取值范围也最大，使用起来比较方便。毕竟，如果日期时间信息分散在好几个字段，很不容易记，而且查询的时候，SQL 语句也会更加复杂。</p>
<p>此外，一般存注册时间、商品发布时间等，不建议使用DATETIME存储，而是使用<code>时间戳</code>，因为DATETIME虽然直观，但不便于计算。</p>
<h4 id="7-文本字符串类型"><a href="#7-文本字符串类型" class="headerlink" title="7. 文本字符串类型"></a><strong>7.</strong> <strong>文本字符串类型</strong></h4><h5 id="7-1-CHAR与VARCHAR类型"><a href="#7-1-CHAR与VARCHAR类型" class="headerlink" title="7.1 CHAR与VARCHAR类型"></a><strong>7.1 CHAR与VARCHAR类型</strong></h5><table>
<thead>
<tr>
<th>字符串(文本)类型</th>
<th>特点</th>
<th>长度</th>
<th>长度范围</th>
<th>占用的存储空间</th>
</tr>
</thead>
<tbody><tr>
<td>CHAR(M)</td>
<td>固定长度</td>
<td>M</td>
<td>0 &lt;= M &lt;= 255</td>
<td>M个字节</td>
</tr>
<tr>
<td>VARCHAR(M)</td>
<td>可变长度</td>
<td>M</td>
<td>0 &lt;= M &lt;= 65535</td>
<td>(实际长度 + 1) 个字节</td>
</tr>
</tbody></table>
<p><strong>CHAR类型：</strong></p>
<ul>
<li>CHAR(M) 类型一般需要预先定义字符串长度。如果不指定(M)，则表示长度默认是1个字符。</li>
<li>如果保存时，数据的实际长度比CHAR类型声明的长度小，则会在<code>右侧填充</code>空格以达到指定的长度。当MySQL检索CHAR类型的数据时，CHAR类型的字段会去除尾部的空格。</li>
<li>定义CHAR类型字段时，声明的字段长度即为CHAR类型字段所占的存储空间的字节数。</li>
</ul>
<p><strong>VARCHAR类型：</strong></p>
<ul>
<li>VARCHAR(M) 定义时，<code>必须指定</code>长度M，否则报错。</li>
<li>MySQL4.0版本以下，varchar(20)：指的是20字节，如果存放UTF8汉字时，只能存6个（每个汉字3字节） ；MySQL5.0版本以上，varchar(20)：指的是20字符。</li>
<li>检索VARCHAR类型的字段数据时，会保留数据尾部的空格。VARCHAR类型的字段所占用的存储空间为字符串实际长度加1个字节。</li>
</ul>
<p><strong>哪些情况使用</strong> <strong>CHAR</strong> <strong>或</strong> <strong>VARCHAR</strong> <strong>更好</strong></p>
<table>
<thead>
<tr>
<th>类型</th>
<th>特点</th>
<th>空间上</th>
<th>时间上</th>
<th>适用场景</th>
</tr>
</thead>
<tbody><tr>
<td>CHAR(M)</td>
<td>固定长度</td>
<td>浪费存储空间</td>
<td>效率高</td>
<td>存储不大，速度要求高</td>
</tr>
<tr>
<td>VARCHAR(M)</td>
<td>可变长度</td>
<td>节省存储空间</td>
<td>效率低</td>
<td>非CHAR的情况</td>
</tr>
</tbody></table>
<p>情况1：存储很短的信息。比如门牌号码101，201……这样很短的信息应该用char，因为varchar还要占个byte用于存储信息长度，本来打算节约存储的，结果得不偿失。</p>
<p>情况2：固定长度的。比如使用uuid作为主键，那用char应该更合适。因为他固定长度，varchar动态根据长度的特性就消失了，而且还要占个长度信息。</p>
<p>情况3：十分频繁改变的column。因为varchar每次存储都要有额外的计算，得到长度等工作，如果一个非常频繁改变的，那就要有很多的精力用于计算，而这些对于char来说是不需要的。</p>
<p>情况4：具体存储引擎中的情况：</p>
<ul>
<li><code>MyISAM</code>数据存储引擎和数据列：MyISAM数据表，最好使用固定长度(CHAR)的数据列代替可变长度(VARCHAR)的数据列。这样使得整个表静态化，从而使<code>数据检索更快</code>，用空间换时间。</li>
<li><code>MEMORY</code>存储引擎和数据列：MEMORY数据表目前都使用固定长度的数据行存储，因此无论使用CHAR或VARCHAR列都没有关系，两者都是作为CHAR类型处理的。</li>
<li>InnoDB 存储引擎，建议使用VARCHAR类型。因为对于InnoDB数据表，内部的行存储格式并没有区分固定长度和可变长度列（所有数据行都使用指向数据列值的头指针），而且<strong>主要影响性能的因素是数据行使用的存储总量</strong>，由于char平均占用的空间多于varchar，所以除了简短并且固定长度的，其他考虑varchar。这样节省空间，对磁盘I/O和数据存储总量比较好。</li>
</ul>
<h5 id="7-2-TEXT类型"><a href="#7-2-TEXT类型" class="headerlink" title="7.2 TEXT类型"></a><strong>7.2 TEXT类型</strong></h5><table>
<thead>
<tr>
<th>文本字符串类型</th>
<th>特点</th>
<th>长度</th>
<th>长度范围</th>
<th>占用的存储空间</th>
</tr>
</thead>
<tbody><tr>
<td>TINYTEXT</td>
<td>小文本、可变长度</td>
<td>L</td>
<td>0 &lt;= L &lt;= 255</td>
<td>L + 2 个字节</td>
</tr>
<tr>
<td>TEXT</td>
<td>文本、可变长度</td>
<td>L</td>
<td>0 &lt;= L &lt;= 65535</td>
<td>L + 2 个字节</td>
</tr>
<tr>
<td>MEDIUMTEXT</td>
<td>中等文本、可变长度</td>
<td>L</td>
<td>0 &lt;= L &lt;= 16777215</td>
<td>L + 3 个字节</td>
</tr>
<tr>
<td>LONGTEXT</td>
<td>大文本、可变长度</td>
<td>L</td>
<td>0 &lt;= L&lt;= 4294967295（相当于4GB）</td>
<td>L + 4 个字节</td>
</tr>
</tbody></table>
<p><strong>由于实际存储的长度不确定，MySQL不允许</strong> <strong>TEXT</strong> <strong>类型的字段做主键</strong>。遇到这种情况，你只能采用CHAR(M)，或者 VARCHAR(M)。</p>
<p><strong>开发中经验：</strong></p>
<p>TEXT文本类型，可以存比较大的文本段，搜索速度稍慢，因此如果不是特别大的内容，建议使用CHAR， VARCHAR来代替。还有TEXT类型不用加默认值，加了也没用。而且text和blob类型的数据删除后容易导致“空洞”，使得文件碎片比较多，所以频繁使用的表不建议包含TEXT类型字段，建议单独分出去，单独用一个表。</p>
<h4 id="8-ENUM类型"><a href="#8-ENUM类型" class="headerlink" title="8. ENUM类型"></a><strong>8. ENUM类型</strong></h4><p>ENUM类型也叫作枚举类型，ENUM类型的取值范围需要在定义字段时进行指定。设置字段值时，ENUM类型只允许从成员中选取单个值，不能一次选取多个值。</p>
<table>
<thead>
<tr>
<th>文本字符串类型</th>
<th>长度</th>
<th>长度范围</th>
<th>占用的存储空间</th>
</tr>
</thead>
<tbody><tr>
<td>ENUM</td>
<td>L</td>
<td>1 &lt;= L &lt;= 65535</td>
<td>1或2个字节</td>
</tr>
</tbody></table>
<ul>
<li>当ENUM类型包含1～255个成员时，需要1个字节的存储空间；</li>
<li>当ENUM类型包含256～65535个成员时，需要2个字节的存储空间。</li>
<li>ENUM类型的成员个数的上限为65535个。</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> test_enum( </span><br><span class="line">    season ENUM(<span class="string">&#x27;春&#x27;</span>,<span class="string">&#x27;夏&#x27;</span>,<span class="string">&#x27;秋&#x27;</span>,<span class="string">&#x27;冬&#x27;</span>,<span class="string">&#x27;unknow&#x27;</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> test_enum </span><br><span class="line"><span class="keyword">VALUES</span>(<span class="string">&#x27;春&#x27;</span>),(<span class="string">&#x27;秋&#x27;</span>);</span><br><span class="line"></span><br><span class="line"># 允许按照角标的方式获取指定索引位置的枚举值</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> test_enum </span><br><span class="line"><span class="keyword">VALUES</span>(<span class="string">&#x27;1&#x27;</span>),(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"># 当ENUM类型的字段没有声明为<span class="keyword">NOT</span> <span class="keyword">NULL</span>时，插入<span class="keyword">NULL</span>也是有效的</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> test_enum</span><br><span class="line"><span class="keyword">VALUES</span>(<span class="keyword">NULL</span>);</span><br></pre></td></tr></table></figure>

<h4 id="9-SET类型"><a href="#9-SET类型" class="headerlink" title="9. SET类型"></a><strong>9. SET类型</strong></h4><p>SET表示一个字符串对象，可以包含0个或多个成员，但成员个数的上限为 64 。设置字段值时，可以取取值范围内的 0 个或多个值。</p>
<p>当SET类型包含的成员个数不同时，其所占用的存储空间也是不同的，具体如下：</p>
<table>
<thead>
<tr>
<th>成员个数范围（L表示实际成员个数）</th>
<th>占用的存储空间</th>
</tr>
</thead>
<tbody><tr>
<td>1 &lt;= L &lt;= 8</td>
<td>1个字节</td>
</tr>
<tr>
<td>9 &lt;= L &lt;= 16</td>
<td>2个字节</td>
</tr>
<tr>
<td>17 &lt;= L &lt;= 24</td>
<td>3个字节</td>
</tr>
<tr>
<td>25 &lt;= L &lt;= 32</td>
<td>4个字节</td>
</tr>
<tr>
<td>33 &lt;= L &lt;= 64</td>
<td>8个字节</td>
</tr>
</tbody></table>
<p>SET类型在存储数据时成员个数越多，其占用的存储空间越大。注意：SET类型在选取成员时，可以一次选择多个成员，这一点与ENUM类型不同。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> test_set(</span><br><span class="line">    s <span class="keyword">SET</span> (<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> test_set (s)</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="string">&#x27;A&#x27;</span>), (<span class="string">&#x27;A,B&#x27;</span>);</span><br><span class="line">#插入重复的<span class="keyword">SET</span>类型成员时，MySQL会自动删除重复的成员 </span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> test_set (s) </span><br><span class="line"><span class="keyword">VALUES</span> (<span class="string">&#x27;A,B,C,A&#x27;</span>);</span><br></pre></td></tr></table></figure>

<h4 id="10-二进制字符串类型"><a href="#10-二进制字符串类型" class="headerlink" title="10. 二进制字符串类型"></a><strong>10.</strong> <strong>二进制字符串类型</strong></h4><p>MySQL中的二进制字符串类型主要存储一些二进制数据，比如可以存储图片、音频和视频等二进制数据。</p>
<p><strong>BINARY与VARBINARY类型</strong> </p>
<p>BINARY和VARBINARY类似于CHAR和VARCHAR，只是它们存储的是二进制字符串。</p>
<p>BINARY (M)为固定长度的二进制字符串，M表示最多能存储的字节数，取值范围是0~255个字符。如果未指定(M)，表示只能存储<code>1个字节</code>。例如BINARY (8)，表示最多能存储8个字节，如果字段值不足(M)个字节，将在右边填充’\0’以补齐指定长度。</p>
<p>VARBINARY (M)为可变长度的二进制字符串，M表示最多能存储的字节数，总字节数不能超过行的字节长度限制65535，另外还要考虑额外字节开销，VARBINARY类型的数据除了存储数据本身外，还需要1或2个字节来存储数据的字节数。VARBINARY类型<code>必须指定(M)</code>，否则报错。</p>
<table>
<thead>
<tr>
<th>二进制字符串类型</th>
<th>特点</th>
<th>值的长度</th>
<th>占用空间</th>
</tr>
</thead>
<tbody><tr>
<td>BINARY(M)</td>
<td>固定长度</td>
<td>M （0 &lt;= M &lt;= 255）</td>
<td>M个字节</td>
</tr>
<tr>
<td>VARBINARY(M)</td>
<td>可变长度</td>
<td>M（0 &lt;= M &lt;= 65535）</td>
<td>M+1个字节</td>
</tr>
</tbody></table>
<p><strong>BLOB类型</strong> </p>
<p>BLOB是一个<code>二进制大对象</code>，可以容纳可变数量的数据。</p>
<p>需要注意的是，在实际工作中，往往不会在MySQL数据库中使用BLOB类型存储大对象数据，通常会将图片、音频和视频文件存储到<code>服务器的磁盘上</code>，并将图片、音频和视频的访问路径存储到MySQL中。</p>
<table>
<thead>
<tr>
<th>二进制字符串类型</th>
<th>值的长度</th>
<th>长度范围</th>
<th>占用空间</th>
</tr>
</thead>
<tbody><tr>
<td>TINYBLOB</td>
<td>L</td>
<td>0 &lt;= L &lt;= 255</td>
<td>L + 1 个字节</td>
</tr>
<tr>
<td>BLOB</td>
<td>L</td>
<td>0 &lt;= L &lt;= 65535（相当于64KB）</td>
<td>L + 2 个字节</td>
</tr>
<tr>
<td>MEDIUMBLOB</td>
<td>L</td>
<td>0 &lt;= L &lt;= 16777215 （相当于16MB）</td>
<td>L + 3 个字节</td>
</tr>
<tr>
<td>LONGBLOB</td>
<td>L</td>
<td>0 &lt;= L &lt;= 4294967295（相当于4GB）</td>
<td>L + 4 个字节</td>
</tr>
</tbody></table>
<p><strong>TEXT和BLOB的使用注意事项：</strong></p>
<p>在使用text和blob字段类型时要注意以下几点，以便更好的发挥数据库的性能。</p>
<p>① BLOB和TEXT值也会引起自己的一些问题，特别是执行了大量的删除或更新操作的时候。删除这种值会在数据表中留下很大的”<code>空洞</code>“，以后填入这些”空洞”的记录可能长度不同。为了提高性能，建议定期使用 OPTIMIZE TABLE 功能对这类表进行<code>碎片整理</code>。 </p>
<p>② 如果需要对大文本字段进行模糊查询，MySQL 提供了<code>前缀索引</code>。但是仍然要在不必要的时候避免检索大型的BLOB或TEXT值。例如，SELECT * 查询就不是很好的想法，除非你能够确定作为约束条件的WHERE子句只会找到所需要的数据行。否则，你可能毫无目的地在网络上传输大量的值。</p>
<p>③ 把BLOB或TEXT列<code>分离到单独的表</code>中。在某些环境中，如果把这些数据列移动到第二张数据表中，可以让你把原数据表中的数据列转换为固定长度的数据行格式，那么它就是有意义的。这会<code>减少主表中的碎片</code>，使你得到固定长度数据行的性能优势。它还使你在主数据表上运行 SELECT * 查询的时候不会通过网络传输大量的BLOB或TEXT值。</p>
<h4 id="11-JSON-类型"><a href="#11-JSON-类型" class="headerlink" title="11. JSON 类型"></a><strong>11. JSON</strong> <strong>类型</strong></h4><p>JSON（JavaScript Object Notation）是一种轻量级的 数据交换格式 。简洁和清晰的层次结构使得 JSON 成为理想的数据交换语言。它易于人阅读和编写，同时也易于机器解析和生成，并有效地提升网络传输效率。<strong>JSON</strong> <strong>可以将</strong> <strong>JavaScript</strong> <strong>对象中表示的一组数据转换为字符串，然后就可以在网络或者程序之间轻松地传递这个字符串，并在需要的时候将它还原为各编程语言所支持的数据格式。</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> test_json(</span><br><span class="line">    js json </span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> test_json (js) </span><br><span class="line"><span class="keyword">VALUES</span> (<span class="string">&#x27;&#123;&quot;name&quot;:&quot;songhk&quot;, &quot;age&quot;:18, &quot;address&quot;:&#123;&quot;province&quot;:&quot;beijing&quot;, &quot;city&quot;:&quot;beijing&quot;&#125;&#125;&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> js <span class="operator">-</span><span class="operator">&gt;</span> <span class="string">&#x27;$.name&#x27;</span> <span class="keyword">AS</span> NAME,js <span class="operator">-</span><span class="operator">&gt;</span> <span class="string">&#x27;$.age&#x27;</span> <span class="keyword">AS</span> age ,js <span class="operator">-</span><span class="operator">&gt;</span> <span class="string">&#x27;$.address.province&#x27;</span> <span class="keyword">AS</span> province, js <span class="operator">-</span><span class="operator">&gt;</span> <span class="string">&#x27;$.address.city&#x27;</span> <span class="keyword">AS</span> city </span><br><span class="line"><span class="keyword">FROM</span> test_json;</span><br></pre></td></tr></table></figure>

<h4 id="12-空间类型"><a href="#12-空间类型" class="headerlink" title="12. 空间类型"></a><strong>12.</strong> <strong>空间类型</strong></h4><p>MySQL的空间数据类型（Spatial Data Type）对应于OpenGIS类，包括单值类型：GEOMETRY、POINT、 LINESTRING、POLYGON以及集合类型：MULTIPOINT、MULTILINESTRING、MULTIPOLYGON、 GEOMETRYCOLLECTION 。</p>
<h4 id="13-小结及选择建议"><a href="#13-小结及选择建议" class="headerlink" title="13. 小结及选择建议"></a><strong>13.</strong> <strong>小结及选择建议</strong></h4><p>在定义数据类型时，如果确定是<code>整数</code>，就用<code>INT</code>； 如果是<code>小数</code>，一定用定点数类型<code>DECIMAL(M,D)</code>； 如果是日期与时间，就用<code>DATETIME</code>。</p>
<p>这样做的好处是，首先确保你的系统不会因为数据类型定义出错。不过，凡事都是有两面的，可靠性好，并不意味着高效。比如，TEXT 虽然使用方便，但是效率不如 CHAR(M) 和 VARCHAR(M)。</p>
<p>关于字符串的选择，建议参考如下阿里巴巴的《Java开发手册》规范：</p>
<p><strong>阿里巴巴《Java开发手册》之MySQL数据库：</strong></p>
<ul>
<li><p>任何字段如果为非负数，必须是 UNSIGNED</p>
</li>
<li><p>【<code>强制</code>】小数类型为 DECIMAL，禁止使用 FLOAT 和 DOUBLE。</p>
<ul>
<li>说明：在存储的时候，FLOAT 和 DOUBLE 都存在精度损失的问题，很可能在比较值的时候，得到不正确的结果。<strong>如果存储的数据范围超过 DECIMAL 的范围，建议将数据拆成整数和小数并分开存储。</strong></li>
</ul>
</li>
<li><p>【<code>强制</code>】如果存储的字符串长度几乎相等，使用 CHAR 定长字符串类型。</p>
<p>【<code>强制</code>】VARCHAR 是可变长字符串，不预先分配存储空间，长度不要超过 5000。如果存储长度大于此值，定义字段类型为 TEXT，独立出来一张表，用主键来对应，避免影响其它字段索引效率。</p>
</li>
</ul>
<h3 id="第13章-约束"><a href="#第13章-约束" class="headerlink" title="第13章 约束"></a>第13章 约束</h3><h4 id="1-约束-constraint-概述"><a href="#1-约束-constraint-概述" class="headerlink" title="1. 约束(constraint)概述"></a><strong>1.</strong> <strong>约束(constraint)概述</strong></h4><h5 id="1-1-为什么需要约束"><a href="#1-1-为什么需要约束" class="headerlink" title="1.1 为什么需要约束"></a><strong>1.1</strong> <strong>为什么需要约束</strong></h5><p>数据完整性（Data Integrity）是指数据的精确性（Accuracy）和可靠性（Reliability）。它是防止数据库中存在不符合语义规定的数据和防止因错误信息的输入输出造成无效操作或错误信息而提出的。</p>
<p>为了保证数据的完整性，SQL规范以约束的方式对<strong>表数据进行额外的条件限制</strong>。从以下四个方面考虑：</p>
<ul>
<li><code>实体完整性（Entity Integrity）</code>：例如，同一个表中，不能存在两条完全相同无法区分的记录</li>
<li><code>域完整性（Domain Integrity）</code>：例如：年龄范围0-120，性别范围“男/女” </li>
<li><code>引用完整性（Referential Integrity）</code>：例如：员工所在部门，在部门表中要能找到这个部门</li>
<li><code>用户自定义完整性（User-defined Integrity）</code>：例如：用户名唯一、密码不能为空等，本部门经理的工资不得高于本部门职工的平均工资的5倍。</li>
</ul>
<h5 id="1-2-什么是约束"><a href="#1-2-什么是约束" class="headerlink" title="1.2 什么是约束"></a><strong>1.2</strong> <strong>什么是约束</strong></h5><p>约束是表级的强制规定。</p>
<p>可以在<strong>创建表时规定约束（通过</strong> <strong>CREATE TABLE</strong> <strong>语句）</strong>，或者在<strong>表创建之后通过</strong> <strong>ALTER TABLE</strong> <strong>语句规定约束</strong>。 </p>
<h5 id="1-3-约束的分类"><a href="#1-3-约束的分类" class="headerlink" title="1.3 约束的分类"></a><strong>1.3</strong> <strong>约束的分类</strong></h5><ul>
<li><p><strong>根据约束数据列的限制，</strong>约束可分为：</p>
<ul>
<li><strong>单列约束</strong>：每个约束只约束一列</li>
<li><strong>多列约束</strong>：每个约束可约束多列数据</li>
</ul>
</li>
<li><p><strong>根据约束的作用范围</strong>，约束可分为：</p>
<ul>
<li><strong>列级约束</strong>：只能作用在一个列上，跟在列的定义后面</li>
<li><strong>表级约束</strong>：可以作用在多个列上，不与列一起，而是单独定义</li>
</ul>
</li>
<li><p><strong>根据约束起的作用</strong>，约束可分为：</p>
<ul>
<li><strong>NOT NULL</strong> <strong>非空约束，规定某个字段不能为空</strong></li>
<li><strong>UNIQUE</strong> <strong>唯一约束</strong>，<strong>规定某个字段在整个表中是唯一的</strong></li>
<li><strong>PRIMARY KEY</strong> <strong>主键(非空且唯一)约束</strong></li>
<li><strong>FOREIGN KEY</strong> <strong>外键约束</strong></li>
<li><strong>CHECK</strong> <strong>检查约束</strong></li>
<li><strong>DEFAULT</strong> <strong>默认值约束</strong></li>
</ul>
</li>
<li><p>查看某个表已有的约束</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#information_schema数据库名（系统库） </span><br><span class="line">#table_constraints表名称（专门存储各个表的约束）</span><br><span class="line">SELECT * FROM information_schema.table_constraints </span><br><span class="line">WHERE table_name &#x3D; &#39;表名称&#39;;</span><br></pre></td></tr></table></figure>

<h4 id="2-非空约束"><a href="#2-非空约束" class="headerlink" title="2. 非空约束"></a><strong>2.</strong> <strong>非空约束</strong></h4><h5 id="2-1-作用"><a href="#2-1-作用" class="headerlink" title="2.1 作用"></a><strong>2.1</strong> <strong>作用</strong></h5><p>限定某个字段/某列的值不允许为空</p>
<h5 id="2-2-关键字"><a href="#2-2-关键字" class="headerlink" title="2.2 关键字"></a><strong>2.2</strong> <strong>关键字</strong></h5><p>NOT NULL</p>
<h5 id="2-3-特点"><a href="#2-3-特点" class="headerlink" title="2.3 特点"></a><strong>2.3</strong> <strong>特点</strong></h5><ul>
<li>默认，所有的类型的值都可以是NULL，包括INT、FLOAT等数据类型</li>
<li>非空约束只能出现在表对象的列上，只能某个列单独限定非空，不能组合非空</li>
<li>一个表可以有很多列都分别限定了非空</li>
<li>空字符串’’不等于NULL，0也不等于NULL </li>
</ul>
<h5 id="2-4-添加非空约束"><a href="#2-4-添加非空约束" class="headerlink" title="2.4 添加非空约束"></a><strong>2.4</strong> <strong>添加非空约束</strong></h5><p>（1）建表时</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE 表名称( </span><br><span class="line">    字段名 数据类型, </span><br><span class="line">    字段名 数据类型 NOT NULL, </span><br><span class="line">    字段名 数据类型 NOT NULL </span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>（2）建表后</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ALTER TABLE 表名称 </span><br><span class="line">MODIFY 字段名 数据类型 NOT NULL;</span><br></pre></td></tr></table></figure>

<h5 id="2-5-删除非空约束"><a href="#2-5-删除非空约束" class="headerlink" title="2.5 删除非空约束"></a><strong>2.5</strong> <strong>删除非空约束</strong></h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 方式一：</span><br><span class="line">ALTER TABLE 表名称 </span><br><span class="line">MODIFY 字段名 数据类型 NULL; </span><br><span class="line"># 方式二：</span><br><span class="line">ALTER TABLE 表名称 </span><br><span class="line">MODIFY 字段名 数据类型;</span><br></pre></td></tr></table></figure>

<h4 id="3-唯一性约束"><a href="#3-唯一性约束" class="headerlink" title="3. 唯一性约束"></a><strong>3.</strong> <strong>唯一性约束</strong></h4><h5 id="3-1-作用"><a href="#3-1-作用" class="headerlink" title="3.1 作用"></a><strong>3.1</strong> <strong>作用</strong></h5><p>用来限制某个字段/某列的值不能重复。</p>
<h5 id="3-2-关键字"><a href="#3-2-关键字" class="headerlink" title="3.2 关键字"></a><strong>3.2</strong> <strong>关键字</strong></h5><p>UNIQUE</p>
<h5 id="3-3-特点"><a href="#3-3-特点" class="headerlink" title="3.3 特点"></a><strong>3.3</strong> <strong>特点</strong></h5><ul>
<li>同一个表可以有多个唯一约束。</li>
<li>唯一约束可以是某一个列的值唯一，也可以多个列组合的值唯一。</li>
<li>唯一性约束允许列值为空。</li>
<li>在创建唯一约束的时候，如果不给唯一约束命名，就默认和列名相同。</li>
<li><strong>MySQL会给唯一约束的列上默认创建一个唯一索引。</strong></li>
</ul>
<h5 id="3-4-添加（复合）唯一约束"><a href="#3-4-添加（复合）唯一约束" class="headerlink" title="3.4 添加（复合）唯一约束"></a><strong>3.4</strong> <strong>添加（复合）唯一约束</strong></h5><p>（1）建表时</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE 表名称( </span><br><span class="line">    字段名 数据类型, </span><br><span class="line">    字段名 数据类型 UNIQUE [KEY], </span><br><span class="line">    字段名 数据类型 </span><br><span class="line">);</span><br><span class="line">CREATE TABLE 表名称( </span><br><span class="line">    字段名 数据类型, </span><br><span class="line">    字段名 数据类型, </span><br><span class="line">    字段名 数据类型, </span><br><span class="line">    [CONSTRAINT 约束名] UNIQUE [KEY](字段列表)  #多个字段之间用逗号隔开</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>（2）建表后指定唯一键约束</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#字段列表中如果是一个字段，表示该列的值唯一。如果是两个或更多个字段，那么复合唯一，即多个字段的组合是唯一的</span><br><span class="line">#方式1： </span><br><span class="line">ALTER TABLE 表名称 </span><br><span class="line">ADD [CONSTRAINT 约束名] UNIQUE [KEY](字段列表); #多个字段之间用逗号隔开</span><br><span class="line">#方式2： </span><br><span class="line">ALTER TABLE 表名称 </span><br><span class="line">MODIFY 字段名 字段类型 UNIQUE [KEY];</span><br></pre></td></tr></table></figure>

<blockquote>
<p>可以向声明为unique的字段上添加null值。而且可以多次添加null</p>
</blockquote>
<h5 id="3-5-删除唯一约束"><a href="#3-5-删除唯一约束" class="headerlink" title="3.5 删除唯一约束"></a><strong>3.5</strong> <strong>删除唯一约束</strong></h5><ul>
<li>添加唯一性约束的列上也会自动创建唯一索引。</li>
<li>删除唯一约束只能通过删除唯一索引的方式删除。</li>
<li>删除时需要指定唯一索引名，唯一索引名就和唯一约束名一样。</li>
<li>如果创建唯一约束时未指定名称，如果是单列，就默认和列名相同；如果是组合列，那么默认和(字段列表)中排在第一个的列名相同。也可以自定义唯一性约束名。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ALTER TABLE 表名称</span><br><span class="line">DROP INDEX 索引名;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：可以通过<code>show index from 表名称;</code>查看表的索引</p>
</blockquote>
<h4 id="4-PRIMARY-KEY-约束"><a href="#4-PRIMARY-KEY-约束" class="headerlink" title="4. PRIMARY KEY 约束"></a><strong>4. PRIMARY KEY</strong> <strong>约束</strong></h4><h5 id="4-1-作用"><a href="#4-1-作用" class="headerlink" title="4.1 作用"></a><strong>4.1</strong> <strong>作用</strong></h5><p>用来唯一标识表中的一行记录</p>
<h5 id="4-2-关键字"><a href="#4-2-关键字" class="headerlink" title="4.2 关键字"></a><strong>4.2</strong> <strong>关键字</strong></h5><p>primary key </p>
<h5 id="4-3-特点"><a href="#4-3-特点" class="headerlink" title="4.3 特点"></a><strong>4.3</strong> <strong>特点</strong></h5><ul>
<li><p>主键约束相当于<strong>唯一约束+非空约束的组合</strong>，主键约束列不允许重复，也不允许出现空值</p>
</li>
<li><p>一个表最多只能有一个主键约束，建立主键约束可以在列级别创建，也可以在表级别上创建。</p>
</li>
<li><p>主键约束对应着表中的一列或者多列（复合主键）</p>
</li>
<li><p>如果是多列组合的复合主键约束，那么这些列<strong>都不允许</strong>为空值，并且组合的值不允许重复。</p>
</li>
<li><p><strong>MySQL的主键名总是PRIMARY</strong>，就算自己命名了主键约束名也没用。</p>
</li>
<li><p>当创建主键约束时，系统默认会在所在的列或列组合上建立对应的<strong>主键索引</strong>（能够根据主键查询的，就根据主键查询，效率更高）。如果删除主键约束了，主键约束对应的索引就自动删除了。</p>
</li>
<li><p>需要注意的一点是，不要修改主键字段的值。因为主键是数据记录的唯一标识，如果修改了主键的值，就有可能会破坏数据的完整性。</p>
</li>
</ul>
<h5 id="4-4-添加（复合）主键约束"><a href="#4-4-添加（复合）主键约束" class="headerlink" title="4.4 添加（复合）主键约束"></a><strong>4.4</strong> <strong>添加（复合）主键约束</strong></h5><p>（1）建表时指定主键约束</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create table 表名称( </span><br><span class="line">    字段名 数据类型 primary key, #列级模式 </span><br><span class="line">    字段名 数据类型, </span><br><span class="line">    字段名 数据类型 </span><br><span class="line">);</span><br><span class="line">create table 表名称( </span><br><span class="line">    字段名 数据类型, </span><br><span class="line">    字段名 数据类型, </span><br><span class="line">    字段名 数据类型, </span><br><span class="line">    [constraint 约束名] primary key(字段列表) #表级模式，多个字段之间用逗号隔开</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 列级约束</span><br><span class="line">CREATE TABLE emp4( </span><br><span class="line">    id INT PRIMARY KEY AUTO_INCREMENT, # AUTO_INCREMENT 表示自增</span><br><span class="line">    NAME VARCHAR(20) </span><br><span class="line">);</span><br><span class="line"># 表级约束</span><br><span class="line">CREATE TABLE emp5( </span><br><span class="line">    id INT NOT NULL AUTO_INCREMENT, </span><br><span class="line">    NAME VARCHAR(20), pwd VARCHAR(15), </span><br><span class="line">    CONSTRAINT emp5_id_pk PRIMARY KEY(id) #没有必要起名字</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>（2）建表后增加主键约束</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ALTER TABLE 表名称 </span><br><span class="line">ADD PRIMARY KEY(字段列表); #字段列表可以是一个字段，也可以是多个字段，如果是多个字段的话，是复合主键</span><br></pre></td></tr></table></figure>

<h5 id="4-5-删除主键约束"><a href="#4-5-删除主键约束" class="headerlink" title="4.5 删除主键约束"></a><strong>4.5</strong> <strong>删除主键约束</strong></h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">alter table 表名称 </span><br><span class="line">drop primary key;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>说明：删除主键约束，不需要指定主键名，因为一个表只有一个主键，删除主键约束后，非空还存在。</p>
<p>在实际开发中，不会去删除表中的主键约束！</p>
</blockquote>
<h4 id="5-自增列：AUTO-INCREMENT"><a href="#5-自增列：AUTO-INCREMENT" class="headerlink" title="5. 自增列：AUTO_INCREMENT"></a><strong>5.</strong> <strong>自增列：AUTO_INCREMENT</strong></h4><h5 id="5-1-作用"><a href="#5-1-作用" class="headerlink" title="5.1 作用"></a><strong>5.1</strong> <strong>作用</strong></h5><p>某个字段的值自增</p>
<h5 id="5-2-关键字"><a href="#5-2-关键字" class="headerlink" title="5.2 关键字"></a><strong>5.2</strong> <strong>关键字</strong></h5><p>auto_increment </p>
<h5 id="5-3-特点和要求"><a href="#5-3-特点和要求" class="headerlink" title="5.3 特点和要求"></a><strong>5.3</strong> <strong>特点和要求</strong></h5><p>（1）一个表最多只能有一个自增长列</p>
<p>（2）当需要产生唯一标识符或顺序值时，可设置自增长</p>
<p>（3）自增长列约束的列必须是键列（主键列，唯一键列）</p>
<p>（4）自增约束的列的数据类型必须是整数类型</p>
<p>（5）如果自增列指定了 0 和 null，会在当前最大值的基础上自增；如果自增列手动指定了具体值，直接赋值为具体值。</p>
<h5 id="5-4-如何指定自增约束"><a href="#5-4-如何指定自增约束" class="headerlink" title="5.4 如何指定自增约束"></a><strong>5.4</strong> <strong>如何指定自增约束</strong></h5><p><strong>（1）建表时</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create table 表名称( </span><br><span class="line">    字段名 数据类型 primary key auto_increment, </span><br><span class="line">    字段名 数据类型 unique key not null, </span><br><span class="line">    字段名 数据类型 unique key, </span><br><span class="line">    字段名 数据类型 not null default 默认值</span><br><span class="line">);</span><br><span class="line">create table 表名称( </span><br><span class="line">    字段名 数据类型 default 默认值, </span><br><span class="line">    字段名 数据类型 unique key auto_increment, </span><br><span class="line">    字段名 数据类型 not null default 默认值, </span><br><span class="line">    primary key(字段名) </span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p><strong>（2）建表后</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">alter table 表名称 modify 字段名 数据类型 auto_increment;</span><br></pre></td></tr></table></figure>

<h5 id="5-5-如何删除自增约束"><a href="#5-5-如何删除自增约束" class="headerlink" title="5.5 如何删除自增约束"></a><strong>5.5</strong> <strong>如何删除自增约束</strong></h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#alter table 表名称 modify 字段名 数据类型 auto_increment;#给这个字段增加自增约束 </span><br><span class="line">alter table 表名称 modify 字段名 数据类型; #去掉auto_increment相当于删除</span><br></pre></td></tr></table></figure>

<h5 id="5-6-MySQL-8-0新特性—自增变量的持久化"><a href="#5-6-MySQL-8-0新特性—自增变量的持久化" class="headerlink" title="5.6 MySQL 8.0新特性—自增变量的持久化"></a><strong>5.6 MySQL 8.0新特性—自增变量的持久化</strong></h5><p>在MySQL 8.0之前，自增主键AUTO_INCREMENT的值如果大于max(primary key)+1，在MySQL重启后，会重置AUTO_INCREMENT=max(primary key)+1，这种现象在某些情况下会导致业务主键冲突或者其他难以发现的问题。</p>
<p>在MySQL 5.7系统中，对于自增主键的分配规则，是由InnoDB数据字典内部一个<code>计数器</code>来决定的，而该计数器只在<code>内存中维护</code>，并不会持久化到磁盘中。当数据库重启时，该计数器会被初始化。</p>
<p>MySQL 8.0将自增主键的计数器持久化到<code>重做日志</code>中。每次计数器发生改变，都会将其写入重做日志中。如果数据库重启，InnoDB会根据重做日志中的信息来初始化计数器的内存值。</p>
<h4 id="6-FOREIGN-KEY-约束"><a href="#6-FOREIGN-KEY-约束" class="headerlink" title="6. FOREIGN KEY 约束"></a><strong>6. FOREIGN KEY</strong> <strong>约束</strong></h4><h5 id="6-1-作用"><a href="#6-1-作用" class="headerlink" title="6.1 作用"></a><strong>6.1</strong> <strong>作用</strong></h5><p>限定某个表的某个字段的引用完整性。</p>
<h5 id="6-2-关键字"><a href="#6-2-关键字" class="headerlink" title="6.2 关键字"></a><strong>6.2</strong> <strong>关键字</strong></h5><p>FOREIGN KEY </p>
<h5 id="6-3-主表和从表-父表和子表"><a href="#6-3-主表和从表-父表和子表" class="headerlink" title="6.3 主表和从表/父表和子表"></a><strong>6.3</strong> <strong>主表和从表/父表和子表</strong></h5><p>主表（父表）：被引用的表，被参考的表</p>
<p>从表（子表）：引用别人的表，参考别人的表</p>
<h5 id="6-4-特点"><a href="#6-4-特点" class="headerlink" title="6.4 特点"></a><strong>6.4</strong> <strong>特点</strong></h5><p>（1）从表的外键列，必须引用/参考主表的主键或唯一约束的列</p>
<p>为什么？因为被依赖/被参考的值必须是唯一的</p>
<p>（2）在创建外键约束时，如果不给外键约束命名，<strong>默认名不是列名，而是自动产生一个外键名</strong>（例如student_ibfk_1;），也可以指定外键约束名。</p>
<p>（3）创建(CREATE)表时就指定外键约束的话，先创建主表，再创建从表</p>
<p>（4）删表时，先删从表（或先删除外键约束），再删除主表</p>
<p>（5）当主表的记录被从表参照时，主表的记录将不允许删除，如果要删除数据，需要先删除从表中依赖该记录的数据，然后才可以删除主表的数据</p>
<p>（6）在“从表”中指定外键约束，并且一个表可以建立多个外键约束</p>
<p>（7）从表的外键列与主表被参照的列名字可以不相同，但是数据类型必须一样，逻辑意义一致。如果类型不一样，创建子表时，就会出现错误“ERROR 1005 (HY000): Can’t create table’database.tablename’(errno: 150)”。</p>
<p>（8）<strong>当创建外键约束时，系统默认会在所在的列上建立对应的普通索引</strong>。但是索引名是外键的约束名。（根据外键查询效率很高）</p>
<p>（9）删除外键约束后，必须<code>手动</code>删除对应的索引</p>
<h5 id="6-5-添加外键约束"><a href="#6-5-添加外键约束" class="headerlink" title="6.5 添加外键约束"></a><strong>6.5</strong> <strong>添加外键约束</strong></h5><p>（1）建表时</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create table 主表名称( </span><br><span class="line">    字段1 数据类型 primary key, </span><br><span class="line">    字段2 数据类型 </span><br><span class="line">);</span><br><span class="line">create table 从表名称( </span><br><span class="line">    字段1 数据类型 primary key, </span><br><span class="line">    字段2 数据类型, </span><br><span class="line">    [CONSTRAINT &lt;外键约束名称&gt;] FOREIGN KEY（从表的某个字段) references 主表名(被参考字段) </span><br><span class="line">);</span><br><span class="line">#(从表的某个字段)的数据类型必须与主表名(被参考字段)的数据类型一致，逻辑意义也一样</span><br><span class="line">#(从表的某个字段)的字段名可以与主表名(被参考字段)的字段名一样，也可以不一样</span><br><span class="line">-- FOREIGN KEY: 在表级指定子表中的列</span><br><span class="line">-- REFERENCES: 标示在父表中的列</span><br></pre></td></tr></table></figure>

<p>（2）建表后</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ALTER TABLE 从表名 </span><br><span class="line">ADD [CONSTRAINT 约束名] FOREIGN KEY (从表的字段) REFERENCES 主表名(被引用 字段) [on update xx][on delete xx];</span><br></pre></td></tr></table></figure>

<p>总结：约束关系是针对双方的</p>
<ul>
<li>添加了外键约束后，主表的修改和删除数据受约束</li>
<li>添加了外键约束后，从表的添加和修改数据受约束</li>
<li>在从表上建立外键，要求主表必须存在</li>
<li>删除主表时，要求从表先删除，或将从表中外键引用该主表的关系先删除</li>
</ul>
<h5 id="6-6-约束等级"><a href="#6-6-约束等级" class="headerlink" title="6.6 约束等级"></a><strong>6.6</strong> <strong>约束等级</strong></h5><ul>
<li><code>Cascade方式</code>：在父表上update/delete记录时，同步update/delete掉子表的匹配记录</li>
<li><code>Set null方式</code>：在父表上update/delete记录时，将子表上匹配记录的列设为null，但是要注意子表的外键列不能为not null </li>
<li><code>No action方式</code>：如果子表中有匹配的记录，则不允许对父表对应候选键进行update/delete操作</li>
<li><code>Restrict方式</code>：同no action， 都是立即检查外键约束</li>
<li><code>Set default方式</code>（在可视化工具SQLyog中可能显示空白）：父表有变更时，子表将外键列设置成一个默认的值，但Innodb不能识别</li>
</ul>
<p>如果没有指定等级，就相当于Restrict方式。</p>
<p>对于外键约束，最好是采用:<code>ON UPDATE CASCADE ON DELETE RESTRICT</code>的方式。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create table emp( </span><br><span class="line">    eid int primary key, #员工编号 </span><br><span class="line">    ename varchar(5), #员工姓名 </span><br><span class="line">    deptid int, #员工所在的部门</span><br><span class="line">    foreign key (deptid) references dept(did) ON UPDATE CASCADE ON DELETE RESTRICT #把修改操作设置为级联修改等级，把删除操作设置为Restrict等级 </span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h5 id="6-7-删除外键约束"><a href="#6-7-删除外键约束" class="headerlink" title="6.7 删除外键约束"></a><strong>6.7</strong> <strong>删除外键约束</strong></h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># (1)第一步先查看约束名和删除外键约束 </span><br><span class="line">SELECT * FROM information_schema.table_constraints WHERE table_name &#x3D; &#39;表名称&#39;;#查看某个表的约束名 </span><br><span class="line">ALTER TABLE 从表名 DROP FOREIGN KEY 外键约束名; </span><br><span class="line">#（2）第二步查看索引名和删除索引。（注意，只能手动删除） </span><br><span class="line">SHOW INDEX FROM 表名称; #查看某个表的索引名 </span><br><span class="line">ALTER TABLE 从表名 DROP INDEX 索引名;</span><br></pre></td></tr></table></figure>

<h5 id="6-8-开发场景"><a href="#6-8-开发场景" class="headerlink" title="6.8 开发场景"></a><strong>6.8</strong> <strong>开发场景</strong></h5><p><strong>问题1：如果两个表之间有关系（一对一、一对多），比如：员工表和部门表（一对多），它们之间是否一定要建外键约束？</strong></p>
<p>答：不是的</p>
<p><strong>问题2：建和不建外键约束有什么区别？</strong></p>
<p>答：建外键约束，你的操作（创建表、删除表、添加、修改、删除）会受到限制，从语法层面受到限制。例如：在员工表中不可能添加一个员工信息，它的部门的值在部门表中找不到。</p>
<p>不建外键约束，你的操作（创建表、删除表、添加、修改、删除）不受限制，要保证数据的<code>引用完整性</code>，只能依<code>靠程序员的自觉</code>，或者是<code>在Java程序中进行限定</code>。例如：在员工表中，可以添加一个员工的信息，它的部门指定为一个完全不存在的部门。</p>
<p><strong>问题3：那么建和不建外键约束和查询有没有关系？</strong></p>
<p>答：没有</p>
<blockquote>
<p>在 MySQL 里，外键约束是有成本的，需要消耗系统资源。对于大并发的 SQL 操作，有可能会不适合。比如大型网站的中央数据库，可能会<code>因为外键约束的系统开销而变得非常慢</code>。所以， MySQL 允许你不使用系统自带的外键约束，在<code>应用层面</code>完成检查数据一致性的逻辑。也就是说，即使你不用外键约束，也要想办法通过应用层面的附加逻辑，来实现外键约束的功能，确保数据的一致性。</p>
</blockquote>
<h5 id="6-9-阿里开发规范"><a href="#6-9-阿里开发规范" class="headerlink" title="6.9 阿里开发规范"></a><strong>6.9</strong> <strong>阿里开发规范</strong></h5><p>【<code>强制</code>】不得使用外键与级联，一切外键概念必须在应用层解决。</p>
<p>说明：（概念解释）学生表中的 student_id 是主键，那么成绩表中的 student_id 则为外键。如果更新学生表中的 student_id，同时触发成绩表中的 student_id 更新，即为级联更新。外键与级联更新适用于<code>单机低并发</code>，不适合<code>分布式</code>、<code>高并发集群</code>；级联更新是强阻塞，存在数据库<code>更新风暴</code>的风险；外键影响数据库的<code>插入速度</code>。</p>
<h4 id="7-CHECK-约束"><a href="#7-CHECK-约束" class="headerlink" title="7. CHECK 约束"></a><strong>7. CHECK</strong> <strong>约束</strong></h4><h5 id="7-1-作用"><a href="#7-1-作用" class="headerlink" title="7.1 作用"></a><strong>7.1</strong> <strong>作用</strong></h5><p>检查某个字段的值是否符号xx要求，一般指的是值的范围</p>
<h5 id="7-2-关键字"><a href="#7-2-关键字" class="headerlink" title="7.2 关键字"></a><strong>7.2 关键字</strong></h5><p>CHECK</p>
<h5 id="7-3-说明：MySQL-5-7-不支持"><a href="#7-3-说明：MySQL-5-7-不支持" class="headerlink" title="7.3 说明：MySQL 5.7 不支持"></a><strong>7.3 说明：MySQL 5.7</strong> <strong>不支持</strong></h5><p>MySQL5.7 可以使用check约束，但check约束对数据验证没有任何作用。添加数据时，没有任何错误或警告</p>
<p>但是<strong>MySQL 8.0中可以使用check约束了</strong>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE temp( </span><br><span class="line">    id INT AUTO_INCREMENT, </span><br><span class="line">    NAME VARCHAR(20), </span><br><span class="line">    age INT CHECK(age &gt; 20), </span><br><span class="line">    gender char CHECK (&#39;男&#39; OR &#39;女&#39;),</span><br><span class="line">    PRIMARY KEY(id) </span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h4 id="8-DEFAULT约束"><a href="#8-DEFAULT约束" class="headerlink" title="8. DEFAULT约束"></a><strong>8. DEFAULT约束</strong></h4><h5 id="8-1-作用"><a href="#8-1-作用" class="headerlink" title="8.1 作用"></a><strong>8.1</strong> <strong>作用</strong></h5><p>给某个字段/某列指定默认值，一旦设置默认值，在插入数据时，如果此字段没有显式赋值，则赋值为默认值。</p>
<h5 id="8-2-关键字"><a href="#8-2-关键字" class="headerlink" title="8.2 关键字"></a><strong>8.2</strong> <strong>关键字</strong></h5><p>DEFAULT</p>
<h5 id="8-3-如何给字段加默认值"><a href="#8-3-如何给字段加默认值" class="headerlink" title="8.3 如何给字段加默认值"></a><strong>8.3</strong> <strong>如何给字段加默认值</strong></h5><p>（1）建表时</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create table 表名称(</span><br><span class="line">    字段名 数据类型 default 默认值 , </span><br><span class="line">    字段名 数据类型 not null default 默认值, </span><br><span class="line">    字段名 数据类型 not null default 默认值, </span><br><span class="line">    primary key(字段名),</span><br><span class="line">    unique key(字段名) </span><br><span class="line">);</span><br><span class="line"># 说明：默认值约束一般不在唯一键和主键列上加</span><br></pre></td></tr></table></figure>

<p>（2）建表后</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">alter table 表名称 </span><br><span class="line">modify 字段名 数据类型 default 默认值; </span><br><span class="line">#如果这个字段原来有非空约束，你还保留非空约束，那么在加默认值约束时，还得保留非空约束，否则非空约束就被删除了 </span><br><span class="line">#同理，在给某个字段加非空约束也一样，如果这个字段原来有默认值约束，你想保留，也要在modify语句中保留默认值约束，否则就删除了 </span><br><span class="line">alter table 表名称 modify 字段名 数据类型 default 默认值 not null;</span><br></pre></td></tr></table></figure>

<h5 id="8-4-如何删除默认值约束"><a href="#8-4-如何删除默认值约束" class="headerlink" title="8.4 如何删除默认值约束"></a><strong>8.4</strong> <strong>如何删除默认值约束</strong></h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">alter table 表名称 modify 字段名 数据类型 ;#删除默认值约束，也不保留非空约束 </span><br><span class="line">alter table 表名称 modify 字段名 数据类型 not null; #删除默认值约束，保留非空约束</span><br></pre></td></tr></table></figure>

<h4 id="9-面试"><a href="#9-面试" class="headerlink" title="9. 面试"></a><strong>9.</strong> <strong>面试</strong></h4><p><strong>面试1、为什么建表时，加 not null default ‘’ 或 default 0</strong></p>
<p>答：不想让表中出现null值。</p>
<p><strong>面试2、为什么不想要</strong> <strong>null</strong> <strong>的值</strong></p>
<p>答:（1）不好比较。null是一种特殊值，比较时只能用专门的is null 和 is not null来比较。碰到运算符，通常返回null。 </p>
<p>（2）效率不高。影响提高索引效果。因此，我们往往在建表时 not null default ‘’ 或 default 0</p>
<p><strong>面试3、带AUTO_INCREMENT约束的字段值是从1开始的吗？</strong> </p>
<p>在MySQL中，默认AUTO_INCREMENT的初始值是1，每新增一条记录，字段值自动加1。设置自增属性（AUTO_INCREMENT）的时候，还可以指定第一条插入记录的自增字段的值，这样新插入的记录的自增字段值从初始值开始递增，如在表中插入第一条记录，同时指定id值为5，则以后插入的记录的id值就会从6开始往上增加。添加主键约束时，往往需要设置字段自动增加属性。</p>
<p><strong>面试4、并不是每个表都可以任意选择存储引擎？</strong> </p>
<p>外键约束（FOREIGN KEY）不能跨引擎使用。</p>
<p>MySQL支持多种存储引擎，每一个表都可以指定一个不同的存储引擎，需要注意的是：外键约束是用来保证数据的参照完整性的，如果表之间需要关联外键，却指定了不同的存储引擎，那么这些表之间是不能创建外键约束的。所以说，存储引擎的选择也不完全是随意的。</p>
<h3 id="第14章-视图"><a href="#第14章-视图" class="headerlink" title="第14章 视图"></a>第14章 视图</h3><h4 id="1-常见的数据库对象"><a href="#1-常见的数据库对象" class="headerlink" title="1. 常见的数据库对象"></a><strong>1.</strong> <strong>常见的数据库对象</strong></h4><table>
<thead>
<tr>
<th>对象</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>表(TABLE)</td>
<td>表是存储数据的逻辑单元，以行和列的形式存在，列就是字段，行就是记录</td>
</tr>
<tr>
<td>数据字典</td>
<td>就是系统表，存放数据库相关信息的表。系统表的数据通常由数据库系统维护，程序员通常不应该修改，只可查看</td>
</tr>
<tr>
<td>约束(CONSTRAINT)</td>
<td>执行数据校验的规则，用于保证数据完整性的规则</td>
</tr>
<tr>
<td>视图(VIEW)</td>
<td>一个或者多个数据表里的数据的逻辑显示，视图并不存储数据</td>
</tr>
<tr>
<td>索引(INDEX)</td>
<td>用于提高查询性能，相当于书的目录</td>
</tr>
<tr>
<td>存储过程(PROCEDURE)</td>
<td>用于完成一次完整的业务处理，没有返回值，但可通过传出参数将多个值传给调用环境</td>
</tr>
<tr>
<td>存储函数(FUNCTION)</td>
<td>用于完成一次特定的计算，具有一个返回值</td>
</tr>
<tr>
<td>触发器(TRIGGER)</td>
<td>相当于一个事件监听器，当数据库发生特定事件后，触发器被触发，完成相应的处理</td>
</tr>
</tbody></table>
<h4 id="2-视图概述"><a href="#2-视图概述" class="headerlink" title="2. 视图概述"></a><strong>2.</strong> <strong>视图概述</strong></h4><h5 id="2-1-为什么使用视图？"><a href="#2-1-为什么使用视图？" class="headerlink" title="2.1 为什么使用视图？"></a><strong>2.1</strong> <strong>为什么使用视图？</strong></h5><p>视图一方面可以帮我们使用表的一部分而不是所有的表，另一方面也可以针对不同的用户制定不同的查询视图。</p>
<h5 id="2-2-视图的理解"><a href="#2-2-视图的理解" class="headerlink" title="2.2 视图的理解"></a><strong>2.2</strong> <strong>视图的理解</strong></h5><ul>
<li>视图是一种<code>虚拟表</code>，本身是<code>不具有数据</code>的，占用很少的内存空间，它是 SQL 中的一个重要概念。</li>
<li><strong>视图建立在已有表的基础上</strong>, 视图赖以建立的这些表称为<strong>基表</strong>。</li>
<li>视图的创建和删除只影响视图本身，不影响对应的基表。但是当对视图中的数据进行增加、删除和修改操作时，数据表中的数据会相应地发生变化，反之亦然。</li>
<li>向视图提供数据内容的语句为 SELECT 语句, 可以将视图理解为<strong>存储起来的</strong> <strong>SELECT</strong> <strong>语句</strong><ul>
<li>在数据库中，视图不会保存数据，数据真正保存在数据表中。当对视图中的数据进行增加、删除和修改操作时，数据表中的数据会相应地发生变化；反之亦然。</li>
</ul>
</li>
<li>视图，是向用户提供基表数据的另一种表现形式。通常情况下，小型项目的数据库可以不使用视图，但是在大型项目中，以及数据表比较复杂的情况下，视图的价值就凸显出来了，它可以帮助我们把经常查询的结果集放到虚拟表中，提升使用效率。理解和使用起来都非常方便。</li>
</ul>
<h4 id="3-创建视图"><a href="#3-创建视图" class="headerlink" title="3. 创建视图"></a><strong>3.</strong> <strong>创建视图</strong></h4><ul>
<li><strong>在</strong> <strong>CREATE VIEW</strong> <strong>语句中嵌入子查询</strong></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE [OR REPLACE] </span><br><span class="line">[ALGORITHM &#x3D; &#123;UNDEFINED | MERGE | TEMPTABLE&#125;] </span><br><span class="line">VIEW 视图名称 [(字段列表)] </span><br><span class="line">AS 查询语句 </span><br><span class="line">[WITH [CASCADED|LOCAL] CHECK OPTION]</span><br></pre></td></tr></table></figure>

<ul>
<li>精简版</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE VIEW 视图名称 </span><br><span class="line">AS 查询语句</span><br></pre></td></tr></table></figure>

<h4 id="4-查看视图"><a href="#4-查看视图" class="headerlink" title="4. 查看视图"></a><strong>4.</strong> <strong>查看视图</strong></h4><p>语法1：查看数据库的表对象、视图对象</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SHOW TABLES;</span><br></pre></td></tr></table></figure>

<p>语法2：查看视图的结构</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DESC &#x2F; DESCRIBE 视图名称;</span><br></pre></td></tr></table></figure>

<p>语法3：查看视图的属性信息</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 查看视图信息（显示数据表的存储引擎、版本、数据行数和数据大小等） </span><br><span class="line">SHOW TABLE STATUS LIKE &#39;视图名称&#39;\G</span><br></pre></td></tr></table></figure>

<p>执行结果显示，注释Comment为VIEW，说明该表为视图，其他的信息为NULL，说明这是一个虚表。</p>
<p>语法4：查看视图的详细定义信息</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SHOW CREATE VIEW 视图名称;</span><br></pre></td></tr></table></figure>

<h4 id="5-更新视图的数据"><a href="#5-更新视图的数据" class="headerlink" title="5. 更新视图的数据"></a><strong>5.</strong> <strong>更新视图的数据</strong></h4><h5 id="5-1-一般情况"><a href="#5-1-一般情况" class="headerlink" title="5.1 一般情况"></a><strong>5.1</strong> <strong>一般情况</strong></h5><p>MySQL支持使用INSERT、UPDATE和DELETE语句对视图中的数据进行插入、更新和删除操作。当视图中的数据发生变化时，数据表中的数据也会发生变化，反之亦然。</p>
<h5 id="5-2-不可更新的视图"><a href="#5-2-不可更新的视图" class="headerlink" title="5.2 不可更新的视图"></a><strong>5.2</strong> <strong>不可更新的视图</strong></h5><p>要使视图可更新，视图中的行和底层基本表中的行之间必须存在<code>一对一</code>的关系。另外当视图定义出现如下情况时，视图不支持更新操作：</p>
<ul>
<li>在定义视图的时候指定了“ALGORITHM = TEMPTABLE”，视图将不支持INSERT和DELETE操作；</li>
<li>视图中不包含基表中所有被定义为非空又未指定默认值的列，视图将不支持INSERT操作；</li>
<li>在定义视图的SELECT语句中使用了<code>JOIN联合查询</code>，视图将不支持INSERT和DELETE操作；</li>
<li>在定义视图的SELECT语句后的字段列表中使用了<code>数学表达式</code>或<code>子查询</code>，视图将不支持INSERT，也不支持UPDATE使用了数学表达式、子查询的字段值；</li>
<li>在定义视图的SELECT语句后的字段列表中使用<code>DISTINCT</code>、<code>聚合函数</code>、<code>GROUP BY</code>、<code>HAVING</code>、<code>UNION</code>等，视图将不支持INSERT、UPDATE、DELETE；</li>
<li>在定义视图的SELECT语句中包含了子查询，而子查询中引用了FROM后面的表，视图将不支持 INSERT、UPDATE、DELETE；</li>
<li>视图定义基于一个<code>不可更新视图</code>；</li>
<li>常量视图</li>
</ul>
<blockquote>
<p>虽然可以更新视图数据，但总的来说，视图作为<code>虚拟表</code>，主要用于<code>方便查询</code>，不建议更新视图的数据。<strong>对视图数据的更改，都是通过对实际数据表里数据的操作来完成的。</strong></p>
</blockquote>
<h4 id="6-修改、删除视图"><a href="#6-修改、删除视图" class="headerlink" title="6. 修改、删除视图"></a><strong>6.</strong> <strong>修改、删除视图</strong></h4><h5 id="6-1-修改视图"><a href="#6-1-修改视图" class="headerlink" title="6.1 修改视图"></a><strong>6.1</strong> <strong>修改视图</strong></h5><p>方式1：使用CREATE <strong>OR REPLACE</strong> VIEW 子句<strong>修改视图</strong></p>
<p>方式2：ALTER VIEW</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ALTER VIEW 视图名称 </span><br><span class="line">AS</span><br><span class="line">查询语句</span><br></pre></td></tr></table></figure>

<h5 id="6-2-删除视图"><a href="#6-2-删除视图" class="headerlink" title="6.2 删除视图"></a><strong>6.2</strong> <strong>删除视图</strong></h5><ul>
<li>删除视图只是删除视图的定义，并不会删除基表的数据。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DROP VIEW IF EXISTS 视图名称;</span><br></pre></td></tr></table></figure>

<h4 id="7-总结"><a href="#7-总结" class="headerlink" title="7. 总结"></a><strong>7.</strong> <strong>总结</strong></h4><h5 id="7-1-视图优点"><a href="#7-1-视图优点" class="headerlink" title="7.1 视图优点"></a><strong>7.1</strong> <strong>视图优点</strong></h5><p><strong>1.</strong> <strong>操作简单</strong></p>
<p>将经常使用的查询操作定义为视图，可以使开发人员不需要关心视图对应的数据表的结构、表与表之间的关联关系，也不需要关心数据表之间的业务逻辑和查询条件，而只需要简单地操作视图即可，极大简化了开发人员对数据库的操作。</p>
<p><strong>2.</strong> <strong>减少数据冗余</strong></p>
<p>视图跟实际数据表不一样，它存储的是查询语句。所以，在使用的时候，我们要通过定义视图的查询语句来获取结果集。而视图本身不存储数据，不占用数据存储的资源，减少了数据冗余。</p>
<p><strong>3.</strong> <strong>数据安全</strong></p>
<p>MySQL将用户对数据的<code>访问限制</code>在某些数据的结果集上，而这些数据的结果集可以使用视图来实现。用户不必直接查询或操作数据表。这也可以理解为视图具有<code>隔离性</code>。视图相当于在用户和实际的数据表之间加了一层虚拟表。</p>
<p>同时，MySQL可以根据权限将用户对数据的访问限制在某些视图上，<strong>用户不需要查询数据表，可以直接通过视图获取数据表中的信息</strong>。这在一定程度上保障了数据表中数据的安全性。</p>
<p><strong>4.</strong> <strong>适应灵活多变的需求</strong> 当业务系统的需求发生变化后，如果需要改动数据表的结构，则工作量相对较大，可以使用视图来减少改动的工作量。这种方式在实际工作中使用得比较多。</p>
<p><strong>5.</strong> <strong>能够分解复杂的查询逻辑</strong> 数据库中如果存在复杂的查询逻辑，则可以将问题进行分解，创建多个视图获取数据，再将创建的多个视图结合起来，完成复杂的查询逻辑。</p>
<h5 id="7-2-视图不足"><a href="#7-2-视图不足" class="headerlink" title="7.2 视图不足"></a><strong>7.2</strong> <strong>视图不足</strong></h5><p>如果我们在实际数据表的基础上创建了视图，那么，<strong>如果实际数据表的结构变更了，我们就需要及时对相关的视图进行相应的维护</strong>。特别是嵌套的视图（就是在视图的基础上创建视图），维护会变得比较复杂， 可读性不好 ，容易变成系统的潜在隐患。因为创建视图的 SQL 查询可能会对字段重命名，也可能包含复杂的逻辑，这些都会增加维护的成本。</p>
<p>实际项目中，如果视图过多，会导致数据库维护成本的问题。</p>
<p>所以，在创建视图的时候，你要结合实际项目需求，综合考虑视图的优点和不足，这样才能正确使用视图，使系统整体达到最优。</p>
<h3 id="第15章-存储过程与函数"><a href="#第15章-存储过程与函数" class="headerlink" title="第15章 存储过程与函数"></a>第15章 存储过程与函数</h3><h4 id="1-存储过程概述"><a href="#1-存储过程概述" class="headerlink" title="1. 存储过程概述"></a><strong>1.</strong> <strong>存储过程概述</strong></h4><h5 id="1-1-理解"><a href="#1-1-理解" class="headerlink" title="1.1 理解"></a><strong>1.1</strong> <strong>理解</strong></h5><p><strong>含义</strong>：存储过程的英文是<code>Stored Procedure</code>。它的思想很简单，就是一组经过<code>预先编译</code>的 SQL 语句的封装。</p>
<p>执行过程：存储过程预先存储在 MySQL 服务器上，需要执行的时候，客户端只需要向服务器端发出调用存储过程的命令，服务器端就可以把预先存储好的这一系列 SQL 语句全部执行。</p>
<h4 id="2-创建存储过程"><a href="#2-创建存储过程" class="headerlink" title="2. 创建存储过程"></a><strong>2.</strong> <strong>创建存储过程</strong></h4><h5 id="2-1-语法分析"><a href="#2-1-语法分析" class="headerlink" title="2.1 语法分析"></a><strong>2.1</strong> <strong>语法分析</strong></h5><p>语法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE PROCEDURE 存储过程名(IN|OUT|INOUT 参数名 参数类型,...) </span><br><span class="line">[characteristics ...] </span><br><span class="line">BEGIN</span><br><span class="line">	存储过程体 </span><br><span class="line">END</span><br></pre></td></tr></table></figure>

<p>说明：</p>
<p>1、参数前面的符号的意思</p>
<ul>
<li><code>IN</code>：当前参数为输入参数，也就是表示入参；<ul>
<li>存储过程只是读取这个参数的值。如果没有定义参数种类，<code>默认就是 IN</code>，表示输入参数。</li>
</ul>
</li>
<li><code>OUT</code>：当前参数为输出参数，也就是表示出参；<ul>
<li>执行完成之后，调用这个存储过程的客户端或者应用程序就可以读取这个参数返回的值了。</li>
</ul>
</li>
<li><code>INOUT</code>：当前参数既可以为输入参数，也可以为输出参数。</li>
</ul>
<p>2、形参类型可以是 MySQL数据库中的任意类型。</p>
<p>3、<code>characteristics</code>表示创建存储过程时指定的对存储过程的约束条件，其取值信息如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">LANGUAGE SQL </span><br><span class="line">| [NOT] DETERMINISTIC </span><br><span class="line">| &#123; CONTAINS SQL | NO SQL | READS SQL DATA | MODIFIES SQL DATA &#125; </span><br><span class="line">| SQL SECURITY &#123; DEFINER | INVOKER &#125; </span><br><span class="line">| COMMENT &#39;string&#39;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>LANGUAGE SQL</code>：说明存储过程执行体是由SQL语句组成的，当前系统支持的语言为SQL。 </p>
</li>
<li><p><code>[NOT] DETERMINISTIC</code>：指明存储过程执行的结果是否确定。DETERMINISTIC表示结果是确定的。每次执行存储过程时，相同的输入会得到相同的输出。NOT DETERMINISTIC表示结果是不确定的，相同的输入可能得到不同的输出。如果没有指定任意一个值，默认为NOT DETERMINISTIC。</p>
</li>
<li><p><code>&#123; CONTAINS SQL | NO SQL | READS SQL DATA | MODIFIES SQL DATA &#125;</code>：指明子程序使用SQL语句的限制。</p>
<ul>
<li>CONTAINS SQL表示当前存储过程的子程序包含SQL语句，但是并不包含读写数据的SQL语句；</li>
<li>NO SQL表示当前存储过程的子程序中不包含任何SQL语句；</li>
<li>READS SQL DATA表示当前存储过程的子程序中包含读数据的SQL语句；</li>
<li>MODIFIES SQL DATA表示当前存储过程的子程序中包含写数据的SQL语句。</li>
<li>默认情况下，系统会指定为CONTAINS SQL。</li>
</ul>
</li>
<li><p><code>SQL SECURITY &#123; DEFINER | INVOKER &#125;</code>：执行当前存储过程的权限，即指明哪些用户能够执行当前存储过程。</p>
<ul>
<li><code>DEFINER</code>表示只有当前存储过程的创建者或者定义者才能执行当前存储过程；</li>
<li><code>INVOKER</code>表示拥有当前存储过程的访问权限的用户能够执行当前存储过程。</li>
</ul>
</li>
<li><p><code>COMMENT &#39;string&#39;</code>：注释信息，可以用来描述存储过程。</p>
</li>
</ul>
<p>4、存储过程体中可以有多条 SQL 语句，如果仅仅一条SQL 语句，则可以省略 BEGIN 和 END</p>
<p>5、需要设置新的结束标记</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DELIMITER 新的结束标记</span><br></pre></td></tr></table></figure>

<h5 id="2-2-代码举例"><a href="#2-2-代码举例" class="headerlink" title="2.2 代码举例"></a><strong>2.2</strong> <strong>代码举例</strong></h5><p>举例1：创建存储过程select_all_data()，查看 emps 表的所有数据</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">DELIMITER $ </span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> select_all_data() </span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">	<span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> emps; </span><br><span class="line"><span class="keyword">END</span> $ </span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure>

<p>举例2：创建存储过程avg_employee_salary()，返回所有员工的平均工资</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DELIMITER &#x2F;&#x2F; </span><br><span class="line">CREATE PROCEDURE avg_employee_salary () </span><br><span class="line">BEGIN</span><br><span class="line">	SELECT AVG(salary) AS avg_salary FROM emps; </span><br><span class="line">END &#x2F;&#x2F; </span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure>

<p>举例3：创建存储过程show_max_salary()，用来查看“emps”表的最高薪资值。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DELIMITER &#x2F;&#x2F; </span><br><span class="line">CREATE PROCEDURE show_max_salary() </span><br><span class="line">    LANGUAGE SQL</span><br><span class="line">    NOT DETERMINISTIC</span><br><span class="line">    CONTAINS SQL </span><br><span class="line">    SQL SECURITY DEFINER </span><br><span class="line">    COMMENT &#39;查看最高薪资&#39; </span><br><span class="line">BEGIN</span><br><span class="line">	SELECT MAX(salary) FROM emps;</span><br><span class="line">END &#x2F;&#x2F; </span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure>

<p>举例4：创建存储过程show_someone_salary2()，查看“emps”表的某个员工的薪资，并用IN参数empname输入员工姓名，用OUT参数empsalary输出员工薪资。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DELIMITER &#x2F;&#x2F; </span><br><span class="line">CREATE PROCEDURE show_someone_salary2(IN empname VARCHAR(20),OUT empsalary DOUBLE) </span><br><span class="line">BEGIN</span><br><span class="line">	SELECT salary INTO empsalary FROM emps WHERE ename &#x3D; empname; </span><br><span class="line">END &#x2F;&#x2F; </span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure>

<p>举例5：创建存储过程show_mgr_name()，查询某个员工领导的姓名，并用INOUT参数“empname”输入员工姓名，输出领导的姓名。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DELIMITER &#x2F;&#x2F; </span><br><span class="line">CREATE PROCEDURE show_mgr_name(INOUT empname VARCHAR(20)) </span><br><span class="line">BEGIN</span><br><span class="line">	SELECT ename INTO empname FROM emps WHERE eid &#x3D; (SELECT MID FROM emps WHERE ename&#x3D;empname); </span><br><span class="line">END &#x2F;&#x2F; </span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure>

<h4 id="3-调用存储过程"><a href="#3-调用存储过程" class="headerlink" title="3. 调用存储过程"></a><strong>3.</strong> <strong>调用存储过程</strong></h4><h5 id="3-1-调用格式"><a href="#3-1-调用格式" class="headerlink" title="3.1 调用格式"></a><strong>3.1</strong> <strong>调用格式</strong></h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CALL 存储过程名(实参列表)</span><br></pre></td></tr></table></figure>

<p><strong>格式：</strong></p>
<p>1、调用in模式的参数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CALL sp1(&#39;值&#39;);</span><br></pre></td></tr></table></figure>

<p>2、调用out模式的参数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SET @name; </span><br><span class="line">CALL sp1(@name); </span><br><span class="line">SELECT @name;</span><br></pre></td></tr></table></figure>

<p>3、调用inout模式的参数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SET @name&#x3D;值; </span><br><span class="line">CALL sp1(@name); </span><br><span class="line">SELECT @name;</span><br></pre></td></tr></table></figure>

<h4 id="4-存储函数的使用"><a href="#4-存储函数的使用" class="headerlink" title="4. 存储函数的使用"></a><strong>4.</strong> <strong>存储函数的使用</strong></h4><h5 id="4-1-语法分析"><a href="#4-1-语法分析" class="headerlink" title="4.1 语法分析"></a><strong>4.1</strong> <strong>语法分析</strong></h5><p>语法格式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE FUNCTION 函数名(参数名 参数类型,...) </span><br><span class="line">RETURNS 返回值类型 </span><br><span class="line">[characteristics ...] </span><br><span class="line">BEGIN</span><br><span class="line">	函数体 #函数体中肯定有 RETURN 语句 </span><br><span class="line">END</span><br></pre></td></tr></table></figure>

<p>说明：</p>
<p>1、参数列表：指定参数为IN、OUT或INOUT只对PROCEDURE是合法的，FUNCTION中总是默认为IN参数。</p>
<p>2、RETURNS type 语句表示函数返回数据的类型；</p>
<p>RETURNS子句只能对FUNCTION做指定，对函数而言这是<code>强制</code>的。它用来指定函数的返回类型，而且函数体必须包含一个<code>RETURN value</code>语句。</p>
<p>3、characteristic 创建函数时指定的对函数的约束。取值与创建存储过程时相同，这里不再赘述。</p>
<p>4、函数体也可以用BEGIN…END来表示SQL代码的开始和结束。如果函数体只有一条语句，也可以省略BEGIN…END。</p>
<h5 id="4-2-调用存储函数"><a href="#4-2-调用存储函数" class="headerlink" title="4.2 调用存储函数"></a><strong>4.2</strong> <strong>调用存储函数</strong></h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT 函数名(实参列表)</span><br></pre></td></tr></table></figure>

<h5 id="4-3-代码举例"><a href="#4-3-代码举例" class="headerlink" title="4.3 代码举例"></a><strong>4.3</strong> <strong>代码举例</strong></h5><p>创建存储函数count_by_id()，参数传入dept_id，该函数查询dept_id部门的员工人数，并返回，数据类型为整型。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DELIMITER &#x2F;&#x2F; </span><br><span class="line">CREATE FUNCTION count_by_id(dept_id INT) </span><br><span class="line">RETURNS INT </span><br><span class="line">	LANGUAGE SQL </span><br><span class="line">	NOT DETERMINISTIC </span><br><span class="line">	READS SQL DATA </span><br><span class="line">	SQL SECURITY DEFINER </span><br><span class="line">	COMMENT &#39;查询部门平均工资&#39; </span><br><span class="line">BEGIN</span><br><span class="line">	RETURN (SELECT COUNT(*) FROM employees WHERE department_id &#x3D; dept_id); </span><br><span class="line">END &#x2F;&#x2F; </span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure>

<p>调用：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SET @dept_id &#x3D; 50; </span><br><span class="line">SELECT count_by_id(@dept_id);</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong></p>
<p>若在创建存储函数中报错“<code>you might want to use the less safe log_bin_trust_function_creators variable</code>”，有两种处理方法：</p>
<ul>
<li>方式1：加上必要的函数特性“[NOT] DETERMINISTIC”和“{CONTAINS SQL | NO SQL | READS SQL DATA | MODIFIES SQL DATA}”</li>
<li>方式2：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; SET GLOBAL log_bin_trust_function_creators &#x3D; 1;</span><br></pre></td></tr></table></figure>

<h5 id="4-4-对比存储函数和存储过程"><a href="#4-4-对比存储函数和存储过程" class="headerlink" title="4.4 对比存储函数和存储过程"></a><strong>4.4</strong> <strong>对比存储函数和存储过程</strong></h5><table>
<thead>
<tr>
<th></th>
<th>关键字</th>
<th>调用语法</th>
<th>返回值</th>
<th>应用场景</th>
</tr>
</thead>
<tbody><tr>
<td>存储过程</td>
<td>PROCEDURE</td>
<td>CALL 存储过程()</td>
<td>理解为有0个或多个</td>
<td>一般用于更新</td>
</tr>
<tr>
<td>存储函数</td>
<td>FUNCTION</td>
<td>SELECT 函数()</td>
<td>只能是一个</td>
<td>一般用于查询结果为一个值并返回时</td>
</tr>
</tbody></table>
<p>此外，<strong>存储函数可以放在查询语句中使用，存储过程不行</strong>。反之，存储过程的功能更加强大，包括能够执行对表的操作（比如创建表，删除表等）和事务操作，这些功能是存储函数不具备的。</p>
<h4 id="5-存储过程和函数的查看、修改、删除"><a href="#5-存储过程和函数的查看、修改、删除" class="headerlink" title="5. 存储过程和函数的查看、修改、删除"></a><strong>5.</strong> <strong>存储过程和函数的查看、修改、删除</strong></h4><h5 id="5-1-查看"><a href="#5-1-查看" class="headerlink" title="5.1 查看"></a><strong>5.1</strong> <strong>查看</strong></h5><p><strong>1.</strong> <strong>使用SHOW CREATE语句查看存储过程和函数的创建信息</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SHOW CREATE &#123;PROCEDURE | FUNCTION&#125; 存储过程名或函数名</span><br></pre></td></tr></table></figure>

<p><strong>2.</strong> <strong>使用SHOW STATUS语句查看存储过程和函数的状态信息</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SHOW &#123;PROCEDURE | FUNCTION&#125; STATUS [LIKE &#39;pattern&#39;]</span><br></pre></td></tr></table></figure>

<p><strong>3.</strong> <strong>从information_schema.Routines表中查看存储过程和函数的信息</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT * FROM information_schema.Routines </span><br><span class="line">WHERE ROUTINE_NAME&#x3D;&#39;存储过程或函数的名&#39; [AND ROUTINE_TYPE &#x3D; &#123;&#39;PROCEDURE|FUNCTION&#39;&#125;];</span><br></pre></td></tr></table></figure>

<h5 id="5-2-修改"><a href="#5-2-修改" class="headerlink" title="5.2 修改"></a><strong>5.2</strong> <strong>修改</strong></h5><p>修改存储过程或函数，不影响存储过程或函数功能，只是修改相关特性。使用ALTER语句实现。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ALTER &#123;PROCEDURE | FUNCTION&#125; 存储过程或函数的名 [characteristic ...];</span><br></pre></td></tr></table></figure>

<p>其中，characteristic指定存储过程或函数的特性，其取值信息与创建存储过程、函数时的取值信息略有不同。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123; CONTAINS SQL | NO SQL | READS SQL DATA | MODIFIES SQL DATA &#125; </span><br><span class="line">| SQL SECURITY &#123; DEFINER | INVOKER &#125; </span><br><span class="line">| COMMENT &#39;string&#39;</span><br></pre></td></tr></table></figure>

<h5 id="5-3-删除"><a href="#5-3-删除" class="headerlink" title="5.3 删除"></a><strong>5.3</strong> <strong>删除</strong></h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DROP &#123;PROCEDURE | FUNCTION&#125; [IF EXISTS] 存储过程或函数的名;</span><br></pre></td></tr></table></figure>

<h4 id="6-关于存储过程使用的争议"><a href="#6-关于存储过程使用的争议" class="headerlink" title="6. 关于存储过程使用的争议"></a><strong>6.</strong> <strong>关于存储过程使用的争议</strong></h4><h5 id="6-1-优点"><a href="#6-1-优点" class="headerlink" title="6.1 优点"></a><strong>6.1</strong> <strong>优点</strong></h5><p><strong>1、存储过程可以一次编译多次使用。</strong>存储过程只在创建时进行编译，之后的使用都不需要重新编译，这就提升了 SQL 的执行效率。</p>
<p><strong>2、可以减少开发工作量。</strong>将代码<code>封装</code>成模块，实际上是编程的核心思想之一，这样可以把复杂的问题拆解成不同的模块，然后模块之间可以<code>重复使用</code>，在减少开发工作量的同时，还能保证代码的结构清晰。</p>
<p><strong>3、存储过程的安全性强。</strong>我们在设定存储过程的时候可以<code>设置对用户的使用权限</code>，这样就和视图一样具有较强的安全性。</p>
<p><strong>4、可以减少网络传输量。</strong>因为代码封装到存储过程中，每次使用只需要调用存储过程即可，这样就减少了网络传输量。</p>
<p><strong>5、良好的封装性。</strong>在进行相对复杂的数据库操作时，原本需要使用一条一条的 SQL 语句，可能要连接多次数据库才能完成的操作，现在变成了一次存储过程，只需要<code>连接一次即可</code>。 </p>
<h5 id="6-2-缺点"><a href="#6-2-缺点" class="headerlink" title="6.2 缺点"></a><strong>6.2</strong> <strong>缺点</strong></h5><blockquote>
<p><strong>阿里开发规范</strong></p>
<p>【强制】禁止使用存储过程，存储过程难以调试和扩展，更没有移植性。</p>
</blockquote>
<p><strong>1、可移植性差。</strong>存储过程不能跨数据库移植，比如在 MySQL、Oracle 和 SQL Server 里编写的存储过程，在换成其他数据库时都需要重新编写。</p>
<p><strong>2、调试困难。</strong>只有少数 DBMS 支持存储过程的调试。对于复杂的存储过程来说，开发和维护都不容易。虽然也有一些第三方工具可以对存储过程进行调试，但要收费。</p>
<p><strong>3、存储过程的版本管理很困难。</strong>比如数据表索引发生变化了，可能会导致存储过程失效。我们在开发软件的时候往往需要进行版本管理，但是存储过程本身没有版本控制，版本迭代更新的时候很麻烦。</p>
<p><strong>4、它不适合高并发的场景。</strong>高并发的场景需要减少数据库的压力，有时数据库会采用分库分表的方式，而且对可扩展性要求很高，在这种情况下，存储过程会变得难以维护， 增加数据库的压力 ，显然就不适用了。</p>
<p>小结：</p>
<p>存储过程既方便，又有局限性。尽管不同的公司对存储过程的态度不一，但是对于我们开发人员来说，不论怎样，掌握存储过程都是必备的技能之一。</p>
<h3 id="第16章-变量、流程控制与游标"><a href="#第16章-变量、流程控制与游标" class="headerlink" title="第16章 变量、流程控制与游标"></a>第16章 变量、流程控制与游标</h3><h4 id="1-变量"><a href="#1-变量" class="headerlink" title="1. 变量"></a><strong>1.</strong> <strong>变量</strong></h4><h5 id="1-1-系统变量"><a href="#1-1-系统变量" class="headerlink" title="1.1 系统变量"></a><strong>1.1</strong> <strong>系统变量</strong></h5><h6 id="1-1-1-系统变量分类"><a href="#1-1-1-系统变量分类" class="headerlink" title="1.1.1 系统变量分类"></a><strong>1.1.1</strong> <strong>系统变量分类</strong></h6><p>系统变量分为全局系统变量（需要添加<code>global</code>关键字）以及会话系统变量（需要添加<code>session</code>关键字），有时也把全局系统变量简称为全局变量，有时也把会话系统变量称为local变量。<strong>如果不写，默认会话级别。</strong>静态变量（在 MySQL 服务实例运行期间它们的值不能使用 set 动态修改）属于特殊的全局系统变量。</p>
<ul>
<li><p>全局系统变量针对于所有会话（连接）有效，但<code>不能跨重启</code></p>
</li>
<li><p>会话系统变量仅针对于当前会话（连接）有效。会话期间，当前会话对某个会话系统变量值的修改，不会影响其他会话同一个会话系统变量的值。</p>
</li>
<li><p>会话1对某个全局系统变量值的修改会导致会话2中同一个全局系统变量值的修改。</p>
</li>
</ul>
<h6 id="1-1-2-查看系统变量"><a href="#1-1-2-查看系统变量" class="headerlink" title="1.1.2 查看系统变量"></a><strong>1.1.2</strong> <strong>查看系统变量</strong></h6><ul>
<li><strong>查看所有或部分系统变量</strong></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#查看所有全局变量 </span><br><span class="line">SHOW GLOBAL VARIABLES; </span><br><span class="line">#查看所有会话变量 </span><br><span class="line">SHOW SESSION VARIABLES; </span><br><span class="line">#或</span><br><span class="line">SHOW VARIABLES;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#查看满足条件的部分系统变量。 </span><br><span class="line">SHOW GLOBAL VARIABLES LIKE &#39;%标识符%&#39;;</span><br><span class="line">#查看满足条件的部分会话变量 </span><br><span class="line">SHOW SESSION VARIABLES LIKE &#39;%标识符%&#39;;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>查看指定系统变量</strong></li>
</ul>
<p>作为 MySQL 编码规范，MySQL 中的系统变量以<code>两个“@”</code>开头，其中“@@global”仅用于标记全局系统变量，“@@session”仅用于标记会话系统变量。“@@”首先标记会话系统变量，如果会话系统变量不存在，则标记全局系统变量。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#查看指定的系统变量的值 </span><br><span class="line">SELECT @@global.变量名; </span><br><span class="line">#查看指定的会话变量的值 </span><br><span class="line">SELECT @@session.变量名; </span><br><span class="line">#或者 </span><br><span class="line">SELECT @@变量名;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>修改系统变量的值</strong></li>
</ul>
<p>方式1：修改MySQL 配置文件 ，继而修改MySQL系统变量的值（该方法需要重启MySQL服务）</p>
<p>方式2：在MySQL服务运行期间，使用“set”命令重新设置系统变量的值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#为某个系统变量赋值 </span><br><span class="line">#方式1： </span><br><span class="line">SET @@global.变量名&#x3D;变量值; </span><br><span class="line">#方式2： </span><br><span class="line">SET GLOBAL 变量名&#x3D;变量值;</span><br><span class="line">#为某个会话变量赋值 </span><br><span class="line">#方式1： </span><br><span class="line">SET @@session.变量名&#x3D;变量值; </span><br><span class="line">#方式2： </span><br><span class="line">SET SESSION 变量名&#x3D;变量值;</span><br></pre></td></tr></table></figure>

<h5 id="1-2-用户变量"><a href="#1-2-用户变量" class="headerlink" title="1.2 用户变量"></a><strong>1.2</strong> <strong>用户变量</strong></h5><h6 id="1-2-1-用户变量分类"><a href="#1-2-1-用户变量分类" class="headerlink" title="1.2.1 用户变量分类"></a><strong>1.2.1</strong> <strong>用户变量分类</strong></h6><p>用户变量是用户自己定义的，作为 MySQL 编码规范，MySQL 中的用户变量以<code>一个“@”</code>开头。根据作用范围不同，又分为<code>会话用户变量</code>和<code>局部变量</code>。</p>
<ul>
<li>会话用户变量：作用域和会话变量一样，只对<code>当前连接</code>会话有效。</li>
<li>局部变量：只在 BEGIN 和 END 语句块中有效。局部变量只能在<code>存储过程和函数</code>中使用。</li>
</ul>
<h6 id="1-2-2-会话用户变量"><a href="#1-2-2-会话用户变量" class="headerlink" title="1.2.2 会话用户变量"></a><strong>1.2.2</strong> <strong>会话用户变量</strong></h6><ul>
<li>变量的定义</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#方式1：“&#x3D;”或“:&#x3D;” </span><br><span class="line">SET @用户变量 &#x3D; 值; </span><br><span class="line">SET @用户变量 :&#x3D; 值; </span><br><span class="line">#方式2：“:&#x3D;” 或 INTO关键字 </span><br><span class="line">SELECT @用户变量 :&#x3D; 表达式 [FROM 等子句]; </span><br><span class="line">SELECT 表达式 INTO @用户变量 [FROM 等子句];</span><br></pre></td></tr></table></figure>

<ul>
<li>查看用户变量的值 （查看、比较、运算等）</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT @用户变量</span><br></pre></td></tr></table></figure>

<h6 id="1-2-3-局部变量"><a href="#1-2-3-局部变量" class="headerlink" title="1.2.3 局部变量"></a><strong>1.2.3</strong> <strong>局部变量</strong></h6><p>定义：可以使用<code>DECLARE</code>语句定义一个局部变量</p>
<p>作用域：仅仅在定义它的 BEGIN … END 中有效</p>
<p>位置：只能放在 BEGIN … END 中，而且只能放在第一句</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">BEGIN</span><br><span class="line">	#声明局部变量 </span><br><span class="line">	DECLARE 变量名1 变量数据类型 [DEFAULT 变量默认值]; </span><br><span class="line">	DECLARE 变量名2,变量名3,... 变量数据类型 [DEFAULT 变量默认值];</span><br><span class="line">    #为局部变量赋值 </span><br><span class="line">    SET 变量名1 &#x3D; 值; </span><br><span class="line">    SELECT 值 INTO 变量名2 [FROM 子句]; </span><br><span class="line">    #查看局部变量的值 </span><br><span class="line">    SELECT 变量1,变量2,变量3; </span><br><span class="line">END</span><br></pre></td></tr></table></figure>

<p><strong>1.定义变量</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DECLARE 变量名 类型 [default 值]; # 如果没有DEFAULT子句，初始值为NULL</span><br></pre></td></tr></table></figure>

<p><strong>2.变量赋值</strong></p>
<p>方式1：一般用于赋简单的值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SET 变量名&#x3D;值; </span><br><span class="line">SET 变量名:&#x3D;值;</span><br></pre></td></tr></table></figure>

<p>方式2：一般用于赋表中的字段值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT 字段名或表达式 INTO 变量名 FROM 表;</span><br></pre></td></tr></table></figure>

<p><strong>3.使用变量</strong>（查看、比较、运算等）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT 局部变量名;</span><br></pre></td></tr></table></figure>

<h6 id="1-2-4-对比会话用户变量与局部变量"><a href="#1-2-4-对比会话用户变量与局部变量" class="headerlink" title="1.2.4 对比会话用户变量与局部变量"></a><strong>1.2.4</strong> <strong>对比会话用户变量与局部变量</strong></h6><table>
<thead>
<tr>
<th></th>
<th>作用域</th>
<th>定义位置</th>
<th>语法</th>
</tr>
</thead>
<tbody><tr>
<td>会话用户变量</td>
<td>当前会话</td>
<td>会话的任何地方</td>
<td>加@符号，不用指定类型</td>
</tr>
<tr>
<td>局部变量</td>
<td>定义它的BEGIN END中</td>
<td>BEGIN END的第一句话</td>
<td>一般不用加@,需要指定类型</td>
</tr>
</tbody></table>
<h4 id="2-定义条件与处理程序"><a href="#2-定义条件与处理程序" class="headerlink" title="2. 定义条件与处理程序"></a><strong>2.</strong> <strong>定义条件与处理程序</strong></h4><p><code>定义条件</code>是事先定义程序执行过程中可能遇到的问题，<code>处理程序</code>定义了在遇到问题时应当采取的处理方式，并且保证存储过程或函数在遇到警告或错误时能继续执行。这样可以增强存储程序处理问题的能力，避免程序异常停止运行。</p>
<p>说明：定义条件和处理程序在存储过程、存储函数中都是支持的。</p>
<p>在存储过程中未定义条件和处理程序，且当存储过程中执行的SQL语句报错时，MySQL数据库会抛出错误，并退出当前SQL逻辑，不再向下继续执行。</p>
<h5 id="2-1-定义条件"><a href="#2-1-定义条件" class="headerlink" title="2.1 定义条件"></a><strong>2.1</strong> <strong>定义条件</strong></h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DECLARE 错误名称 CONDITION FOR 错误码（或错误条件）</span><br></pre></td></tr></table></figure>

<p>错误码的说明：</p>
<ul>
<li><p><code>MySQL_error_code</code>和<code>sqlstate_value</code>都可以表示MySQL的错误。</p>
<ul>
<li>MySQL_error_code是数值类型错误代码。</li>
<li>sqlstate_value是长度为5的字符串类型错误代码。</li>
</ul>
</li>
<li><p>例如，在ERROR 1418 (HY000)中，1418是MySQL_error_code，’HY000’是sqlstate_value。</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#使用MySQL_error_code </span><br><span class="line">DECLARE Field_Not_Be_NULL CONDITION FOR 1048; </span><br><span class="line">#使用sqlstate_value </span><br><span class="line">DECLARE Field_Not_Be_NULL CONDITION FOR SQLSTATE &#39;23000&#39;;</span><br></pre></td></tr></table></figure>

<h5 id="2-2-定义处理程序"><a href="#2-2-定义处理程序" class="headerlink" title="2.2 定义处理程序"></a><strong>2.2</strong> <strong>定义处理程序</strong></h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DECLARE 处理方式 HANDLER FOR 错误类型 处理语句</span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>处理方式</strong>：处理方式有3个取值：CONTINUE、EXIT、UNDO。 </p>
<ul>
<li><code>CONTINUE</code>：表示遇到错误不处理，继续执行。</li>
<li><code>EXIT</code>：表示遇到错误马上退出。</li>
<li><code>UNDO</code>：表示遇到错误后撤回之前的操作。MySQL中暂时不支持这样的操作。</li>
</ul>
</li>
<li><p><strong>错误类型</strong>（即条件）可以有如下取值：</p>
<ul>
<li><code>SQLSTATE &#39;字符串错误码&#39;</code>：表示长度为5的sqlstate_value类型的错误代码； </li>
<li><code>MySQL_error_code</code>：匹配数值类型错误代码；</li>
<li><code>错误名称</code>：表示DECLARE … CONDITION定义的错误条件名称。</li>
<li><code>SQLWARNING</code>：匹配所有以01开头的SQLSTATE错误代码；</li>
<li><code>NOT FOUND</code>：匹配所有以02开头的SQLSTATE错误代码；</li>
<li><code>SQLEXCEPTION</code>：匹配所有没有被SQLWARNING或NOT FOUND捕获的SQLSTATE错误代码；</li>
</ul>
</li>
<li><p><strong>处理语句</strong>：如果出现上述条件之一，则采用对应的处理方式，并执行指定的处理语句。语句可以是像“<code>SET 变量 = 值</code>”这样的简单语句，也可以是使用<code>BEGIN ... END</code>编写的复合语句。</p>
</li>
</ul>
<p>定义处理程序的几种方式，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#方法1：捕获sqlstate_value </span><br><span class="line">DECLARE CONTINUE HANDLER FOR SQLSTATE &#39;42S02&#39; SET @info &#x3D; &#39;NO_SUCH_TABLE&#39;; </span><br><span class="line">#方法2：捕获mysql_error_value </span><br><span class="line">DECLARE CONTINUE HANDLER FOR 1146 SET @info &#x3D; &#39;NO_SUCH_TABLE&#39;; </span><br><span class="line">#方法3：先定义条件，再调用 </span><br><span class="line">DECLARE no_such_table CONDITION FOR 1146;</span><br><span class="line">DECLARE CONTINUE HANDLER FOR NO_SUCH_TABLE SET @info &#x3D; &#39;NO_SUCH_TABLE&#39;; </span><br><span class="line">#方法4：使用SQLWARNING </span><br><span class="line">DECLARE EXIT HANDLER FOR SQLWARNING SET @info &#x3D; &#39;ERROR&#39;; </span><br><span class="line">#方法5：使用NOT FOUND </span><br><span class="line">DECLARE EXIT HANDLER FOR NOT FOUND SET @info &#x3D; &#39;NO_SUCH_TABLE&#39;; </span><br><span class="line">#方法6：使用SQLEXCEPTION </span><br><span class="line">DECLARE EXIT HANDLER FOR SQLEXCEPTION SET @info &#x3D; &#39;ERROR&#39;;</span><br></pre></td></tr></table></figure>

<h4 id="3-流程控制"><a href="#3-流程控制" class="headerlink" title="3. 流程控制"></a><strong>3.</strong> <strong>流程控制</strong></h4><h5 id="3-1-分支结构之-IF"><a href="#3-1-分支结构之-IF" class="headerlink" title="3.1 分支结构之 IF"></a><strong>3.1</strong> <strong>分支结构之</strong> <strong>IF</strong></h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">IF 表达式1 THEN 操作1 </span><br><span class="line">[ELSEIF 表达式2 THEN 操作2]…… </span><br><span class="line">[ELSE 操作N] </span><br><span class="line">END IF</span><br></pre></td></tr></table></figure>

<h5 id="3-2-分支结构之-CASE"><a href="#3-2-分支结构之-CASE" class="headerlink" title="3.2 分支结构之 CASE"></a><strong>3.2</strong> <strong>分支结构之</strong> <strong>CASE</strong></h5><p>CASE 语句的语法结构1：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#情况一：类似于switch </span><br><span class="line">CASE 表达式 </span><br><span class="line">WHEN 值1 THEN 结果1或语句1(如果是语句，需要加分号) </span><br><span class="line">WHEN 值2 THEN 结果2或语句2(如果是语句，需要加分号) </span><br><span class="line">... </span><br><span class="line">ELSE 结果n或语句n(如果是语句，需要加分号) </span><br><span class="line">END [case]（如果是放在begin end中需要加上case，如果放在select后面不需要）</span><br></pre></td></tr></table></figure>

<p>CASE 语句的语法结构2：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#情况二：类似于多重if </span><br><span class="line">CASE </span><br><span class="line">WHEN 条件1 THEN 结果1或语句1(如果是语句，需要加分号) </span><br><span class="line">WHEN 条件2 THEN 结果2或语句2(如果是语句，需要加分号) </span><br><span class="line">... </span><br><span class="line">ELSE 结果n或语句n(如果是语句，需要加分号) </span><br><span class="line">END [case]（如果是放在begin end中需要加上case，如果放在select后面不需要）</span><br></pre></td></tr></table></figure>

<h5 id="3-3-循环结构之LOOP"><a href="#3-3-循环结构之LOOP" class="headerlink" title="3.3 循环结构之LOOP"></a><strong>3.3</strong> <strong>循环结构之LOOP</strong></h5><p>LOOP循环语句用来重复执行某些语句。LOOP内的语句一直重复执行直到循环被退出（使用LEAVE子句），跳出循环过程。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[loop_label:] LOOP </span><br><span class="line">	循环执行的语句 </span><br><span class="line">END LOOP [loop_label]</span><br></pre></td></tr></table></figure>

<h5 id="3-4-循环结构之WHILE"><a href="#3-4-循环结构之WHILE" class="headerlink" title="3.4 循环结构之WHILE"></a><strong>3.4</strong> <strong>循环结构之WHILE</strong></h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[while_label:] WHILE 循环条件 DO </span><br><span class="line">	循环体 </span><br><span class="line">END WHILE [while_label];</span><br></pre></td></tr></table></figure>

<h5 id="3-5-循环结构之REPEAT"><a href="#3-5-循环结构之REPEAT" class="headerlink" title="3.5 循环结构之REPEAT"></a><strong>3.5</strong> <strong>循环结构之REPEAT</strong></h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[repeat_label:] REPEAT </span><br><span class="line">	循环体的语句 </span><br><span class="line">	UNTIL 结束循环的条件表达式 </span><br><span class="line">END REPEAT [repeat_label]</span><br></pre></td></tr></table></figure>

<p><strong>对比三种循环结构：</strong></p>
<p>1、这三种循环都可以省略名称，但如果循环中添加了循环控制语句（LEAVE或ITERATE）则必须添加名称。 2、 LOOP：一般用于实现简单的”死”循环；WHILE：先判断后执行；REPEAT：先执行后判断，无条件至少执行一次。</p>
<h5 id="3-6-跳转语句之LEAVE语句"><a href="#3-6-跳转语句之LEAVE语句" class="headerlink" title="3.6 跳转语句之LEAVE语句"></a><strong>3.6</strong> <strong>跳转语句之LEAVE语句</strong></h5><p>LEAVE语句：可以用在循环语句内，或者以 BEGIN 和 END 包裹起来的程序体内，表示跳出循环或者跳出程序体的操作。如果你有面向过程的编程语言的使用经验，你可以把 LEAVE 理解为 break。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">LEAVE 标记名</span><br></pre></td></tr></table></figure>

<h5 id="3-7-跳转语句之ITERATE语句"><a href="#3-7-跳转语句之ITERATE语句" class="headerlink" title="3.7 跳转语句之ITERATE语句"></a><strong>3.7</strong> <strong>跳转语句之ITERATE语句</strong></h5><p>ITERATE语句：只能用在循环语句（LOOP、REPEAT和WHILE语句）内，表示重新开始循环，将执行顺序转到语句段开头处。如果你有面向过程的编程语言的使用经验，你可以把 ITERATE 理解为 continue，意思为“再次循环”。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ITERATE label</span><br></pre></td></tr></table></figure>

<h4 id="4-游标"><a href="#4-游标" class="headerlink" title="4. 游标"></a><strong>4.</strong> <strong>游标</strong></h4><h5 id="4-1-什么是游标（或光标）"><a href="#4-1-什么是游标（或光标）" class="headerlink" title="4.1 什么是游标（或光标）"></a><strong>4.1</strong> <strong>什么是游标（或光标）</strong></h5><p>游标，提供了一种灵活的操作方式，让我们能够对结果集中的每一条记录进行定位，并对指向的记录中的数据进行操作的数据结构。<strong>游标让</strong> <strong>SQL</strong> <strong>这种面向集合的语言有了面向过程开发的能力。</strong></p>
<h5 id="4-2-使用游标步骤"><a href="#4-2-使用游标步骤" class="headerlink" title="4.2 使用游标步骤"></a><strong>4.2</strong> <strong>使用游标步骤</strong></h5><p>游标必须在声明处理程序之前被声明，并且变量和条件还必须在声明游标或处理程序之前被声明。</p>
<p><strong>第一步，声明游标</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DECLARE cursor_name CURSOR FOR select_statement;</span><br></pre></td></tr></table></figure>

<p><strong>第二步，打开游标</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">OPEN cursor_name</span><br></pre></td></tr></table></figure>

<p><strong>第三步，使用游标（从游标中取得数据）</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">FETCH cursor_name INTO var_name [, var_name] ...</span><br></pre></td></tr></table></figure>

<p>注意：<strong>游标的查询结果集中的字段数，必须跟</strong> <strong>INTO</strong> <strong>后面的变量数一致</strong>，否则，在存储过程执行的时候，MySQL 会提示错误。</p>
<p><strong>第四步，关闭游标</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CLOSE cursor_name</span><br></pre></td></tr></table></figure>

<p>当我们使用完游标后需要关闭掉该游标。因为游标会占用系统资源 ，如果不及时关闭，<strong>游标会一直保持到存储过程结束</strong>，影响系统运行的效率。</p>
<h5 id="4-3-小结"><a href="#4-3-小结" class="headerlink" title="4.3 小结"></a><strong>4.3</strong> <strong>小结</strong></h5><p>游标是 MySQL 的一个重要的功能，为<code>逐条读取</code>结果集中的数据，提供了完美的解决方案。跟在应用层面实现相同的功能相比，游标可以在存储程序中使用，效率高，程序也更加简洁。</p>
<p>但同时也会带来一些性能问题，比如在使用游标的过程中，会对数据行进行<code>加锁</code>，这样在业务并发量大的时候，不仅会影响业务之间的效率，还会<code>消耗系统资源</code>，造成内存不足，这是因为游标是在内存中进行的处理。</p>
<p>建议：养成用完之后就关闭的习惯，这样才能提高系统的整体效率。</p>
<h4 id="补充：MySQL-8-0的新特性—全局变量的持久化"><a href="#补充：MySQL-8-0的新特性—全局变量的持久化" class="headerlink" title="补充：MySQL 8.0的新特性—全局变量的持久化"></a><strong>补充：MySQL 8.0的新特性—全局变量的持久化</strong></h4><p>使用SET GLOBAL语句设置的变量值只会<code>临时生效</code>。<code>数据库重启</code>后，服务器又会从MySQL配置文件中读取变量的默认值。 MySQL 8.0版本新增了<code>SET PERSIST</code>命令。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SET PERSIST global max_connections &#x3D; 1000;</span><br></pre></td></tr></table></figure>

<p>MySQL会将该命令的配置保存到数据目录下的 mysqld-auto.cnf 文件中，下次启动时会读取该文件，用其中的配置来覆盖默认的配置文件。</p>
<h3 id="第17章-触发器"><a href="#第17章-触发器" class="headerlink" title="第17章 触发器"></a>第17章 触发器</h3><h4 id="1-触发器概述"><a href="#1-触发器概述" class="headerlink" title="1. 触发器概述"></a><strong>1.</strong> <strong>触发器概述</strong></h4><p>MySQL从<code>5.0.2</code>版本开始支持触发器。MySQL的触发器和存储过程一样，都是嵌入到MySQL服务器的一段程序。</p>
<p>触发器是由<code>事件来触发</code>某个操作，这些事件包括<code>INSERT</code>、<code>UPDATE</code>、<code>DELETE</code>事件。所谓事件就是指用户的动作或者触发某项行为。如果定义了触发程序，当数据库执行这些语句时候，就相当于事件发生了，就会<code>自动</code>激发触发器执行相应的操作。</p>
<p>当对数据表中的数据执行插入、更新和删除操作，需要自动执行一些数据库逻辑时，可以使用触发器来实现。</p>
<h4 id="2-触发器的创建"><a href="#2-触发器的创建" class="headerlink" title="2. 触发器的创建"></a><strong>2.</strong> <strong>触发器的创建</strong></h4><h5 id="2-1-创建触发器语法"><a href="#2-1-创建触发器语法" class="headerlink" title="2.1 创建触发器语法"></a><strong>2.1</strong> <strong>创建触发器语法</strong></h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TRIGGER 触发器名称 </span><br><span class="line">&#123;BEFORE|AFTER&#125; &#123;INSERT|UPDATE|DELETE&#125; ON 表名 </span><br><span class="line">FOR EACH ROW </span><br><span class="line">触发器执行的语句块;</span><br></pre></td></tr></table></figure>

<p>说明：</p>
<ul>
<li><code>表名</code>：表示触发器监控的对象。</li>
<li><code>BEFORE|AFTER</code>：表示触发的时间。BEFORE 表示在事件之前触发；AFTER 表示在事件之后触发。</li>
<li><code>INSERT|UPDATE|DELETE</code>：表示触发的事件。<ul>
<li>INSERT 表示插入记录时触发；</li>
<li>UPDATE 表示更新记录时触发；</li>
<li>DELETE 表示删除记录时触发。</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DELIMITER &#x2F;&#x2F; </span><br><span class="line">CREATE TRIGGER before_insert </span><br><span class="line">BEFORE INSERT ON test_trigger </span><br><span class="line">FOR EACH ROW </span><br><span class="line">BEGIN</span><br><span class="line">	INSERT INTO test_trigger_log (t_log) </span><br><span class="line">	VALUES(&#39;before_insert&#39;); </span><br><span class="line">END &#x2F;&#x2F; </span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure>

<h4 id="3-查看、删除触发器"><a href="#3-查看、删除触发器" class="headerlink" title="3. 查看、删除触发器"></a><strong>3.</strong> <strong>查看、删除触发器</strong></h4><h5 id="3-1-查看触发器"><a href="#3-1-查看触发器" class="headerlink" title="3.1 查看触发器"></a><strong>3.1</strong> <strong>查看触发器</strong></h5><p>方式1：查看当前数据库的所有触发器的定义</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SHOW TRIGGERS\G</span><br></pre></td></tr></table></figure>

<p>方式2：查看当前数据库中某个触发器的定义</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SHOW CREATE TRIGGER 触发器名</span><br></pre></td></tr></table></figure>

<p>方式3：从系统库information_schema的TRIGGERS表中查询“salary_check_trigger”触发器的信息。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT * FROM information_schema.TRIGGERS;</span><br></pre></td></tr></table></figure>

<h5 id="3-2-删除触发器"><a href="#3-2-删除触发器" class="headerlink" title="3.2 删除触发器"></a><strong>3.2</strong> <strong>删除触发器</strong></h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DROP TRIGGER IF EXISTS 触发器名称;</span><br></pre></td></tr></table></figure>

<h4 id="4-触发器的优缺点"><a href="#4-触发器的优缺点" class="headerlink" title="4. 触发器的优缺点"></a><strong>4.</strong> <strong>触发器的优缺点</strong></h4><h5 id="4-1-优点"><a href="#4-1-优点" class="headerlink" title="4.1 优点"></a><strong>4.1</strong> <strong>优点</strong></h5><p><strong>1、触发器可以确保数据的完整性</strong>。</p>
<p><strong>2、触发器可以帮助我们记录操作日志。</strong></p>
<p><strong>3、触发器还可以用在操作数据前，对数据进行合法性检查。</strong></p>
<h5 id="4-2-缺点"><a href="#4-2-缺点" class="headerlink" title="4.2 缺点"></a><strong>4.2</strong> <strong>缺点</strong></h5><p><strong>1、触发器最大的一个问题就是可读性差。</strong></p>
<p>比如触发器中的数据插入操作多了一个字段，系统提示错误。可是，如果你不了解这个触发器，很可能会认为是更新语句本身的问题，或者是表的结构出了问题。</p>
<p><strong>2、相关数据的变更，可能会导致触发器出错。</strong></p>
<p>特别是数据表结构的变更，都可能会导致触发器出错，进而影响数据操作的正常运行。这些都会由于触发器本身的隐蔽性，影响到应用中错误原因排查的效率。</p>
<h5 id="4-3-注意点"><a href="#4-3-注意点" class="headerlink" title="4.3 注意点"></a><strong>4.3</strong> <strong>注意点</strong></h5><p>注意，如果在子表中定义了外键约束，并且外键指定了ON UPDATE/DELETE CASCADE/SET NULL子句，此时修改父表被引用的键值或删除父表被引用的记录行时，也会引起子表的修改和删除操作，此时基于子表的UPDATE和DELETE语句定义的触发器并不会被激活。</p>
<h3 id="第18章-MySQL8其它新特性"><a href="#第18章-MySQL8其它新特性" class="headerlink" title="第18章 MySQL8其它新特性"></a>第18章 MySQL8其它新特性</h3><h4 id="1-新特性1：窗口函数"><a href="#1-新特性1：窗口函数" class="headerlink" title="1. 新特性1：窗口函数"></a><strong>1.</strong> <strong>新特性1：窗口函数</strong></h4><h5 id="1-1-窗口函数分类"><a href="#1-1-窗口函数分类" class="headerlink" title="1.1 窗口函数分类"></a><strong>1.1</strong> <strong>窗口函数分类</strong></h5><p>MySQL从8.0版本开始支持窗口函数。窗口函数的作用类似于在查询中对数据进行分组，不同的是，分组操作会把分组的结果聚合成一条记录，而窗口函数是将结果置于每一条数据记录中。</p>
<p>窗口函数可以分为<code>静态窗口函数</code>和<code>动态窗口函数</code>。</p>
<ul>
<li><p>静态窗口函数的窗口大小是固定的，不会因为记录的不同而不同；</p>
</li>
<li><p>动态窗口函数的窗口大小会随着记录的不同而变化。</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>函数分类</th>
<th>函数</th>
<th>函数说明</th>
</tr>
</thead>
<tbody><tr>
<td>序号函数</td>
<td>ROW_NUMBER()</td>
<td>顺序排序</td>
</tr>
<tr>
<td></td>
<td>RANK()</td>
<td>并列排序，会跳过重复的序号，比如序号为1、1、3</td>
</tr>
<tr>
<td></td>
<td>DENSE_RANK()</td>
<td>并列排序，不会跳过重复的序号，比如序号为1、1、2</td>
</tr>
<tr>
<td>分布函数</td>
<td>PERCENT_RANK()</td>
<td>等级值百分比</td>
</tr>
<tr>
<td></td>
<td>CUME_DIST()</td>
<td>累积分布值</td>
</tr>
<tr>
<td>前后函数</td>
<td>LAG(expr, n)</td>
<td>返回当前行的前n行的expr的值</td>
</tr>
<tr>
<td></td>
<td>LEAD(expr, n)</td>
<td>返回当前行的后n行的expr的值</td>
</tr>
<tr>
<td>首尾函数</td>
<td>FIRST_VALUE(expr)</td>
<td>返回第一个expr的值</td>
</tr>
<tr>
<td></td>
<td>LAST_VALUE(expr)</td>
<td>返回最后一个expr的值</td>
</tr>
<tr>
<td>其他函数</td>
<td>NTH_VALUE(expr, n)</td>
<td>返回第n个expr的值</td>
</tr>
<tr>
<td></td>
<td>NTILE(n)</td>
<td>将分区中的有序数据分为n个桶，记录桶编号</td>
</tr>
</tbody></table>
<h5 id="1-2-语法结构"><a href="#1-2-语法结构" class="headerlink" title="1.2 语法结构"></a><strong>1.2</strong> <strong>语法结构</strong></h5><p>窗口函数的语法结构是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">函数 OVER（[PARTITION BY 字段名 ORDER BY 字段名 ASC|DESC]）</span><br></pre></td></tr></table></figure>

<p>或者是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">函数 OVER 窗口名 … WINDOW 窗口名 AS （[PARTITION BY 字段名 ORDER BY 字段名 ASC|DESC]）</span><br></pre></td></tr></table></figure>

<ul>
<li>OVER 关键字指定函数窗口的范围。<ul>
<li>如果省略后面括号中的内容，则窗口会包含满足WHERE条件的所有记录，窗口函数会基于所有满足WHERE条件的记录进行计算。</li>
<li>如果OVER关键字后面的括号不为空，则可以使用如下语法设置窗口。</li>
</ul>
</li>
<li>窗口名：为窗口设置一个别名，用来标识窗口。</li>
<li>PARTITION BY子句：指定窗口函数按照哪些字段进行分组。分组后，窗口函数可以在每个分组中分别执行。</li>
<li>ORDER BY子句：指定窗口函数按照哪些字段进行排序。执行排序操作使窗口函数按照排序后的数据记录的顺序进行编号。</li>
<li>FRAME子句：为分区中的某个子集定义规则，可以用来作为滑动窗口使用。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT ROW_NUMBER() OVER(PARTITION BY category_id ORDER BY price DESC) AS row_num, id, category_id, category, NAME, price, stock</span><br><span class="line">FROM goods;</span><br></pre></td></tr></table></figure>

<h5 id="1-3-小-结"><a href="#1-3-小-结" class="headerlink" title="1.3 小 结"></a><strong>1.3</strong> <strong>小 结</strong></h5><p>窗口函数的特点是可以分组，而且可以在分组内排序。另外，窗口函数不会因为分组而减少原表中的行数，这对我们在原表数据的基础上进行统计和排序非常有用。</p>
<h4 id="2-新特性2：公用表表达式"><a href="#2-新特性2：公用表表达式" class="headerlink" title="2. 新特性2：公用表表达式"></a><strong>2.</strong> <strong>新特性2：公用表表达式</strong></h4><p>公用表表达式（或通用表表达式）简称为CTE（Common Table Expressions）。CTE是一个命名的临时结果集，作用范围是当前语句。CTE可以理解成一个可以复用的子查询，当然跟子查询还是有点区别的，CTE可以引用其他CTE，但子查询不能引用其他子查询。所以，可以考虑代替子查询。</p>
<p>依据语法结构和执行方式的不同，公用表表达式分为<code>普通公用表表达式</code>和<code>递归公用表表达式</code>2 种。</p>
<h5 id="2-1-普通公用表表达式"><a href="#2-1-普通公用表表达式" class="headerlink" title="2.1 普通公用表表达式"></a><strong>2.1</strong> <strong>普通公用表表达式</strong></h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">WITH CTE名称 </span><br><span class="line">AS （子查询） </span><br><span class="line">SELECT|DELETE|UPDATE 语句;</span><br></pre></td></tr></table></figure>

<p>举例：查询员工所在的部门的详细信息。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">WITH emp_dept_id</span><br><span class="line">AS (SELECT DISTINCT department_id FROM employees)</span><br><span class="line">SELECT *</span><br><span class="line">FROM departments d JOIN emp_dept_id e</span><br><span class="line">ON d.department_id &#x3D; e.department_id;</span><br></pre></td></tr></table></figure>

<h5 id="2-2-递归公用表表达式"><a href="#2-2-递归公用表表达式" class="headerlink" title="2.2 递归公用表表达式"></a><strong>2.2</strong> <strong>递归公用表表达式</strong></h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">WITH RECURSIVE </span><br><span class="line">CTE名称 AS （子查询） </span><br><span class="line">SELECT|DELETE|UPDATE 语句;</span><br></pre></td></tr></table></figure>

<p><strong>案例：</strong>针对于我们常用的employees表，包含employee_id，last_name和manager_id三个字段。如果a是b的管理者，那么，我们可以把b叫做a的下属，如果同时b又是c的管理者，那么c就是b的下属，是a的下下属。</p>
<ul>
<li><p>用递归公用表表达式中的种子查询，找出初代管理者。字段 n 表示代次，初始值为 1，表示是第一代管理者。</p>
</li>
<li><p>用递归公用表表达式中的递归查询，查出以这个递归公用表表达式中的人为管理者的人，并且代次的值加 1。直到没有人以这个递归公用表表达式中的人为管理者了，递归返回。</p>
</li>
<li><p>在最后的查询中，选出所有代次大于等于 3 的人，他们肯定是第三代及以上代次的下属了，也就是下下属了。这样就得到了我们需要的结果集。</p>
</li>
</ul>
<p><strong>代码实现：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">WITH RECURSIVE cte </span><br><span class="line">AS(SELECT employee_id,last_name,manager_id,1 AS n FROM employees WHERE employee_id &#x3D; 100</span><br><span class="line">-- 种子查询，找到第一代领导 </span><br><span class="line">UNION ALL </span><br><span class="line">SELECT a.employee_id,a.last_name,a.manager_id,n+1 FROM employees AS a JOIN cte </span><br><span class="line">ON (a.manager_id &#x3D; cte.employee_id) -- 递归查询，找出以递归公用表表达式的人为领导的人 </span><br><span class="line">)</span><br><span class="line">SELECT employee_id,last_name FROM cte WHERE n &gt;&#x3D; 3;</span><br></pre></td></tr></table></figure>

<h5 id="2-3-小-结"><a href="#2-3-小-结" class="headerlink" title="2.3 小 结"></a><strong>2.3</strong> <strong>小 结</strong></h5><p>公用表表达式的作用是可以替代子查询，而且可以被多次引用。递归公用表表达式对查询有一个共同根节点的树形结构数据非常高效，可以轻松搞定其他查询方式难以处理的查询。</p>
<h2 id="第二部分-MySQL高级特性篇"><a href="#第二部分-MySQL高级特性篇" class="headerlink" title="第二部分 MySQL高级特性篇"></a>第二部分 MySQL高级特性篇</h2><h3 id="第01章-Linux下MySQL的安装与使用"><a href="#第01章-Linux下MySQL的安装与使用" class="headerlink" title="第01章 Linux下MySQL的安装与使用"></a>第01章 Linux下MySQL的安装与使用</h3><h4 id="1-安装前说明"><a href="#1-安装前说明" class="headerlink" title="1. 安装前说明"></a><strong>1.</strong> <strong>安装前说明</strong></h4><h5 id="1-1-查看是否安装过MySQL"><a href="#1-1-查看是否安装过MySQL" class="headerlink" title="1.1 查看是否安装过MySQL"></a><strong>1.1</strong> <strong>查看是否安装过MySQL</strong></h5><ul>
<li>如果你是用rpm安装, 检查一下RPM PACKAGE：</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rpm -qa | grep -i mysql # -i 忽略大小写</span><br></pre></td></tr></table></figure>

<ul>
<li>检查mysql service：</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl status mysqld.service</span><br></pre></td></tr></table></figure>

<h5 id="1-2-MySQL的卸载"><a href="#1-2-MySQL的卸载" class="headerlink" title="1.2 MySQL的卸载"></a><strong>1.2 MySQL的卸载</strong></h5><p><strong>1.</strong> <strong>关闭</strong> <strong>mysql</strong> <strong>服务</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl stop mysqld.service</span><br></pre></td></tr></table></figure>

<p><strong>2.</strong> <strong>查看当前</strong> <strong>mysql</strong> <strong>安装状况</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rpm -qa | grep -i mysql</span><br><span class="line"><span class="meta">#</span><span class="bash"> 或</span></span><br><span class="line">yum list installed | grep mysql</span><br></pre></td></tr></table></figure>

<p><strong>3.</strong> <strong>卸载上述命令查询出的已安装程序</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum remove mysql-xxx mysql-xxx mysql-xxx mysqk-xxxx</span><br></pre></td></tr></table></figure>

<p>务必卸载干净，反复执行<code>rpm -qa | grep -i mysql</code>确认是否有卸载残留</p>
<p><strong>4.</strong> <strong>删除</strong> <strong>mysql</strong> <strong>相关文件</strong></p>
<ul>
<li>查找相关文件</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">find / -name mysql</span><br></pre></td></tr></table></figure>

<ul>
<li>删除上述命令查找出的相关文件</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rm -rf xxx</span><br></pre></td></tr></table></figure>

<p><strong>5.删除 my.cnf</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rm -rf /etc/my.cnf</span><br></pre></td></tr></table></figure>

<h4 id="2-MySQL的Linux版安装"><a href="#2-MySQL的Linux版安装" class="headerlink" title="2. MySQL的Linux版安装"></a><strong>2. MySQL的Linux版安装</strong></h4><h5 id="2-1-CentOS7下检查MySQL依赖"><a href="#2-1-CentOS7下检查MySQL依赖" class="headerlink" title="2.1 CentOS7下检查MySQL依赖"></a><strong>2.1 CentOS7下检查MySQL依赖</strong></h5><p><strong>1.</strong> <strong>检查/tmp临时目录权限（必不可少）</strong></p>
<p>由于mysql安装过程中，会通过mysql用户在/tmp目录下新建tmp_db文件，所以请给/tmp较大的权限。执行 ：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">chmod -R 777 /tmp</span><br></pre></td></tr></table></figure>

<p><strong>2.</strong> <strong>安装前，检查依赖</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rpm -qa|grep libaio</span><br><span class="line">rpm -qa|grep net-tools</span><br></pre></td></tr></table></figure>

<h5 id="2-2-CentOS7下MySQL安装过程"><a href="#2-2-CentOS7下MySQL安装过程" class="headerlink" title="2.2 CentOS7下MySQL安装过程"></a><strong>2.2 CentOS7下MySQL安装过程</strong></h5><p><strong>1.</strong> <strong>将安装程序拷贝到/opt目录下</strong></p>
<p>在mysql的安装文件目录下执行：（必须按照顺序执行）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rpm -ivh mysql-community-common-8.0.25-1.el7.x86_64.rpm </span><br><span class="line">rpm -ivh mysql-community-client-plugins-8.0.25-1.el7.x86_64.rpm </span><br><span class="line">rpm -ivh mysql-community-libs-8.0.25-1.el7.x86_64.rpm </span><br><span class="line">rpm -ivh mysql-community-client-8.0.25-1.el7.x86_64.rpm </span><br><span class="line">rpm -ivh mysql-community-server-8.0.25-1.el7.x86_64.rpm</span><br></pre></td></tr></table></figure>

<ul>
<li><code>rpm</code>是Redhat Package Manage缩写，通过RPM的管理，用户可以把源代码包装成以rpm为扩展名的文件形式，易于安装。</li>
<li><code>-i</code>, –install 安装软件包</li>
<li><code>-v</code>, –verbose 提供更多的详细信息输出</li>
<li><code>-h</code>, –hash 软件包安装的时候列出哈希标记 (和 -v 一起使用效果更好)，展示进度条</li>
</ul>
<blockquote>
<p>若存在mariadb-libs问题，则执行<strong>yum remove mysql-libs</strong>即可</p>
</blockquote>
<h5 id="2-3-查看MySQL版本"><a href="#2-3-查看MySQL版本" class="headerlink" title="2.3 查看MySQL版本"></a><strong>2.3</strong> <strong>查看MySQL版本</strong></h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mysql --version </span><br><span class="line"><span class="meta">#</span><span class="bash">或</span></span><br><span class="line">mysqladmin --version</span><br></pre></td></tr></table></figure>

<h5 id="2-4-服务的初始化"><a href="#2-4-服务的初始化" class="headerlink" title="2.4 服务的初始化"></a><strong>2.4</strong> <strong>服务的初始化</strong></h5><p>为了保证数据库目录与文件的所有者为 mysql 登录用户，如果你是以 root 身份运行 mysql 服务，需要执行下面的命令初始化：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mysqld --initialize --user=mysql</span><br></pre></td></tr></table></figure>

<p>说明： –initialize 选项默认以“安全”模式来初始化，则会为 root 用户生成一个密码并将<code>该密码标记为过期</code>，登录后你需要设置一个新的密码。生成的<code>临时密码</code>会往日志中记录一份。</p>
<p>查看密码：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat /var/log/mysqld.log</span><br></pre></td></tr></table></figure>

<p>root@localhost: 后面就是初始化的密码</p>
<h5 id="2-5-启动MySQL，查看状态"><a href="#2-5-启动MySQL，查看状态" class="headerlink" title="2.5 启动MySQL，查看状态"></a><strong>2.5</strong> <strong>启动MySQL，查看状态</strong></h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">加不加.service后缀都可以</span> </span><br><span class="line">启动：systemctl start mysqld.service </span><br><span class="line">关闭：systemctl stop mysqld.service </span><br><span class="line">重启：systemctl restart mysqld.service </span><br><span class="line">查看状态：systemctl status mysqld.service</span><br></pre></td></tr></table></figure>

<h5 id="2-6-查看MySQL服务是否自启动"><a href="#2-6-查看MySQL服务是否自启动" class="headerlink" title="2.6 查看MySQL服务是否自启动"></a><strong>2.6</strong> <strong>查看MySQL服务是否自启动</strong></h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl list-unit-files|grep mysqld.service</span><br></pre></td></tr></table></figure>

<ul>
<li>如不是enabled可以运行如下命令设置自启动</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl enable mysqld.service</span><br></pre></td></tr></table></figure>

<ul>
<li>如果希望不进行自启动，运行如下命令设置</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl disable mysqld.service</span><br></pre></td></tr></table></figure>

<h4 id="3-MySQL登录"><a href="#3-MySQL登录" class="headerlink" title="3. MySQL登录"></a><strong>3. MySQL登录</strong></h4><h5 id="3-1-首次登录"><a href="#3-1-首次登录" class="headerlink" title="3.1 首次登录"></a><strong>3.1</strong> <strong>首次登录</strong></h5><p>通过<code>mysql -hlocalhost -P3306 -uroot -p</code>进行登录，在Enter password：录入初始化密码</p>
<h5 id="3-2-修改密码"><a href="#3-2-修改密码" class="headerlink" title="3.2 修改密码"></a><strong>3.2</strong> <strong>修改密码</strong></h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ALTER USER &#39;root&#39;@&#39;localhost&#39; IDENTIFIED BY &#39;new_password&#39;;</span><br></pre></td></tr></table></figure>

<h5 id="3-3-设置远程登录"><a href="#3-3-设置远程登录" class="headerlink" title="3.3 设置远程登录"></a><strong>3.3</strong> <strong>设置远程登录</strong></h5><p><strong>1.</strong> <strong>确认网络</strong> </p>
<p>1.在远程机器上使用ping ip地址<code>保证网络畅通</code></p>
<p>2.在远程机器上使用telnet命令<code>保证端口号开放</code>访问</p>
<p><strong>2.</strong> <strong>关闭防火墙或开放端口</strong></p>
<p><strong>方式一：关闭防火墙</strong></p>
<ul>
<li>CentOS6 ：</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">service iptables stop</span><br></pre></td></tr></table></figure>

<ul>
<li>CentOS7：</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">开启防火墙</span></span><br><span class="line">systemctl start firewalld.service</span><br><span class="line"><span class="meta">#</span><span class="bash">查看防火墙状态</span></span><br><span class="line">systemctl status firewalld.service</span><br><span class="line"><span class="meta">#</span><span class="bash">关闭防火墙</span></span><br><span class="line">systemctl stop firewalld.service</span><br><span class="line"><span class="meta">#</span><span class="bash">设置开机启用防火墙</span> </span><br><span class="line">systemctl enable firewalld.service </span><br><span class="line"><span class="meta">#</span><span class="bash">设置开机禁用防火墙</span> </span><br><span class="line">systemctl disable firewalld.service</span><br></pre></td></tr></table></figure>

<p><strong>方式二：开放端口</strong></p>
<ul>
<li>查看开放的端口号</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">firewall-cmd --list-all</span><br></pre></td></tr></table></figure>

<ul>
<li>设置开放的端口号</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">firewall-cmd --add-service=http --permanent</span><br><span class="line">firewall-cmd --add-port=3306/tcp --permanent</span><br></pre></td></tr></table></figure>

<ul>
<li>重启防火墙</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">firewall-cmd --reload</span><br></pre></td></tr></table></figure>

<h4 id="4-Linux下修改配置"><a href="#4-Linux下修改配置" class="headerlink" title="4. Linux下修改配置"></a><strong>4. Linux下修改配置</strong></h4><ul>
<li>修改允许远程登陆</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">use mysql;</span><br><span class="line">select Host,User from user;</span><br><span class="line">update user set host &#x3D; &#39;%&#39; where user &#x3D;&#39;root&#39;;</span><br><span class="line">flush privileges;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>%</code>是个 通配符 ，如果Host=192.168.1.%，那么就表示只要是IP地址前缀为“192.168.1.”的客户端都可以连接。如果<code>Host=%</code>，表示所有IP都有连接权限。</p>
<p>注意：在生产环境下不能为了省事将host设置为%，这样做会存在安全问题，具体的设置可以根据生产环境的IP进行设置。</p>
</blockquote>
<p>配置新连接报错：错误号码 2058，分析是 mysql 密码加密方法变了。</p>
<p><strong>解决方法一：</strong>升级远程连接工具版本</p>
<p><strong>解决方法二：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ALTER USER &#39;root&#39;@&#39;%&#39; IDENTIFIED WITH mysql_native_password BY &#39;abc123&#39;;</span><br></pre></td></tr></table></figure>

<h4 id="5-字符集的相关操作"><a href="#5-字符集的相关操作" class="headerlink" title="5. 字符集的相关操作"></a><strong>5.</strong> <strong>字符集的相关操作</strong></h4><h5 id="5-1-各级别的字符集"><a href="#5-1-各级别的字符集" class="headerlink" title="5.1 各级别的字符集"></a><strong>5.1</strong> <strong>各级别的字符集</strong></h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">show variables like &#39;character%&#39;;</span><br></pre></td></tr></table></figure>

<ul>
<li>character_set_server：服务器级别的字符集</li>
<li>character_set_database：当前数据库的字符集</li>
<li>character_set_client：服务器解码请求时使用的字符集</li>
<li>character_set_connection：服务器处理请求时会把请求字符串从character_set_client转为character_set_connection </li>
<li>character_set_results：服务器向客户端返回数据时使用的字符集</li>
</ul>
<p><strong>小结</strong></p>
<ul>
<li>如果<code>创建或修改列</code>时没有显式的指定字符集和比较规则，则该列<code>默认用表的</code>字符集和比较规则</li>
<li>如果<code>创建表时</code>没有显式的指定字符集和比较规则，则该表<code>默认用数据库的</code>字符集和比较规则</li>
<li>如果<code>创建数据库时</code>没有显式的指定字符集和比较规则，则该数据库<code>默认用服务器的</code>字符集和比较规则</li>
</ul>
<h5 id="5-2-请求到响应过程中字符集的变化"><a href="#5-2-请求到响应过程中字符集的变化" class="headerlink" title="5.2 请求到响应过程中字符集的变化"></a><strong>5.2</strong> <strong>请求到响应过程中字符集的变化</strong></h5><p><img src="https://rulerofterabithia-blog.oss-cn-hangzhou.aliyuncs.com/img/20221016214806.png"></p>
<h3 id="第02章-MySQL的数据目录"><a href="#第02章-MySQL的数据目录" class="headerlink" title="第02章 MySQL的数据目录"></a>第02章 MySQL的数据目录</h3><h4 id="1-MySQL8的主要目录结构"><a href="#1-MySQL8的主要目录结构" class="headerlink" title="1. MySQL8的主要目录结构"></a><strong>1. MySQL8的主要目录结构</strong></h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">find / -name mysql</span><br></pre></td></tr></table></figure>

<h5 id="1-1-数据库文件的存放路径"><a href="#1-1-数据库文件的存放路径" class="headerlink" title="1.1 数据库文件的存放路径"></a><strong>1.1</strong> <strong>数据库文件的存放路径</strong></h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">show variables like &#39;datadir&#39;; # &#x2F;var&#x2F;lib&#x2F;mysql&#x2F;</span><br></pre></td></tr></table></figure>

<h5 id="1-2-相关命令目录"><a href="#1-2-相关命令目录" class="headerlink" title="1.2 相关命令目录"></a><strong>1.2</strong> <strong>相关命令目录</strong></h5><p><strong>相关命令目录：/usr/bin 和/usr/sbin。</strong></p>
<h5 id="1-3-配置文件目录"><a href="#1-3-配置文件目录" class="headerlink" title="1.3 配置文件目录"></a><strong>1.3</strong> <strong>配置文件目录</strong></h5><p><strong>配置文件目录：/usr/share/mysql-8.0（命令及配置文件），/etc/mysql（如my.cnf）</strong></p>
<h4 id="2-数据库和文件系统的关系"><a href="#2-数据库和文件系统的关系" class="headerlink" title="2. 数据库和文件系统的关系"></a><strong>2.</strong> <strong>数据库和文件系统的关系</strong></h4><h5 id="2-1-表在文件系统中的表示"><a href="#2-1-表在文件系统中的表示" class="headerlink" title="2.1 表在文件系统中的表示"></a><strong>2.1</strong> <strong>表在文件系统中的表示</strong></h5><h6 id="2-3-1-InnoDB存储引擎模式"><a href="#2-3-1-InnoDB存储引擎模式" class="headerlink" title="2.3.1 InnoDB存储引擎模式"></a><strong>2.3.1 InnoDB存储引擎模式</strong></h6><p><strong>1.</strong> <strong>表结构</strong></p>
<p>为了保存表结构，<code>InnoDB</code>在<code>数据目录</code>下对应的数据库子目录下创建了一个专门用于<code>描述表结构的文件</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">表名.frm</span><br></pre></td></tr></table></figure>

<p><strong>2.</strong> <strong>表中数据和索引</strong></p>
<p><strong>① 系统表空间（system tablespace）</strong></p>
<p>默认情况下，InnoDB会在数据目录下创建一个名为<code>ibdata1</code>、大小为<code>12M</code>的<code>自拓展</code>文件，这个文件就是对应的<code>系统表空间</code>在文件系统上的表示。</p>
<p><strong>② 独立表空间(file-per-table tablespace)</strong> </p>
<p>在MySQL5.6.6以及之后的版本中，InnoDB并不会默认的把各个表的数据存储到系统表空间中，而是为<code>每一个表建立一个独立表空间</code>，也就是说我们创建了多少个表，就有多少个独立表空间。使用<code>独立表空间</code>来存储表数据的话，会在该表所属数据库对应的子目录下创建一个表示该独立表空间的文件，文件名和表名相同。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">表名.ibd</span><br></pre></td></tr></table></figure>

<blockquote>
<p>MySQL8.0中不再单独提供<code>表名.frm</code>，而是合并在<code>表名.ibd</code>文件中。</p>
</blockquote>
<p><strong>③ 系统表空间与独立表空间的设置</strong></p>
<p>我们可以自己指定使用<code>系统表空间</code>还是<code>独立表空间</code>来存储数据，这个功能由启动参数<code>innodb_file_per_table</code>控制</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="section">[server]</span> </span><br><span class="line"><span class="attr">innodb_file_per_table</span>=<span class="number">0</span> <span class="comment"># 0：代表使用系统表空间； 1：代表使用独立表空间</span></span><br></pre></td></tr></table></figure>

<p><strong>④ 其他类型的表空间</strong></p>
<p>随着MySQL的发展，除了上述两种老牌表空间之外，现在还新提出了一些不同类型的表空间，比如通用表空间（general tablespace）、临时表空间（temporary tablespace）等。</p>
<h6 id="2-3-2-MyISAM存储引擎模式"><a href="#2-3-2-MyISAM存储引擎模式" class="headerlink" title="2.3.2 MyISAM存储引擎模式"></a><strong>2.3.2 MyISAM存储引擎模式</strong></h6><p><strong>1.</strong> <strong>表结构</strong></p>
<p>在存储表结构方面， MyISAM 和 InnoDB 一样，也是在<code>数据目录</code>下对应的数据库子目录下创建了一个专门用于描述表结构的文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">表名.frm</span><br></pre></td></tr></table></figure>

<p><strong>2.</strong> <strong>表中数据和索引</strong></p>
<p>在MyISAM中的索引全部都是<code>二级索引</code>，该存储引擎的<code>数据和索引是分开存放</code>的。所以在文件系统中也是使用不同的文件来存储数据文件和索引文件，同时表数据都存放在对应的数据库子目录下。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">test.frm 存储表结构 #MySQL8.0 改为了 b.xxx.sdi</span><br><span class="line">test.MYD 存储数据 (MYData) </span><br><span class="line">test.MYI 存储索引 (MYIndex</span><br></pre></td></tr></table></figure>

<h3 id="第03章-用户与权限管理"><a href="#第03章-用户与权限管理" class="headerlink" title="第03章 用户与权限管理"></a>第03章 用户与权限管理</h3><h4 id="1-用户管理"><a href="#1-用户管理" class="headerlink" title="1. 用户管理"></a><strong>1.</strong> <strong>用户管理</strong></h4><h5 id="1-1-登录MySQL服务器"><a href="#1-1-登录MySQL服务器" class="headerlink" title="1.1 登录MySQL服务器"></a><strong>1.1</strong> <strong>登录MySQL服务器</strong></h5><p>启动MySQL服务后，可以通过mysql命令来登录MySQL服务器，命令如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql –h hostname|hostIP –P port –u username –p DatabaseName –e &quot;SQL语句&quot;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>-h参数</code>后面接主机名或者主机IP，hostname为主机，hostIP为主机IP。 </li>
<li><code>-P参数</code>后面接MySQL服务的端口，通过该参数连接到指定的端口。MySQL服务的默认端口是3306，不使用该参数时自动连接到3306端口，port为连接的端口号。</li>
<li><code>-u参数</code>后面接用户名，username为用户名。</li>
<li><code>-p参数</code>会提示输入密码。</li>
<li><code>DatabaseName参数</code>指明登录到哪一个数据库中。如果没有该参数，就会直接登录到MySQL数据库中，然后可以使用USE命令来选择数据库。</li>
<li><code>-e参数</code>后面可以直接加SQL语句。登录MySQL服务器以后即可执行这个SQL语句，然后退出MySQL服务器。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql -uroot -p -hlocalhost -P3306 mysql -e &quot;select host,user from user&quot;</span><br></pre></td></tr></table></figure>

<h5 id="1-2-创建用户"><a href="#1-2-创建用户" class="headerlink" title="1.2 创建用户"></a><strong>1.2</strong> <strong>创建用户</strong></h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE USER 用户名 [IDENTIFIED BY &#39;密码&#39;][,用户名 [IDENTIFIED BY &#39;密码&#39;]];</span><br></pre></td></tr></table></figure>

<p>举例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE USER zhang3 IDENTIFIED BY &#39;123123&#39;; # 默认host是 %</span><br><span class="line">CREATE USER &#39;kangshifu&#39;@&#39;localhost&#39; IDENTIFIED BY &#39;123456&#39;;</span><br></pre></td></tr></table></figure>

<h5 id="1-3-修改用户"><a href="#1-3-修改用户" class="headerlink" title="1.3 修改用户"></a><strong>1.3</strong> <strong>修改用户</strong></h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">UPDATE mysql.user SET USER&#x3D;&#39;li4&#39; WHERE USER&#x3D;&#39;wang5&#39;; </span><br><span class="line">FLUSH PRIVILEGES;</span><br></pre></td></tr></table></figure>

<h5 id="1-4-删除用户"><a href="#1-4-删除用户" class="headerlink" title="1.4 删除用户"></a><strong>1.4</strong> <strong>删除用户</strong></h5><p><strong>方式1：使用DROP方式删除（推荐）</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DROP USER user[,user]…;</span><br></pre></td></tr></table></figure>

<p>举例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DROP USER li4 ; # 默认删除host为%的用户</span><br><span class="line">DROP USER &#39;kangshifu&#39;@&#39;localhost&#39;;</span><br></pre></td></tr></table></figure>

<p><strong>方式2：使用DELETE方式删除（不推荐，有残留信息）</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DELETE FROM mysql.user WHERE Host&#x3D;’hostname’ AND User&#x3D;’username’;</span><br><span class="line">FLUSH PRIVILEGES;</span><br></pre></td></tr></table></figure>

<h5 id="1-5-设置当前用户密码"><a href="#1-5-设置当前用户密码" class="headerlink" title="1.5 设置当前用户密码"></a><strong>1.5</strong> <strong>设置当前用户密码</strong></h5><p><strong>1.</strong> <strong>使用ALTER USER命令来修改当前用户密码</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ALTER USER USER() IDENTIFIED BY &#39;new_password&#39;;</span><br></pre></td></tr></table></figure>

<p><strong>2.</strong> <strong>使用SET语句来修改当前用户密码</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SET PASSWORD&#x3D;&#39;new_password&#39;;</span><br></pre></td></tr></table></figure>

<h5 id="1-6-修改其它用户密码"><a href="#1-6-修改其它用户密码" class="headerlink" title="1.6 修改其它用户密码"></a><strong>1.6</strong> <strong>修改其它用户密码</strong></h5><p><strong>1.</strong> <strong>使用ALTER语句来修改普通用户的密码</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ALTER USER user [IDENTIFIED BY &#39;新密码&#39;] </span><br><span class="line">[,user[IDENTIFIED BY &#39;新密码&#39;]]…;</span><br></pre></td></tr></table></figure>

<p><strong>2.</strong> <strong>使用SET命令来修改普通用户的密码</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SET PASSWORD FOR &#39;username&#39;@&#39;hostname&#39;&#x3D;&#39;new_password&#39;;</span><br></pre></td></tr></table></figure>

<h4 id="2-权限管理"><a href="#2-权限管理" class="headerlink" title="2. 权限管理"></a><strong>2.</strong> <strong>权限管理</strong></h4><h5 id="2-1-权限列表"><a href="#2-1-权限列表" class="headerlink" title="2.1 权限列表"></a><strong>2.1</strong> <strong>权限列表</strong></h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">show privileges;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>CREATE和DROP权限</code>，可以创建新的数据库和表，或删除（移掉）已有的数据库和表。如果将MySQL数据库中的DROP权限授予某用户，用户就可以删除MySQL访问权限保存的数据库。</li>
<li><code>SELECT、INSERT、UPDATE和DELETE权限</code>允许在一个数据库现有的表上实施操作。</li>
<li><code>SELECT权限</code>只有在它们真正从一个表中检索行时才被用到。</li>
<li><code>INDEX权限</code>允许创建或删除索引，INDEX适用于已有的表。如果具有某个表的CREATE权限，就可以在CREATE TABLE语句中包括索引定义。</li>
<li><code>ALTER权限</code>可以使用ALTER TABLE来更改表的结构和重新命名表。</li>
<li><code>CREATE ROUTINE权限</code>用来创建保存的程序（函数和程序），<code>ALTER ROUTINE权限</code>用来更改和删除保存的程序，<code>EXECUTE权限</code>用来执行保存的程序。</li>
<li><code>GRANT权限</code>允许授权给其他用户，可用于数据库、表和保存的程序。</li>
<li><code>FILE权限</code>使用户可以使用LOAD DATA INFILE和SELECT … INTO OUTFILE语句读或写服务器上的文件，任何被授予FILE权限的用户都能读或写MySQL服务器上的任何文件（说明用户可以读任何数据库目录下的文件，因为服务器可以访问这些文件）。</li>
</ul>
<h5 id="2-2-授予权限的原则"><a href="#2-2-授予权限的原则" class="headerlink" title="2.2 授予权限的原则"></a><strong>2.2</strong> <strong>授予权限的原则</strong></h5><p>权限控制主要是出于安全因素，因此需要遵循以下几个<code>经验原则</code>：</p>
<p>1、只授予能<code>满足需要的最小权限</code>，防止用户干坏事。比如用户只是需要查询，那就只给select权限就可以了，不要给用户赋予update、insert或者delete权限。</p>
<p>2、创建用户的时候<code>限制用户的登录主机</code>，一般是限制成指定IP或者内网IP段。</p>
<p>3、为每个用户<code>设置满足密码复杂度的密码</code>。 </p>
<p>4、<code>定期清理不需要的用户</code>，回收权限或者删除用户。</p>
<h5 id="2-3-授予权限"><a href="#2-3-授予权限" class="headerlink" title="2.3 授予权限"></a><strong>2.3</strong> <strong>授予权限</strong></h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GRANT 权限1,权限2,…权限n ON 数据库名称.表名称 TO 用户名@用户地址 [IDENTIFIED BY ‘密码口令’];</span><br></pre></td></tr></table></figure>

<ul>
<li>该权限如果发现没有该用户，则会直接新建一个用户。</li>
<li>给li4用户用本地命令行方式，授予atguigudb这个库下的所有表的插删改查的权限。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GRANT SELECT,INSERT,DELETE,UPDATE ON atguigudb.* TO li4@localhost;</span><br></pre></td></tr></table></figure>

<ul>
<li>授予通过网络方式登录的joe用户 ，对所有库所有表的全部权限，密码设为123。注意这里唯独不包括grant的权限</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GRANT ALL PRIVILEGES ON *.* TO joe@&#39;%&#39; IDENTIFIED BY &#39;123&#39;;</span><br></pre></td></tr></table></figure>

<h5 id="2-4-查看权限"><a href="#2-4-查看权限" class="headerlink" title="2.4 查看权限"></a><strong>2.4</strong> <strong>查看权限</strong></h5><ul>
<li>查看当前用户权限</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SHOW GRANTS; </span><br><span class="line"># 或 </span><br><span class="line">SHOW GRANTS FOR CURRENT_USER; </span><br><span class="line"># 或 </span><br><span class="line">SHOW GRANTS FOR CURRENT_USER();</span><br></pre></td></tr></table></figure>

<ul>
<li>查看某用户的全局权限</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SHOW GRANTS FOR &#39;user&#39;@&#39;主机地址&#39;;</span><br></pre></td></tr></table></figure>

<h5 id="2-5-收回权限"><a href="#2-5-收回权限" class="headerlink" title="2.5 收回权限"></a><strong>2.5</strong> <strong>收回权限</strong></h5><p><strong>注意：在将用户账户从user表删除之前，应该收回相应用户的所有权限。</strong></p>
<ul>
<li>收回权限命令</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">REVOKE 权限1,权限2,…权限n ON 数据库名称.表名称 FROM 用户名@用户地址;</span><br></pre></td></tr></table></figure>

<ul>
<li>举例</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#收回全库全表的所有权限 </span><br><span class="line">REVOKE ALL PRIVILEGES ON *.* FROM joe@&#39;%&#39;; </span><br><span class="line">#收回mysql库下的所有表的插删改查权限 </span><br><span class="line">REVOKE SELECT,INSERT,UPDATE,DELETE ON mysql.* FROM joe@localhost;</span><br></pre></td></tr></table></figure>

<ul>
<li>注意：<code>须用户重新登录后才能生效</code> </li>
</ul>
<h4 id="3-角色管理"><a href="#3-角色管理" class="headerlink" title="3. 角色管理"></a><strong>3.</strong> <strong>角色管理</strong></h4><h5 id="3-1-创建角色"><a href="#3-1-创建角色" class="headerlink" title="3.1 创建角色"></a><strong>3.1</strong> <strong>创建角色</strong></h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE ROLE &#39;role_name&#39;[@&#39;host_name&#39;] [,&#39;role_name&#39;[@&#39;host_name&#39;]]...</span><br></pre></td></tr></table></figure>

<p>角色名称的命名规则和用户名类似。如果<code>host_name省略，默认为%</code>，<code>role_name不可省略</code>，不可为空。</p>
<h5 id="3-2-给角色赋予权限"><a href="#3-2-给角色赋予权限" class="headerlink" title="3.2 给角色赋予权限"></a><strong>3.2</strong> <strong>给角色赋予权限</strong></h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GRANT privileges ON table_name TO &#39;role_name&#39;[@&#39;host_name&#39;];</span><br></pre></td></tr></table></figure>

<p>上述语句中privileges代表权限的名称，多个权限以逗号隔开。可使用SHOW语句查询权限名称</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SHOW PRIVILEGES\G</span><br></pre></td></tr></table></figure>

<h5 id="3-3-查看角色的权限"><a href="#3-3-查看角色的权限" class="headerlink" title="3.3 查看角色的权限"></a><strong>3.3</strong> <strong>查看角色的权限</strong></h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SHOW GRANTS FOR &#39;role_name&#39;;</span><br></pre></td></tr></table></figure>

<p>只要你创建了一个角色，系统就会自动给你一个“<code>USAGE</code>”权限，意思是<code>连接登录数据库的权限</code>。</p>
<h5 id="3-4-回收角色的权限"><a href="#3-4-回收角色的权限" class="headerlink" title="3.4 回收角色的权限"></a><strong>3.4</strong> <strong>回收角色的权限</strong></h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">REVOKE privileges ON tablename FROM &#39;rolename&#39;;</span><br></pre></td></tr></table></figure>

<h5 id="3-5-删除角色"><a href="#3-5-删除角色" class="headerlink" title="3.5 删除角色"></a><strong>3.5</strong> <strong>删除角色</strong></h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DROP ROLE role [,role2]...</span><br></pre></td></tr></table></figure>

<p>注意，<code>如果你删除了角色，那么用户也就失去了通过这个角色所获得的所有权限</code>。</p>
<h5 id="3-6-给用户赋予角色"><a href="#3-6-给用户赋予角色" class="headerlink" title="3.6 给用户赋予角色"></a><strong>3.6</strong> <strong>给用户赋予角色</strong></h5><p>角色创建并授权后，要赋给用户并处于<code>激活状态</code>才能发挥作用。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GRANT role [,role2,...] TO user [,user2,...];</span><br></pre></td></tr></table></figure>

<p>查询当前已激活的角色</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT CURRENT_ROLE();</span><br></pre></td></tr></table></figure>

<h5 id="3-7-激活角色"><a href="#3-7-激活角色" class="headerlink" title="3.7 激活角色"></a><strong>3.7</strong> <strong>激活角色</strong></h5><p><strong>方式1：使用set default role 命令激活角色</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SET DEFAULT ROLE ALL TO &#39;kangshifu&#39;@&#39;localhost&#39;;</span><br></pre></td></tr></table></figure>

<p><strong>方式2：将activate_all_roles_on_login设置为ON</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SET GLOBAL activate_all_roles_on_login&#x3D;ON;</span><br></pre></td></tr></table></figure>

<p>这条 SQL 语句的意思是，对<code>所有角色永久激活</code>。</p>
<h5 id="3-8-撤销用户的角色"><a href="#3-8-撤销用户的角色" class="headerlink" title="3.8 撤销用户的角色"></a><strong>3.8</strong> <strong>撤销用户的角色</strong></h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">REVOKE role FROM user;</span><br></pre></td></tr></table></figure>

<h5 id="3-9-设置强制角色-mandatory-role"><a href="#3-9-设置强制角色-mandatory-role" class="headerlink" title="3.9 设置强制角色(mandatory role)"></a><strong>3.9</strong> <strong>设置强制角色(mandatory role)</strong></h5><p>方式1：服务启动前设置</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="section">[mysqld]</span> </span><br><span class="line"><span class="attr">mandatory_roles</span>=<span class="string">&#x27;role1,role2@localhost,r3@%.atguigu.com&#x27;</span></span><br></pre></td></tr></table></figure>

<p>方式2：运行时设置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SET PERSIST mandatory_roles &#x3D; &#39;role1,role2@localhost,r3@%.example.com&#39;; #系统重启后仍然有效</span><br><span class="line">SET GLOBAL mandatory_roles &#x3D; &#39;role1,role2@localhost,r3@%.example.com&#39;; #系统重启后失效</span><br></pre></td></tr></table></figure>

<h3 id="第04章-逻辑架构"><a href="#第04章-逻辑架构" class="headerlink" title="第04章 逻辑架构"></a>第04章 逻辑架构</h3><h4 id="1-逻辑架构剖析"><a href="#1-逻辑架构剖析" class="headerlink" title="1. 逻辑架构剖析"></a><strong>1.</strong> <strong>逻辑架构剖析</strong></h4><p><img src="https://rulerofterabithia-blog.oss-cn-hangzhou.aliyuncs.com/img/20221016215037.png"></p>
<h5 id="1-1-第1层：连接层"><a href="#1-1-第1层：连接层" class="headerlink" title="1.1 第1层：连接层"></a><strong>1.1</strong> <strong>第1层：连接层</strong></h5><p>系统（客户端）访问<code>MySQL</code>服务器前，做的第一件事就是建立<code>TCP</code>连接。</p>
<p>经过三次握手建立连接成功后，<code>MySQL</code>服务器对<code>TCP</code>传输过来的账号密码做身份认证、权限获取。</p>
<ul>
<li><strong>用户名或密码不对，会收到一个Access denied for user错误，客户端程序结束执行</strong></li>
<li><strong>用户名密码认证通过，会从权限表查出账号拥有的权限与连接关联，之后的权限判断逻辑，都将依赖于此时读到的权限</strong></li>
</ul>
<p><code>TCP</code>连接收到请求后，必须要分配给一个线程专门与这个客户端的交互。所以还会有个线程池，去走后面的流程。每一个连接从线程池中获取线程，省去了创建和销毁线程的开销。</p>
<h5 id="1-2-第2层：服务层"><a href="#1-2-第2层：服务层" class="headerlink" title="1.2 第2层：服务层"></a><strong>1.2</strong> <strong>第2层：服务层</strong></h5><ul>
<li><p><strong>SQL Interface: SQL接口</strong></p>
<ul>
<li>接收用户的SQL命令，并且返回用户需要查询的结果。比如SELECT … FROM就是调用SQL Interface </li>
<li>MySQL支持DML（数据操作语言）、DDL（数据定义语言）、存储过程、视图、触发器、自定义函数等多种SQL语言接口</li>
</ul>
</li>
<li><p><strong>Parser:</strong> <strong>解析器</strong></p>
<ul>
<li>在解析器中对 SQL 语句进行语法分析、语义分析。将SQL语句分解成数据结构，并将这个结构传递到后续步骤，以后SQL语句的传递和处理就是基于这个结构的。如果在分解构成中遇到错误，那么就说明这个SQL语句是不合理的。</li>
<li>在SQL命令传递到解析器的时候会被解析器验证和解析，并为其创建<code>语法树</code>，并根据数据字典丰富查询语法树，会<code>验证该客户端是否具有执行该查询的权限</code>。创建好语法树后，MySQL还会对SQL查询进行语法上的优化，进行查询重写。</li>
</ul>
</li>
<li><p><strong>Optimizer:</strong> <strong>查询优化器</strong></p>
<ul>
<li>SQL语句在语法解析之后、查询之前会使用查询优化器确定 SQL 语句的执行路径，生成一个<code>执行计划</code>。</li>
<li>这个执行计划表明应该<code>使用哪些索引</code>进行查询（全表检索还是使用索引检索），表之间的连接顺序如何，最后会按照执行计划中的步骤调用存储引擎提供的方法来真正的执行查询，并将查询结果返回给用户。</li>
<li>它使用“<code>选取-投影-连接</code>”策略进行查询。例如：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT id,name FROM student WHERE gender &#x3D; &#39;女&#39;;</span><br></pre></td></tr></table></figure>

<p>这个SELECT查询先根据WHERE语句进行<code>选取</code>，而不是将表全部查询出来以后再进行gender过滤。 这个SELECT查询先根据id和name进行属性<code>投影</code>，而不是将属性全部取出以后再进行过滤，将这两个查询条件<code>连接</code>起来生成最终查询结果。</p>
</li>
<li><p><strong>Caches &amp; Buffers： 查询缓存组件</strong></p>
<ul>
<li>MySQL内部维持着一些Cache和Buffer，比如Query Cache用来缓存一条SELECT语句的执行结果，如果能够在其中找到对应的查询结果，那么就不必再进行查询解析、优化和执行的整个过程了，直接将结果反馈给客户端。</li>
<li>这个缓存机制是由一系列小缓存组成的。比如表缓存，记录缓存，key缓存，权限缓存等 。</li>
<li>这个查询缓存可以在<code>不同客户端之间共享</code>。 </li>
<li>从MySQL 5.7.20开始，不推荐使用查询缓存，并在<code>MySQL 8.0中删除</code>。</li>
</ul>
</li>
</ul>
<h5 id="1-3-第3层：引擎层"><a href="#1-3-第3层：引擎层" class="headerlink" title="1.3 第3层：引擎层"></a><strong>1.3</strong> <strong>第3层：引擎层</strong></h5><p>插件式存储引擎层（ Storage Engines），<strong>真正的负责了MySQL中数据的存储和提取，对物理服务器级别维护的底层数据执行操作</strong>，服务层通过API与存储引擎进行通信。</p>
<h5 id="1-4-小结"><a href="#1-4-小结" class="headerlink" title="1.4 小结"></a><strong>1.4</strong> <strong>小结</strong></h5><p><img src="https://rulerofterabithia-blog.oss-cn-hangzhou.aliyuncs.com/img/20221016215146.png"></p>
<p>简化为三层结构：</p>
<ol>
<li><p>连接层：客户端和服务器端建立连接，客户端发送 SQL 至服务器端；</p>
</li>
<li><p>SQL 层（服务层）：对 SQL 语句进行查询处理；与数据库文件的存储方式无关；</p>
</li>
<li><p>存储引擎层：与数据库文件打交道，负责数据的存储和读取。</p>
</li>
</ol>
<h4 id="2-SQL执行流程"><a href="#2-SQL执行流程" class="headerlink" title="2. SQL执行流程"></a><strong>2. SQL执行流程</strong></h4><h5 id="2-1-MySQL-中的-SQL执行流程"><a href="#2-1-MySQL-中的-SQL执行流程" class="headerlink" title="2.1 MySQL 中的 SQL执行流程"></a><strong>2.1 MySQL</strong> <strong>中的</strong> <strong>SQL执行流程</strong></h5><p><img src="https://rulerofterabithia-blog.oss-cn-hangzhou.aliyuncs.com/img/20221016215232.png"></p>
<p><strong>MySQL的查询流程：</strong></p>
<p><strong>1.</strong> <strong>查询缓存</strong>：Server 如果在查询缓存中发现了这条 SQL 语句，就会直接将结果返回给客户端；如果没有，就进入到解析器阶段。需要说明的是，因为查询缓存往往效率不高，所以在 MySQL8.0 之后就抛弃了这个功能。</p>
<p>查询缓存是提前把查询结果缓存起来，这样下次不需要执行就可以直接拿到结果。需要说明的是，在MySQL 中的查询缓存，不是缓存查询计划，而是查询对应的结果。这就意味着查询匹配的<code>鲁棒性大大降低</code>，只有<code>相同的查询操作才会命中查询缓存</code>。两个查询请求在任何字符上的不同（例如：空格、注释、大小写），都会导致缓存不会命中。因此 MySQL 的 查询缓存命中率不高 。</p>
<p>同时，如果查询请求中包含某些系统函数、用户自定义变量和函数、一些系统表，如 mysql、 information_schema、 performance_schema 数据库中的表，那这个请求就不会被缓存。</p>
<p>此外，既然是缓存，那就有它<code>缓存失效的时候</code>。MySQL的缓存系统会监测涉及到的每张表，只要该表的结构或者数据被修改，如对该表使用了<code>INSERT</code>、<code>UPDATE</code>、<code>DELETE</code>、<code>TRUNCATE TABLE</code>、<code>ALTER TABLE</code>、<code>DROP TABLE</code>或<code>DROP DATABASE</code>语句，那使用该表的所有高速缓存查询都将变为无效并从高速缓存中删除！对于<code>更新压力大的数据库</code>来说，查询缓存的命中率会非常低。</p>
<p><strong>2.</strong> <strong>解析器</strong>：在解析器中对 SQL 语句进行语法分析、语义分析。</p>
<p>分析器先做“<code>词法分析</code>”。你输入的是由多个字符串和空格组成的一条 SQL 语句，MySQL 需要识别出里面的字符串分别是什么，代表什么。 MySQL 从你输入的”select”这个关键字识别出来，这是一个查询语句。它也要把字符串“T”识别成“表名 T”，把字符串“ID”识别成“列 ID”。</p>
<p>接着，要做“<code>语法分析</code>”。根据词法分析的结果，语法分析器（比如：Bison）会根据语法规则，判断你输入的这个 SQL 语句是否<code>满足 MySQL 语法</code>。如果SQL语句正确，则会生成一个语法树。</p>
<p><strong>3.</strong> <strong>优化器</strong>：在优化器中会确定 SQL 语句的执行路径，比如是根据<code>全表检索</code>，还是根据<code>索引检索</code>等。在查询优化器中，可以分为<code>逻辑查询</code>优化阶段和<code>物理查询</code>优化阶段。</p>
<p><strong>4.</strong> <strong>执行器</strong>：在执行之前需要判断该用户是否<code>具备权限</code>。如果没有，就会返回权限错误。如果具备权限，就执行 SQL查询并返回结果。在 MySQL8.0 以下的版本，如果设置了查询缓存，这时会将查询结果进行缓存。</p>
<p><img src="https://rulerofterabithia-blog.oss-cn-hangzhou.aliyuncs.com/img/20221016215309.png"></p>
<p>SQL 语句在 MySQL 中的流程是： SQL语句→查询缓存→解析器→优化器→执行器 。</p>
<h4 id="3-数据库缓冲池-buffer-pool"><a href="#3-数据库缓冲池-buffer-pool" class="headerlink" title="3. 数据库缓冲池(buffer pool)"></a><strong>3.</strong> <strong>数据库缓冲池(buffer pool)</strong></h4><p><code>InnoDB</code>存储引擎是以页为单位来管理存储空间的，我们进行的增删改查操作其实本质上都是在访问页面（包括读页面、写页面、创建新页面等操作）。而磁盘 I/O 需要消耗的时间很多，而在内存中进行操作，效率则会高很多，为了能让数据表或者索引中的数据随时被我们所用，DBMS 会申请<code>占用内存来作为数据缓冲池</code>，在真正访问页面之前，需要把在磁盘上的页缓存到内存中的<code>Buffer Pool</code>之后才可以访问。</p>
<p>这样做的好处是可以让磁盘活动最小化，从而<code>减少与磁盘直接进行 I/O 的时间</code>。要知道，这种策略对提升 SQL 语句的查询性能来说至关重要。如果索引的数据在缓冲池里，那么访问的成本就会降低很多。</p>
<h5 id="3-1-缓冲池-vs-查询缓存"><a href="#3-1-缓冲池-vs-查询缓存" class="headerlink" title="3.1 缓冲池 vs 查询缓存"></a><strong>3.1</strong> <strong>缓冲池</strong> <strong>vs</strong> <strong>查询缓存</strong></h5><p><strong>1.</strong> <strong>缓冲池（Buffer Pool）</strong></p>
<p><img src="https://rulerofterabithia-blog.oss-cn-hangzhou.aliyuncs.com/img/20221016215403.png"></p>
<p>从图中，你能看到 InnoDB 缓冲池包括了数据页、索引页、插入缓冲、锁信息、自适应 Hash 和数据字典信息等。</p>
<p><strong>缓存原则：</strong></p>
<p>“<code>位置 * 频次</code>”这个原则，可以帮我们对 I/O 访问效率进行优化。</p>
<p>首先，位置决定效率，提供缓冲池就是为了在内存中可以直接访问数据。</p>
<p>其次，频次决定优先级顺序。因为缓冲池的大小是有限的，比如磁盘有 200G，但是内存只有 16G，缓冲池大小只有 1G，就无法将所有数据都加载到缓冲池里，这时就涉及到优先级顺序，会<code>优先对使用频次高的热数据进行加载</code>。</p>
<p><strong>2.</strong> <strong>查询缓存</strong></p>
<p>查询缓存是提前把<code>查询结果缓存</code>起来，这样下次不需要执行就可以直接拿到结果。需要说明的是，在MySQL 中的查询缓存，不是缓存查询计划，而是查询对应的结果。因为命中条件苛刻，而且只要数据表发生变化，查询缓存就会失效，因此命中率低。</p>
<h5 id="3-2-缓冲池如何读取数据"><a href="#3-2-缓冲池如何读取数据" class="headerlink" title="3.2 缓冲池如何读取数据"></a><strong>3.2</strong> <strong>缓冲池如何读取数据</strong></h5><p>缓冲池管理器会尽量将经常使用的数据保存起来，在数据库进行页面读操作的时候，首先会判断该页面是否在缓冲池中，如果存在就直接读取，如果不存在，就会通过内存或磁盘将页面存放到缓冲池中再进行读取。</p>
<p><img src="https://rulerofterabithia-blog.oss-cn-hangzhou.aliyuncs.com/img/20221016215437.png"></p>
<h5 id="3-3-查看-设置缓冲池的大小"><a href="#3-3-查看-设置缓冲池的大小" class="headerlink" title="3.3 查看/设置缓冲池的大小"></a><strong>3.3</strong> <strong>查看/设置缓冲池的大小</strong></h5><p>查看缓冲池的大小</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">show variables like &#39;innodb_buffer_pool_size&#39;;</span><br></pre></td></tr></table></figure>

<p>设置缓冲池的大小</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">set global innodb_buffer_pool_size &#x3D; 268435456;</span><br></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="section">[server]</span> </span><br><span class="line"><span class="attr">innodb_buffer_pool_size</span> = <span class="number">268435456</span></span><br></pre></td></tr></table></figure>

<h5 id="3-4-多个Buffer-Pool实例"><a href="#3-4-多个Buffer-Pool实例" class="headerlink" title="3.4 多个Buffer Pool实例"></a><strong>3.4</strong> <strong>多个Buffer Pool实例</strong></h5><figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="section">[server]</span> </span><br><span class="line"><span class="attr">innodb_buffer_pool_instances</span> = <span class="number">2</span></span><br></pre></td></tr></table></figure>

<p>何查看缓冲池的个数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">show variables like &#39;innodb_buffer_pool_instances&#39;;</span><br></pre></td></tr></table></figure>

<p>每个<code>Buffer Pool</code>实例实际占内存空间</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">innodb_buffer_pool_size&#x2F;innodb_buffer_pool_instances</span><br></pre></td></tr></table></figure>

<h3 id="第05章-存储引擎"><a href="#第05章-存储引擎" class="headerlink" title="第05章 存储引擎"></a>第05章 存储引擎</h3><h4 id="1-查看存储引擎"><a href="#1-查看存储引擎" class="headerlink" title="1. 查看存储引擎"></a><strong>1.</strong> <strong>查看存储引擎</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">show engines;</span><br><span class="line"># 或</span><br><span class="line">show engines\G</span><br></pre></td></tr></table></figure>

<h4 id="2-设置系统默认的存储引擎"><a href="#2-设置系统默认的存储引擎" class="headerlink" title="2. 设置系统默认的存储引擎"></a><strong>2.</strong> <strong>设置系统默认的存储引擎</strong></h4><ul>
<li>查看默认的存储引擎：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">show variables like &#39;%storage_engine%&#39;; </span><br><span class="line">#或</span><br><span class="line">SELECT @@default_storage_engine;</span><br></pre></td></tr></table></figure>

<ul>
<li>修改默认的存储引擎</li>
</ul>
<p>如果在创建表的语句中没有显式指定表的存储引擎的话，那就会默认使用<code>InnoDB</code>作为表的存储引擎。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SET DEFAULT_STORAGE_ENGINE&#x3D;MyISAM;</span><br></pre></td></tr></table></figure>

<p>或者修改<code>my.cnf</code>文件：</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">default-storage-engine</span>=MyISAM </span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 重启服务</span> </span><br><span class="line">systemctl restart mysqld.service</span><br></pre></td></tr></table></figure>

<h4 id="3-设置表的存储引擎"><a href="#3-设置表的存储引擎" class="headerlink" title="3. 设置表的存储引擎"></a><strong>3.</strong> <strong>设置表的存储引擎</strong></h4><p>存储引擎是负责对表中的数据进行提取和写入工作的，我们可以为<code>不同的表设置不同的存储引擎</code>，也就是说不同的表可以有不同的物理存储结构，不同的提取和写入方式。</p>
<h5 id="3-1-创建表时指定存储引擎"><a href="#3-1-创建表时指定存储引擎" class="headerlink" title="3.1 创建表时指定存储引擎"></a><strong>3.1</strong> <strong>创建表时指定存储引擎</strong></h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE 表名(</span><br><span class="line">    建表语句; </span><br><span class="line">) ENGINE &#x3D; 存储引擎名称;</span><br></pre></td></tr></table></figure>

<h5 id="3-2-修改表的存储引擎"><a href="#3-2-修改表的存储引擎" class="headerlink" title="3.2 修改表的存储引擎"></a><strong>3.2</strong> <strong>修改表的存储引擎</strong></h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ALTER TABLE 表名 ENGINE &#x3D; 存储引擎名称;</span><br></pre></td></tr></table></figure>

<h4 id="4-引擎介绍"><a href="#4-引擎介绍" class="headerlink" title="4. 引擎介绍"></a><strong>4.</strong> <strong>引擎介绍</strong></h4><h5 id="4-1-InnoDB-引擎：具备外键支持功能的事务存储引擎"><a href="#4-1-InnoDB-引擎：具备外键支持功能的事务存储引擎" class="headerlink" title="4.1 InnoDB 引擎：具备外键支持功能的事务存储引擎"></a><strong>4.1 InnoDB</strong> <strong>引擎：具备外键支持功能的事务存储引擎</strong></h5><ul>
<li>MySQL从3.23.34a开始就包含InnoDB存储引擎。<code>大于等于5.5之后，默认采用InnoDB引擎</code>。 </li>
<li>InnoDB是MySQL的<code>默认事务型引擎</code>，它被设计用来处理大量的短期(short-lived)事务。可以确保事务的完整提交(Commit)和回滚(Rollback)。</li>
<li>除了增加和查询外，还需要更新、删除操作，那么，应优先选择InnoDB存储引擎。</li>
<li><strong>除非有非常特别的原因需要使用其他的存储引擎，否则应该优先考虑InnoDB引擎。</strong></li>
<li>数据文件结构：<ul>
<li>表名.frm 存储表结构（MySQL8.0时，合并在表名.ibd中）</li>
<li>表名.ibd 存储数据和索引</li>
</ul>
</li>
<li>InnoDB是<code>为处理巨大数据量的最大性能设计</code>。<ul>
<li>在以前的版本中，字典数据以元数据文件、非事务表等来存储。现在这些元数据文件被删除了。比如：<code>.frm</code>，<code>.par</code>，<code>.trn</code>，<code>.isl</code>，<code>.db.opt</code>等都在MySQL8.0中不存在了。</li>
</ul>
</li>
<li>对比MyISAM的存储引擎，<code>InnoDB写的处理效率差一些</code>，并且会占用更多的磁盘空间以保存数据和索引。</li>
<li>MyISAM只缓存索引，不缓存真实数据；InnoDB不仅缓存索引还要缓存真实数据，<code>对内存要求较高</code>，而且内存大小对性能有决定性的影响。</li>
</ul>
<h5 id="4-2-MyISAM-引擎：主要的非事务处理存储引擎"><a href="#4-2-MyISAM-引擎：主要的非事务处理存储引擎" class="headerlink" title="4.2 MyISAM 引擎：主要的非事务处理存储引擎"></a><strong>4.2 MyISAM</strong> <strong>引擎：主要的非事务处理存储引擎</strong></h5><ul>
<li>MyISAM提供了大量的特性，包括全文索引、压缩、空间函数(GIS)等，但MyISAM<code>不支持事务、行级锁、外键</code>，有一个毫无疑问的缺陷就是<code>崩溃后无法安全恢复</code>。 </li>
<li><code>5.5之前默认的存储引擎</code></li>
<li>优势是访问的<code>速度快</code>，对事务完整性没有要求或者以SELECT、INSERT为主的应用</li>
<li>针对数据统计有额外的常数存储。故而 count(*) 的查询效率很高</li>
<li>数据文件结构：<ul>
<li>表名.frm 存储表结构</li>
<li>表名.MYD 存储数据 (MYData)</li>
<li>表名.MYI 存储索引 (MYIndex)</li>
</ul>
</li>
<li>应用场景：只读应用或者以读为主的业务</li>
</ul>
<h5 id="4-3-Archive-引擎：用于数据存档"><a href="#4-3-Archive-引擎：用于数据存档" class="headerlink" title="4.3 Archive 引擎：用于数据存档"></a><strong>4.3 Archive</strong> <strong>引擎：用于数据存档</strong></h5><h5 id="4-4-Blackhole-引擎：丢弃写操作，读操作会返回空内容"><a href="#4-4-Blackhole-引擎：丢弃写操作，读操作会返回空内容" class="headerlink" title="4.4 Blackhole 引擎：丢弃写操作，读操作会返回空内容"></a><strong>4.4 Blackhole</strong> <strong>引擎：丢弃写操作，读操作会返回空内容</strong></h5><h5 id="4-5-CSV-引擎：存储数据时，以逗号分隔各个数据项"><a href="#4-5-CSV-引擎：存储数据时，以逗号分隔各个数据项" class="headerlink" title="4.5 CSV 引擎：存储数据时，以逗号分隔各个数据项"></a><strong>4.5 CSV</strong> <strong>引擎：存储数据时，以逗号分隔各个数据项</strong></h5><h5 id="4-6-Memory-引擎：置于内存的表"><a href="#4-6-Memory-引擎：置于内存的表" class="headerlink" title="4.6 Memory 引擎：置于内存的表"></a><strong>4.6 Memory</strong> <strong>引擎：置于内存的表</strong></h5><h5 id="4-7-Federated-引擎：访问远程表"><a href="#4-7-Federated-引擎：访问远程表" class="headerlink" title="4.7 Federated 引擎：访问远程表"></a><strong>4.7 Federated</strong> <strong>引擎：访问远程表</strong></h5><h5 id="4-8-Merge引擎：管理多个MyISAM表构成的表集合"><a href="#4-8-Merge引擎：管理多个MyISAM表构成的表集合" class="headerlink" title="4.8 Merge引擎：管理多个MyISAM表构成的表集合"></a><strong>4.8 Merge引擎：管理多个MyISAM表构成的表集合</strong></h5><h5 id="4-9-NDB引擎：MySQL集群专用存储引擎"><a href="#4-9-NDB引擎：MySQL集群专用存储引擎" class="headerlink" title="4.9 NDB引擎：MySQL集群专用存储引擎"></a><strong>4.9 NDB引擎：MySQL集群专用存储引擎</strong></h5><h4 id="5-MyISAM和InnoDB"><a href="#5-MyISAM和InnoDB" class="headerlink" title="5. MyISAM和InnoDB"></a><strong>5. MyISAM和InnoDB</strong></h4><table>
<thead>
<tr>
<th>对比项</th>
<th><strong>MyISAM</strong></th>
<th><strong>InnoDB</strong></th>
</tr>
</thead>
<tbody><tr>
<td>外键</td>
<td>不支持</td>
<td>支持</td>
</tr>
<tr>
<td>事务</td>
<td>不支持</td>
<td>支持</td>
</tr>
<tr>
<td>行表锁</td>
<td>表锁，即使操作一条记录也会锁住整个表，不适合高并发的操作</td>
<td>行锁，操作时只锁某一行，不对其它行有影响，适合高并发的操作</td>
</tr>
<tr>
<td>缓存</td>
<td>只缓存索引，不缓存真实数据</td>
<td>不仅缓存索引还要缓存真实数据，对内存要求较高，而且内存大小对性能有决定性的影响</td>
</tr>
<tr>
<td>自带系统表使用</td>
<td>Y</td>
<td>N</td>
</tr>
<tr>
<td>关注点</td>
<td>性能：节省资源、消耗少、简单业务</td>
<td>事务：并发写、事务、更大资源</td>
</tr>
<tr>
<td>默认安装</td>
<td>Y</td>
<td>Y</td>
</tr>
<tr>
<td>默认使用</td>
<td>N</td>
<td>Y</td>
</tr>
</tbody></table>
<h3 id="第06章-索引的数据结构"><a href="#第06章-索引的数据结构" class="headerlink" title="第06章 索引的数据结构"></a>第06章 索引的数据结构</h3><h4 id="1-索引及其优缺点"><a href="#1-索引及其优缺点" class="headerlink" title="1. 索引及其优缺点"></a><strong>1.</strong> <strong>索引及其优缺点</strong></h4><h5 id="1-1-索引概述"><a href="#1-1-索引概述" class="headerlink" title="1.1 索引概述"></a><strong>1.1</strong> <strong>索引概述</strong></h5><p>MySQL官方对索引的定义为：<strong>索引（Index）是帮助MySQL高效获取数据的数据结构</strong>。</p>
<p><strong>索引的本质：</strong>索引是数据结构。你可以简单理解为“排好序的快速查找数据结构”，满足特定查找算法。这些数据结构以某种方式指向数据， 这样就可以在这些数据结构的基础上实现<code>高级查找算法</code>。</p>
<h5 id="1-2-优点"><a href="#1-2-优点" class="headerlink" title="1.2 优点"></a><strong>1.2</strong> <strong>优点</strong></h5><p>（1）类似大学图书馆建书目索引，提高数据检索的效率，降低<code>数据库的IO成本</code>，这也是创建索引最主要的原因。</p>
<p>（2）通过创建唯一索引，可以保证数据库表中每一行<code>数据的唯一性</code>。</p>
<p>（3）在实现数据的参考完整性方面，可以<code>加速表和表之间的连接</code>。换句话说，对于有依赖关系的子表和父表联合查询时，可以提高查询速度。</p>
<p>（4）在使用分组和排序子句进行数据查询时，可以显著<code>减少查询中分组和排序的时间</code>，降低了CPU的消耗。</p>
<h5 id="1-3-缺点"><a href="#1-3-缺点" class="headerlink" title="1.3 缺点"></a><strong>1.3</strong> <strong>缺点</strong></h5><p>（1）创建索引和维护索引要<code>耗费时间</code>，并且随着数据量的增加，所耗费的时间也会增加。</p>
<p>（2）索引需要占<code>磁盘空间</code>，除了数据表占数据空间之外，每一个索引还要占一定的物理空间<code>存储在磁盘上</code>，如果有大量的索引，索引文件就可能比数据文件更快达到最大文件尺寸。</p>
<p>（3）虽然索引大大提高了查询速度，同时却会<code>降低更新表的速度</code>。当对表中的数据进行增加、删除和修改的时候，索引也要动态地维护，这样就降低了数据的维护速度。</p>
<h4 id="2-InnoDB中索引的推演"><a href="#2-InnoDB中索引的推演" class="headerlink" title="2. InnoDB中索引的推演"></a><strong>2. InnoDB中索引的推演</strong></h4><h5 id="2-1-索引之前的查找"><a href="#2-1-索引之前的查找" class="headerlink" title="2.1 索引之前的查找"></a><strong>2.1</strong> <strong>索引之前的查找</strong></h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT [列名列表] FROM 表名 WHERE 列名 &#x3D; xxx;</span><br></pre></td></tr></table></figure>

<p><strong>1.在一个页中的查找</strong></p>
<p>假设目前表中的记录比较少，所有的记录都可以被存放在一个页中，在查找记录的时候可以根据搜索条件的不同分为两种情况：</p>
<ul>
<li>以主键为搜索条件<ul>
<li>可以在页目录中使用<code>二分法</code>快速定位到对应的槽，然后再遍历该槽对应分组中的记录即可快速找到指定的记录。</li>
</ul>
</li>
<li>以其他列作为搜索条件<ul>
<li>因为在数据页中并没有对非主键建立所谓的页目录，所以我们无法通过二分法快速定位相应的槽。这种情况下只能从最小记录开始依次遍历单链表中的每条记录，然后对比每条记录是不是符合搜索条件。很显然，这种查找的效率是非常低的。</li>
</ul>
</li>
</ul>
<p><strong>2.在很多页中查找</strong></p>
<p>大部分情况下我们表中存放的记录都是非常多的，需要好多的数据页来存储这些记录。在很多页中查找记录的话可以分为两个步骤：</p>
<ol>
<li>定位到记录所在的页。</li>
<li>从所在的页内查找相应的记录。</li>
</ol>
<p>在没有索引的情况下，不论是根据主键列或者其他列的值进行查找，由于我们并不能快速的定位到记录所在的页，所以只能<code>从第一个页</code>沿着<code>双向链表</code>一直往下找，在每一个页中根据我们上面的查找方式去查找指定的记录。因为要遍历所有的数据页，所以这种方式显然是<code>超级耗时</code>的。</p>
<h5 id="2-2-设计索引"><a href="#2-2-设计索引" class="headerlink" title="2.2 设计索引"></a><strong>2.2</strong> <strong>设计索引</strong></h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; CREATE TABLE index_demo(</span><br><span class="line">    -&gt; c1 INT,</span><br><span class="line">    -&gt; c2 INT,</span><br><span class="line">    -&gt; c3 CHAR(1),</span><br><span class="line">    -&gt; PRIMARY KEY(c1)</span><br><span class="line">    -&gt; ) ROW_FORMAT &#x3D; Compact;</span><br></pre></td></tr></table></figure>

<p>这个新建的<code>index_demo</code>表中有2个INT类型的列，1个CHAR(1)类型的列，而且我们规定了c1列为主键，这个表使用<code>Compact</code>行格式来实际存储记录的。这里我们简化了index_demo表的行格式示意图：</p>
<p><img src="https://rulerofterabithia-blog.oss-cn-hangzhou.aliyuncs.com/img/20221016215546.png"></p>
<ul>
<li><code>record_type</code>：记录头信息的一项属性，表示记录的类型，<code>0</code>表示普通记录、<code>1</code>表示目录项记录、<code>2</code>表示最小记录、<code>3</code>表示最大记录。</li>
<li><code>next_record</code>：记录头信息的一项属性，表示下一条地址相对于本条记录的地址偏移量，我们用箭头来表明下一条记录是谁。</li>
<li><code>各个列的值</code>：这里只记录在<code>index_demo</code>表中的三个列，分别是<code>c1</code>、<code>c2</code>和<code>c3</code>。 </li>
<li><code>其他信息</code>：除了上述3种信息以外的所有信息，包括其他隐藏列的值以及记录的额外信息。</li>
</ul>
<p>将记录格式示意图的其他信息项暂时去掉并把它竖起来的效果就是这样：</p>
<p><img src="https://rulerofterabithia-blog.oss-cn-hangzhou.aliyuncs.com/img/20221016215626.png"></p>
<p>把一些记录放到页里的示意图就是：</p>
<p><img src="https://rulerofterabithia-blog.oss-cn-hangzhou.aliyuncs.com/img/20221016215657.png"></p>
<p><strong>1.</strong> <strong>一个简单的索引设计方案</strong></p>
<p>我们在根据某个搜索条件查找一些记录时为什么要遍历所有的数据页呢？因为各个页中的记录并没有规律，我们并不知道我们的搜索条件匹配哪些页中的记录，所以不得不依次遍历所有的数据页。所以如果我们<code>想快速的定位到需要查找的记录在哪些数据页</code>中该咋办？我们可以为快速定位记录所在的数据页而<code>建立一个目录</code>，建这个目录必须完成下边这些事：</p>
<ul>
<li><strong>下一个数据页中用户记录的主键值必须大于上一个页中用户记录的主键值。</strong></li>
<li><strong>给所有的页建立一个目录项。</strong></li>
</ul>
<p><img src="https://rulerofterabithia-blog.oss-cn-hangzhou.aliyuncs.com/img/20221016215738.png"></p>
<p>以<code>页28</code>为例，它对应<code>目录项2</code>，这个目录项中包含着该页的页号<code>28</code>以及该页中用户记录的最小主键值<code>5</code>。我们只需要把几个目录项在物理存储器上连续存储（比如：数组），就可以实现根据主键值快速查找某条记录的功能了。比如：查找主键值为<code>20</code>的记录，具体查找过程分两步：</p>
<ol>
<li><p>先从目录项中根据<code>二分法</code>快速确定出主键值为<code>20</code>的记录在<code>目录项3</code>中（因为 12 &lt; 20 &lt; 209 ），它对应的页是<code>页9</code>。 </p>
</li>
<li><p>再根据前边说的在页中查找记录的方式去<code>页9</code>中定位具体的记录。</p>
</li>
</ol>
<p>至此，针对数据页做的简易目录就搞定了。这个目录有一个别名，称为<code>索引</code>。</p>
<p><strong>2. InnoDB中的索引方案</strong> </p>
<p><strong>① 迭代1次：目录项纪录的页</strong></p>
<p>我们把前边使用到的目录项放到数据页中的样子就是这样：</p>
<p><img src="https://rulerofterabithia-blog.oss-cn-hangzhou.aliyuncs.com/img/20221016215831.png"></p>
<p>从图中可以看出来，我们新分配了一个编号为30的页来专门存储目录项记录。这里再次强调<code>目录项记录</code>和普通的<code>用户记录</code>的<strong>不同点</strong>：</p>
<ul>
<li><code>目录项记录</code>的<code>record_type</code>值是1，而<code>普通用户记录</code>的<code>record_type</code>值是0。</li>
<li>目录项记录只有<code>主键值和页的编号</code>两个列，而普通的用户记录的列是用户自己定义的，可能包含<code>很多列</code>，另外还有InnoDB自己添加的隐藏列。</li>
<li>了解：记录头信息里还有一个叫<code>min_rec_mask</code>的属性，只有在存储<code>目录项记录</code>的页中的主键值最小的<code>目录项记录</code>的<code>min_rec_mask</code>值为<code>1</code>，其他别的记录的<code>min_rec_mask</code>值都是<code>0</code>。</li>
</ul>
<p><strong>相同点：</strong>两者用的是一样的数据页，都会为主键值生成<code>Page Directory</code>（页目录），从而在按照主键值进行查找时可以使用<code>二分法</code>来加快查询速度。</p>
<p>现在以查找主键为<code>20</code>的记录为例，根据某个主键值去查找记录的步骤就可以大致拆分成下边两步：</p>
<ol>
<li><p>先到存储<code>目录项记录</code>的页，也就是页30中通过<code>二分法</code>快速定位到对应目录项，因为 12 &lt; 20 &lt; 209 ，所以定位到对应的记录所在的页就是页9。 </p>
</li>
<li><p>再到存储用户记录的页9中根据<code>二分法</code>快速定位到主键值为<code>20</code>的用户记录。</p>
</li>
</ol>
<p><strong>② 迭代2次：多个目录项纪录的页</strong></p>
<p><img src="https://rulerofterabithia-blog.oss-cn-hangzhou.aliyuncs.com/img/20221016215903.png"></p>
<p>从图中可以看出，我们插入了一条主键值为320的用户记录之后需要两个新的数据页：</p>
<ul>
<li>为存储该用户记录而新生成了<code>页31</code>。</li>
<li>因为原先存储目录项记录的<code>页30的容量已满</code>（我们前边假设只能存储4条目录项记录），所以不得不需要一个新的<code>页32</code>来存放<code>页31</code>对应的目录项。</li>
</ul>
<p>现在因为存储目录项记录的页不止一个，所以如果我们想根据主键值查找一条用户记录大致需要3个步骤，以查找主键值为<code>20</code>的记录为例：</p>
<ol>
<li><p>确定<code>目录项记录页</code>我们现在的存储目录项记录的页有两个，即<code>页30</code>和<code>页32</code>，又因为页30表示的目录项的主键值的范围是 [1, 320) ，页32表示的目录项的主键值不小于 320 ，所以主键值为<code>20</code>的记录对应的目录项记录在<code>页30</code>中。</p>
</li>
<li><p>通过目录项记录页<code>确定用户记录真实所在的页</code>。在一个存储<code>目录项记录</code>的页中通过主键值定位一条目录项记录的方式说过了。</p>
</li>
<li><p>在真实存储用户记录的页中定位到具体的记录。</p>
</li>
</ol>
<p><strong>③ 迭代3次：目录项记录页的目录页</strong></p>
<p><img src="https://rulerofterabithia-blog.oss-cn-hangzhou.aliyuncs.com/img/20221016215933.png"></p>
<p>如图，我们生成了一个存储更高级目录项的<code>页33</code>，这个页中的两条记录分别代表页30和页32，如果用户记录的主键值在<code>[1, 320)</code>之间，则到页30中查找更详细的目录项记录，如果主键值<code>不小于320</code>的话，就到页32中查找更详细的目录项记录。</p>
<p>我们可以用下边这个图来描述它：</p>
<p><img src="https://rulerofterabithia-blog.oss-cn-hangzhou.aliyuncs.com/img/20221016215955.png"></p>
<p>这个数据结构，它的名称是<code>B+树</code>。 </p>
<p><strong>④</strong> <strong>B+Tree</strong></p>
<p>一个B+树的节点其实可以分成好多层，规定最下边的那层，也就是存放我们用户记录的那层为第<code>0</code>层，之后依次往上加。之前我们做了一个非常极端的假设：存放用户记录的页<code>最多存放3条记录</code>，存放目录项记录的页<code>最多存放4条记录</code>。其实真实环境中一个页存放的记录数量是非常大的，假设所有存放用户记录的叶子节点代表的数据页可以存放<code>100条用户记录</code>，所有存放目录项记录的内节点代表的数据页可以存放<code>1000条目录项记录</code>，那么：</p>
<ul>
<li>如果B+树只有1层，也就是只有1个用于存放用户记录的节点，最多能存放<code>100</code>条记录。</li>
<li>如果B+树有2层，最多能存放<code>1000×100=10,0000</code>条记录。</li>
<li>如果B+树有3层，最多能存放<code>1000×1000×100=1,0000,0000</code>条记录。</li>
<li>如果B+树有4层，最多能存放<code>1000×1000×1000×100=1000,0000,0000</code>条记录。相当多的记录！！！</li>
</ul>
<p>你的表里能存放<code>100000000000</code>条记录吗？所以一般情况下，我们<code>用到的B+树都不会超过4层</code>，那我们通过主键值去查找某条记录最多只需要做4个页面内的查找（查找3个目录项页和一个用户记录页），又因为在每个页面内有所谓的<code>Page Directory</code>（页目录），所以在页面内也可以通过<code>二分法</code>实现快速定位记录。</p>
<h5 id="2-3-常见索引概念"><a href="#2-3-常见索引概念" class="headerlink" title="2.3 常见索引概念"></a><strong>2.3</strong> <strong>常见索引概念</strong></h5><p><strong>1.</strong> <strong>聚簇索引</strong></p>
<p><strong>特点：</strong></p>
<ol>
<li><p>使用记录主键值的大小进行记录和页的排序，这包括三个方面的含义：</p>
<ul>
<li><p><code>页内</code>的记录是按照主键的大小顺序排成一个<code>单向链表</code>。</p>
</li>
<li><p>各个存放<code>用户记录的页</code>也是根据页中用户记录的主键大小顺序排成一个<code>双向链表</code>。</p>
</li>
<li><p>存放<code>目录项记录的页</code>分为不同的层次，在同一层次中的页也是根据页中目录项记录的主键大小顺序排成一个<code>双向链表</code>。 </p>
</li>
</ul>
</li>
<li><p>B+树的<code>叶子节点</code>存储的是完整的用户记录。</p>
<p>所谓完整的用户记录，就是指这个记录中存储了所有列的值（包括隐藏列）。</p>
</li>
</ol>
<p><strong>优点：</strong></p>
<ul>
<li><code>数据访问更快</code>，因为聚簇索引将索引和数据保存在同一个B+树中，因此从聚簇索引中获取数据比非聚簇索引更快</li>
<li>聚簇索引对于主键的<code>排序查找</code>和<code>范围查找</code>速度非常快</li>
<li>按照聚簇索引排列顺序，查询显示一定范围数据的时候，由于数据都是紧密相连，数据库不用从多个数据块中提取数据，所以<code>节省了大量的io操作</code>。</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li><code>插入速度严重依赖于插入顺序</code>，按照主键的顺序插入是最快的方式，否则将会出现页分裂，严重影响性能。因此，对于InnoDB表，我们一般都会定义一个<strong>自增ID列为主键</strong></li>
<li><code>更新主键的代价很高</code>，因为将会导致被更新的行移动。因此，对于InnoDB表，我们一般定义<strong>主键为不可更新</strong></li>
<li><code>二级索引访问需要两次索引查找</code>，第一次找到主键值，第二次根据主键值找到行数据</li>
</ul>
<p><strong>2.</strong> <strong>二级索引（辅助索引、非聚簇索引）</strong></p>
<p><img src="https://rulerofterabithia-blog.oss-cn-hangzhou.aliyuncs.com/img/20221016220030.png"></p>
<p><strong>概念：回表</strong> 我们根据这个以c2列大小排序的B+树只能确定我们要查找记录的主键值，所以如果我们想根据c2列的值查找到完整的用户记录的话，仍然需要到<code>聚簇索引</code>中再查一遍，这个过程称为<code>回表</code>。也就是根据c2列的值查询一条完整的用户记录需要使用到<code>2</code>棵B+树！</p>
<p><strong>3.</strong> <strong>联合索引</strong></p>
<p>我们也可以同时以多个列的大小作为排序规则，也就是同时为多个列建立索引，比方说我们想让B+树按照<code>c2和c3列</code>的大小进行排序，这个包含两层含义：</p>
<ul>
<li><p>先把各个记录和页按照c2列进行排序。</p>
</li>
<li><p>在记录的c2列相同的情况下，采用c3列进行排序</p>
</li>
</ul>
<p>注意一点，以c2和c3列的大小为排序规则建立的B+树称为<code>联合索引</code>，本质上也是一个二级索引。它的意思与分别为c2和c3列分别建立索引的表述是不同的，不同点如下：</p>
<ul>
<li><p>建立<code>联合索引</code>只会建立如上图一样的1棵B+树。</p>
</li>
<li><p>为c2和c3列分别建立索引会分别以c2和c3列的大小为排序规则建立2棵B+树。</p>
</li>
</ul>
<h5 id="2-4-InnoDB的B-树索引的注意事项"><a href="#2-4-InnoDB的B-树索引的注意事项" class="headerlink" title="2.4 InnoDB的B+树索引的注意事项"></a><strong>2.4 InnoDB的B+树索引的注意事项</strong></h5><p><strong>1.</strong> <strong>根页面位置万年不动</strong> </p>
<p>我们前边介绍B+索引的时候，为了大家理解上的方便，先把存储用户记录的叶子节点都画出来，然后接着画存储目录项记录的内节点，实际上B+树的形成过程是这样的：</p>
<ul>
<li>每当为某个表创建一个B+树索引（聚簇索引不是人为创建的，默认就有）的时候，都会为这个索引创建一个<code>根节点</code>页面。最开始表中没有数据的时候，每个B+树索引对应的<code>根节点</code>中既没有用户记录，也没有目录项记录。</li>
<li>随后向表中插入用户记录时，先把用户记录存储到这个<code>根节点</code>中。</li>
<li>当根节点中的可用<code>空间用完时</code>继续插入记录，此时会将根节点中的所有记录复制到一个新分配的页，比如<code>页a</code>中，然后对这个新页进行<code>页分裂</code>的操作，得到另一个新页，比如<code>页b</code>。这时新插入的记录根据键值（也就是聚簇索引中的主键值，二级索引中对应的索引列的值）的大小就会被分配到<code>页a</code>或者<code>页b</code>中，而<code>根节点</code>便升级为存储目录项记录的页。</li>
</ul>
<p>这个过程特别注意的是：一个B+树索引的根节点自诞生之日起，便不会再移动。这样只要我们对某个表建立一个索引，那么它的根节点的页号便会被记录到某个地方，然后凡是<code>InnoDB</code>存储引擎需要用到这个索引的时候，都会从那个固定的地方取出根节点的页号，从而来访问这个索引。</p>
<p><strong>2.</strong> <strong>内节点中目录项记录的唯一性</strong> </p>
<p>我们知道B+树索引的内节点中目录项记录的内容是<code>索引列+页号</code>的搭配，但是这个搭配对于二级索引来说有点不严谨。还拿<code>index_demo</code>表为例，假设这个表中的数据是这样的：</p>
<table>
<thead>
<tr>
<th>c1</th>
<th>c2</th>
<th>c3</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>1</td>
<td>‘u’</td>
</tr>
<tr>
<td>3</td>
<td>1</td>
<td>‘d’</td>
</tr>
<tr>
<td>5</td>
<td>1</td>
<td>‘y’</td>
</tr>
<tr>
<td>7</td>
<td>1</td>
<td>‘a’</td>
</tr>
</tbody></table>
<p>如果二级索引中目录项的内容只是<code>索引号+页号</code>的搭配的话，那么为<code>c2</code>列建立索引后的B+树应该长这样：</p>
<p><img src="https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202203301110222.png" alt="image-20220330111029120"></p>
<p>如果我们想要新插入一行记录，其中<code>c1</code>、<code>c2</code>、<code>c3</code>的值分别是：<code>9</code>、<code>1</code>、<code>c</code>，那么在修改这个为c2列建立的二级索引对应的B+树时便碰到了个大问题：由于<code>页3</code>中存储的目录项记录是由<code>c2列+页号</code>的值构成的，<code>页3</code>中的两条目录项记录对应的c2列的值都是<code>1</code>，那么我们这条新插入的记录到底应该放在<code>页4</code>中，还是应该放在<code>页5</code>中啊？答案是：对不起，懵了。</p>
<p>为了让新插入记录能找到自己在哪个页里，我们需要<strong>保证在B+树的同一层内节点的目录项记录除页号这个字段以外是唯一的。</strong>所以对于二级索引的内节点的目录项记录的内容实际上是由三个部分构成的：</p>
<ul>
<li>索引列的值</li>
<li>主键值</li>
<li>页号</li>
</ul>
<p>也就是我们把主键值也添加到二级索引内节点中的目录项记录了，这样就能保证B+树每一层节点中各条目录项记录除页号这个字段外是唯一的，所以我们为c2列建立二级索引后的示意图实际上应该是这样子的：</p>
<p><img src="https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202203301120304.png" alt="image-20220330112018199"></p>
<p>这样我们再插入记录<code>(9, 1, &#39;c&#39;)</code>时，由于<code>页3</code>中存储的目录项记录是由<code>c2列+主键+页号</code>的值构成的，可以先把新记录的<code>c2</code>列的值和<code>页3</code>中各目录项记录的<code>c2</code>列的值作比较，如果<code>c2</code>列的值相同的话，可以接着比较主键值，因为B+树同一层中不同目录项记录的<code>c2列+主键</code>的值肯定是不一样的，所以最后肯定能定位唯一的一条目录项记录，在本例中最后确定新记录应该被插入到<code>页5</code>中。</p>
<p><strong>3.</strong> <strong>一个页面最少可以存储2条记录</strong></p>
<p>一个B+树只需要很少的层级就可以轻松存储数亿条记录，查询速度相当不错！这是因为B+树本质上就是一个大的多层级目录，每经过一个目录时都会过滤掉许多无效的子目录，直到最后访问的存储真实数据的目录。那如果一个大的目录中只存放一个子目录是个啥效果呢？那就是目录层级非常非常非常多，而且最后的那个存放真实数据的目录中存放一条记录。费了半天劲只能存放一条真实的用户记录？所以<code>InnoDB的一个数据页至少可以存放两条记录</code></p>
<h4 id="3-MyISAM中的索引方案"><a href="#3-MyISAM中的索引方案" class="headerlink" title="3. MyISAM中的索引方案"></a><strong>3. MyISAM中的索引方案</strong></h4><p><strong>B树索引适用存储引擎如表所示：</strong></p>
<table>
<thead>
<tr>
<th>索引/存储引擎</th>
<th>MyISAM</th>
<th>InnoDB</th>
<th>Memory</th>
</tr>
</thead>
<tbody><tr>
<td>B-Tree索引</td>
<td>支持</td>
<td>支持</td>
<td>支持</td>
</tr>
</tbody></table>
<p>即使多个存储引擎支持同一种类型的索引，但是他们的实现原理也是不同的。Innodb和MyISAM默认的索引是Btree索引；而Memory默认的索引是Hash索引。</p>
<p>MyISAM引擎使用<code>B+Tree</code>作为索引结构，叶子节点的data域存放的是<code>数据记录的地址</code>。</p>
<h5 id="3-1-MyISAM索引的原理"><a href="#3-1-MyISAM索引的原理" class="headerlink" title="3.1 MyISAM索引的原理"></a><strong>3.1 MyISAM索引的原理</strong></h5><p><img src="https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202203301133907.png" alt="image-20220330113307813"></p>
<h5 id="3-2-MyISAM-与-InnoDB对比"><a href="#3-2-MyISAM-与-InnoDB对比" class="headerlink" title="3.2 MyISAM 与 InnoDB对比"></a><strong>3.2 MyISAM</strong> <strong>与</strong> <strong>InnoDB对比</strong></h5><p><strong>MyISAM的索引方式都是“非聚簇”的，与InnoDB包含1个聚簇索引是不同的。</strong></p>
<p><strong>小结两种引擎中索引的区别：</strong></p>
<p>① 在InnoDB存储引擎中，我们只需要根据主键值对<code>聚簇索引</code>进行一次查找就能找到对应的记录，而在<code>MyISAM</code>中却需要进行一次<code>回表</code>操作，意味着MyISAM中建立的索引相当于全部都是<code>二级索引</code>。 </p>
<p>② InnoDB的数据文件本身就是索引文件，而MyISAM索引文件和数据文件是<code>分离的</code>，索引文件仅保存数据记录的地址。</p>
<p>③ InnoDB的非聚簇索引data域存储相应记录<code>主键的值</code>，而MyISAM索引记录的是<code>地址</code>。换句话说，InnoDB的所有非聚簇索引都引用主键作为data域。</p>
<p>④ MyISAM的回表操作是十分<code>快速</code>的，因为是拿着地址偏移量直接到文件中取数据的，反观InnoDB是通过获取主键之后再去聚簇索引里找记录，虽然说也不慢，但还是比不上直接用地址去访问。</p>
<p>⑤ InnoDB要求表<code>必须有主键</code>（<code>MyISAM可以没有</code>）。如果没有显式指定，则MySQL系统会自动选择一个可以非空且唯一标识数据记录的列作为主键。如果不存在这种列，则MySQL自动为InnoDB表生成一个隐含字段作为主键，这个字段长度为6个字节，类型为长整型。</p>
<h4 id="4-索引的代价"><a href="#4-索引的代价" class="headerlink" title="4. 索引的代价"></a><strong>4.</strong> <strong>索引的代价</strong></h4><p>索引是个好东西，可不能乱建，它在空间和时间上都会有消耗：</p>
<ul>
<li><strong>空间上的代价</strong></li>
</ul>
<p>每建立一个索引都要为它建立一棵B+树，每一棵B+树的每一个节点都是一个数据页，一个页默认会占用<code>16KB</code>的存储空间，一棵很大的B+树由许多数据页组成，那就是很大的一片存储空间。</p>
<ul>
<li><strong>时间上的代价</strong></li>
</ul>
<p>每次对表中的数据进行<code>增、删、改</code>操作时，都需要去修改各个B+树索引。而且我们讲过，B+树每层节点都是按照索引列的值<code>从小到大的顺序排序</code>而组成了<code>双向链表</code>。不论是叶子节点中的记录，还是内节点中的记录（也就是不论是用户记录还是目录项记录）都是按照索引列的值从小到大的顺序而形成了一个单向链表。而增、删、改操作可能会对节点和记录的排序造成破坏，所以存储引擎需要额外的时间进行一些<code>记录移位</code>，<code>页面分裂</code>、<code>页面回收</code>等操作来维护好节点和记录的排序。如果我们建了许多索引，每个索引对应的B+树都要进行相关的维护操作，会给性能拖后腿。</p>
<h4 id="5-MySQL数据结构选择的合理性"><a href="#5-MySQL数据结构选择的合理性" class="headerlink" title="5. MySQL数据结构选择的合理性"></a><strong>5. MySQL数据结构选择的合理性</strong></h4><h5 id="5-1-二叉搜索树"><a href="#5-1-二叉搜索树" class="headerlink" title="5.1 二叉搜索树"></a><strong>5.1</strong> <strong>二叉搜索树</strong></h5><p>如果我们利用二叉树作为索引结构，那么磁盘的IO次数和索引树的高度是相关的。</p>
<p><img src="https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202203301636830.png" alt="image-20220330163602743"></p>
<p>为了提高查询效率，就需要<code>减少磁盘IO数</code>。为了减少磁盘IO的次数，就需要尽量<code>降低树的高度</code>，需要把原来“瘦高”的树结构变的“矮胖”，树的每层的分叉越多越好。</p>
<h5 id="5-2-AVL树"><a href="#5-2-AVL树" class="headerlink" title="5.2 AVL树"></a><strong>5.2 AVL树</strong></h5><p>如果我们利用二叉树作为索引结构，那么磁盘的IO次数和索引树的高度是相关的。</p>
<p><img src="https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202203301635653.png" alt="image-20220330163506536"></p>
<p>针对同样的数据，如果我们把二叉树改成<code>M 叉树</code>（M&gt;2）呢？当 M=3 时，同样的 31 个节点可以由下面的三叉树来进行存储：</p>
<p><img src="https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202203301637104.png" alt="image-20220330163709022"></p>
<h5 id="5-3-B-Tree"><a href="#5-3-B-Tree" class="headerlink" title="5.3 B-Tree"></a><strong>5.3 B-Tree</strong></h5><p>B 树的结构如下图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202203301638995.png" alt="image-20220330163803905"></p>
<p>一个 M 阶的 B 树（M&gt;2）有以下的特性：</p>
<ol>
<li><p>根节点的儿子数的范围是 [2,M]。 </p>
</li>
<li><p>每个中间节点包含 k-1 个关键字和 k 个孩子，孩子的数量 = 关键字的数量 +1，k 的取值范围为[ceil(M/2), M]。 </p>
</li>
<li><p>叶子节点包括 k-1 个关键字（叶子节点没有孩子），k 的取值范围为 [ceil(M/2), M]。 </p>
</li>
<li><p>假设中间节点节点的关键字为：Key[1], Key[2], …, Key[k-1]，且关键字按照升序排序，即 Key[i] &lt;Key[i+1]。此时 k-1 个关键字相当于划分了 k 个范围，也就是对应着 k 个指针，即为：P[1], P[2], …,P[k]，其中 P[1] 指向关键字小于 Key[1] 的子树，P[i] 指向关键字属于 (Key[i-1], Key[i]) 的子树，P[k]指向关键字大于 Key[k-1] 的子树。</p>
</li>
<li><p>所有叶子节点位于同一层。</p>
</li>
</ol>
<p>上面那张图所表示的 B 树就是一棵 3 阶的 B 树。我们可以看下磁盘块 2，里面的关键字为（8，12），它有 3 个孩子 (3，5)，(9，10) 和 (13，15)，你能看到 (3，5) 小于 8，(9，10) 在 8 和 12 之间，而 (13，15)大于 12，刚好符合刚才我们给出的特征。</p>
<p>然后我们来看下如何用 B 树进行查找。假设我们想要<code>查找的关键字是 9</code>，那么步骤可以分为以下几步：</p>
<ol>
<li><p>我们与根节点的关键字 (17，35）进行比较，9 小于 17 那么得到指针 P1； </p>
</li>
<li><p>按照指针 P1 找到磁盘块 2，关键字为（8，12），因为 9 在 8 和 12 之间，所以我们得到指针 P2； </p>
</li>
<li><p>按照指针 P2 找到磁盘块 6，关键字为（9，10），然后我们找到了关键字 9。</p>
</li>
</ol>
<p>你能看出来在 B 树的搜索过程中，我们比较的次数并不少，但如果把数据读取出来然后在内存中进行比较，这个时间就是可以忽略不计的。而读取磁盘块本身需要进行 I/O 操作，消耗的时间比在内存中进行比较所需要的时间要多，是数据查找用时的重要因素。<code>B 树相比于平衡二叉树来说磁盘 I/O 操作要少</code>，在数据查询中比平衡二叉树效率要高。所以<code>只要树的高度足够低，IO次数足够少，就可以提高查询性能</code>。</p>
<p><strong>再举例1：</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202203301644761.png" alt="image-20220330164411665"></p>
<h5 id="5-4-B-Tree"><a href="#5-4-B-Tree" class="headerlink" title="5.4 B+Tree"></a><strong>5.4 B+Tree</strong></h5><p><strong>B+</strong> <strong>树和</strong> <strong>B</strong> <strong>树的差异：</strong></p>
<ol>
<li><p>有 k 个孩子的节点就有 k 个关键字。也就是孩子数量 = 关键字数，而 B 树中，孩子数量 = 关键字数+1。</p>
</li>
<li><p>非叶子节点的关键字也会同时存在在子节点中，并且是在子节点中所有关键字的最大（或最小）。</p>
</li>
<li><p>非叶子节点仅用于索引，不保存数据记录，跟记录有关的信息都放在叶子节点中。而 B 树中， <code>非叶子节点既保存索引，也保存数据记录</code>。 </p>
</li>
<li><p>所有关键字都在叶子节点出现，叶子节点构成一个有序链表，而且叶子节点本身按照关键字的大小从小到大顺序链接。</p>
</li>
</ol>
<blockquote>
<p>B 树和 B+ 树都可以作为索引的数据结构，在 MySQL 中采用的是 B+ 树。</p>
<p>但B树和B+树各有自己的应用场景，不能说B+树完全比B树好，反之亦然。</p>
</blockquote>
<p><strong>思考题：为了减少IO，索引树会一次性加载吗？</strong></p>
<blockquote>
<p>1、数据库索引是存储在磁盘上的，如果数据量很大，必然导致索引的大小也会很大，超过几个G。</p>
<p>2、当我们利用索引查询时候，是不可能将全部几个G的索引都加载进内存的，我们能做的只能是：逐一加载每一个磁盘页，因为磁盘页对应着索引树的节点。</p>
</blockquote>
<p><strong>思考题：B+树的存储能力如何？为何说一般查找行记录，最多只需1~3次磁盘IO</strong></p>
<blockquote>
<p>InnoDB存储引擎中页的大小为16KB，一般表的主键类型为INT(占用4个字节)或BIGINT(占用8个字节)，指针类型也一般为4或8个字节，也就是说一个页（B+Tree中的一个节点）中大概存储16KB/(8B+8B)=1K个键值，因为是估算，为了方便计算，这里的K取值为10^3。也就是说一个深度为3的B+Tree索引可以维护10^3 * 10^3 * 10^3 = 10亿条记录。（这里假定一个数据页也存储10^3条行记录数据了）</p>
<p>实际情况中每个节点可能不能填充满，因此在数据库中，<code>B+Tree的高度一般都在2~4层</code>。MySQL的InnoDB存储引擎在设计时是将根节点常驻内存的，也就是说查找某一键值的行记录时最多只需要1~3次磁盘I/O操作</p>
</blockquote>
<p><strong>思考题：为什么说B+树比B-树更适合实际应用中操作系统的文件索引和数据库索引？</strong></p>
<blockquote>
<p>1.B+树的磁盘读写代价更低</p>
<p>B+树的内部结点并没有指向关键字具体信息的指针。因此其内部结点相对于B树更小。如果把所有同一内部结点的关键字存放在同一盘块中，那么盘块所能容纳的关键字数量也越多。一次性读入内存中的需要查找的关键字也就越多。相对来说IO读写次数也就降低了。</p>
<p>2、B+树的查询效率更加稳定</p>
<p>由于非终结点并不是最终指向文件内容的节点，而只是叶子结点中关键字的索引。所有任何关键字的查找必须走一条从根结点到叶子结点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当。</p>
</blockquote>
<p><strong>思考题：Hash索引与B+树索引的区别</strong></p>
<blockquote>
<p>1、Hash索引<code>不能进行范围查询</code>，而B+树可以。这是因为Hash索引指向的数据是无序的，而B+树的叶子节点是个有序的链表。</p>
<p>2、Hash索引<code>不支持联合索引的最左侧原则</code>（即联合索引的部分索引无法使用），而B+树可以。对于联合索引来说，Hash索引在计算Hash值的时候是将索引键合并后再一起计算Hash值，所以不会针对每个索引单独计算Hash值。因此如果用到联合索引的一个或者几个索引时，联合索引无法被利用。</p>
<p>3、Hash索引<code>不支持 ORDER BY 排序</code>，因为Hash索引指向的数据是无序的，因此无法起到排序优化的作用，而B+树索引数据是有序的，可以起到对该字段ORDER BY 排序优化的作用。同理，我们也无法用Hash索引进行<code>模糊查询</code>，而B+树使用LIKE进行模糊查询的时候，LIKE后面后模糊查询（比如%结尾）的话就可以起到优化作用。</p>
<p>4、<code>InnoDB不支持哈希索引</code></p>
</blockquote>
<h3 id="第07章-InnoDB数据存储结构"><a href="#第07章-InnoDB数据存储结构" class="headerlink" title="第07章 InnoDB数据存储结构"></a>第07章 InnoDB数据存储结构</h3><h4 id="1-数据库的存储结构：页"><a href="#1-数据库的存储结构：页" class="headerlink" title="1. 数据库的存储结构：页"></a>1. 数据库的存储结构：页</h4><p>索引结构给我们提供了高效的索引方式，不过索引信息以及数据记录都保存在文件上的，确切说是存储在页结构中。另一方面，索引是在存储引擎中实现的，MySQL服务器上的<code>存储引擎</code>负责对表中数据的读取和写入工作。不同存储引擎中<code>存放的格式</code>一般不同的，甚至有的存储引擎比如Memory都不用磁盘来存储数据。</p>
<p>由于<code>InnoDB</code>是MySQL的<code>默认存储引擎</code>，所以本章剖析InooDB存储引擎的数据存储结构。</p>
<h5 id="1-1-磁盘与内存交互基本单位：页"><a href="#1-1-磁盘与内存交互基本单位：页" class="headerlink" title="1.1 磁盘与内存交互基本单位：页"></a>1.1 磁盘与内存交互基本单位：页</h5><p>InnoDB将数据划分为若干个页，InnoDB中页的大小默认为<code>16KB</code>。</p>
<p>以<code>页</code>作为磁盘和内存之间交互的基本单位，也就是一次最少从磁盘中读取16KB的内容到内存中，一次最少把内存中的16KB内容刷新到磁盘中。也就是说，<strong>在数据库中，不论读一行，还是读多行，都是将这些行所在的页进行加载。也就是说，数据库管理存储空间的基本单位是页（Page），数据库I/O操作的最小单位是页。</strong>一个页中可以存储多个行记录。</p>
<blockquote>
<p>记录是按照行来存储的，但是数据库的读取并不以行为单位，否则一次读取（也就是一次I/O操作）只能处理一行数据，效率会非常低。</p>
</blockquote>
<h5 id="1-2-页结构概述"><a href="#1-2-页结构概述" class="headerlink" title="1.2 页结构概述"></a>1.2 页结构概述</h5><p>页a、页b、页c…页n这些页可以<code>不在物理结构上相连</code>，只要通过<code>双向链表</code>相关联即可。每个数据页中的记录会按照主键值从小到大的顺序组成一个<code>单向链表</code>，每个数据页都会为存储在它里边的记录生成一个<code>页目录</code>，在通过主键查找某条记录的时候可以在页目录中<code>使用二分法</code>快速定位到对应的槽，然后再遍历该槽对应的分组中的记录即可快速找到指定的记录。</p>
<h5 id="1-3-页的上层结构"><a href="#1-3-页的上层结构" class="headerlink" title="1.3 页的上层结构"></a>1.3 页的上层结构</h5><p><img src="https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202203301838071.png" alt="image-20220330183814954"></p>
<p>区（Extent）是比页大一级的存储结构，在InnoDB存储引擎中，一个区会分配<code>64个连续的页</code>。因为InnoDB中的页大小默认是16KB，所以一个区的大小是64*16KB=<code>1MB</code>。</p>
<p>段（Segment）由一个或多个区组成，区在文件系统是一个连续分配的空间（在InnoDB中是连续的64个页），不过在段中不要求区与区之间是相邻的。<code>段是数据库中的分配单位，不同类型的数据库对象以不同的段形式存在。</code>当我们创建数据表、索引的时候，就会相应创建对应的段，比如创建一张表时会创建一个表段，创建一个索引时会创建一个索引段。</p>
<p>表空间（Tablespace）是一个逻辑容器，表空间存储的对象是段，在一个表空间中可以有一个或多个段，但是一个段只能属于一个表空间。数据库由一个或多个表空间组成，表空间从管理上可以划分为<code>系统表空间</code>、<code>用户表空间</code>、<code>撤销表空间</code>、<code>临时表空间</code>等。</p>
<h4 id="2-页的内部结构"><a href="#2-页的内部结构" class="headerlink" title="2. 页的内部结构"></a>2. 页的内部结构</h4><h5 id="2-1-第1部分：文件头部和文件尾部"><a href="#2-1-第1部分：文件头部和文件尾部" class="headerlink" title="2.1 第1部分：文件头部和文件尾部"></a>2.1 第1部分：文件头部和文件尾部</h5><h6 id="2-1-1-File-Header（文件头部）（38字节）"><a href="#2-1-1-File-Header（文件头部）（38字节）" class="headerlink" title="2.1.1 File Header（文件头部）（38字节）"></a>2.1.1 File Header（文件头部）（38字节）</h6><p><strong>作用</strong>：<br>描述各种页的通用信息。（比如页的编号、其上一页、下一页是谁等）</p>
<p><strong>大小</strong>：38字节</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>占用空间大小</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>FIL_PAGE_SPACE_OR_CHKSUM</code></td>
<td><code>4</code>字节</td>
<td>页的校验和（checksum值）</td>
</tr>
<tr>
<td><code>FIL_PAGE_OFFSET</code></td>
<td><code>4</code>字节</td>
<td>页号</td>
</tr>
<tr>
<td><code>FIL_PAGE_PREV</code></td>
<td><code>4</code>字节</td>
<td>上一个页的页号</td>
</tr>
<tr>
<td><code>FIL_PAGE_NEXT</code></td>
<td><code>4</code>字节</td>
<td>下一个页的页号</td>
</tr>
<tr>
<td>FIL_PAGE_LSN</td>
<td><code>8</code>字节</td>
<td>页面被最后修改时对应的日志序列位置</td>
</tr>
<tr>
<td><code>FIL_PAGE_TYPE</code></td>
<td><code>2</code>字节</td>
<td>该页的类型</td>
</tr>
<tr>
<td>FIL_PAGE_FILE_FLUSH_LSN</td>
<td><code>8</code>字节</td>
<td>仅在系统表空间的一个页中定义，代表文件至少被刷新到了对应的LSN值</td>
</tr>
<tr>
<td><code>FIL_PAGE_ARCH_LOG_NO_OR_SPACE_ID</code></td>
<td><code>4</code>字节</td>
<td>页属于哪个表空间</td>
</tr>
</tbody></table>
<ul>
<li><code>FIL_PAGE_OFFSET（4字节）</code>：每一个页都有一个单独的页号，就跟你的身份证号码一样，InnoDB通过页号可以唯一定位一个页。</li>
<li><code>FIL_PAGE_TYPE（2字节）</code>：这个代表当前页的类型。</li>
</ul>
<table>
<thead>
<tr>
<th>类型名称</th>
<th>十六进制</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>FIL_PAGE_TYPE_ALLOCATED</td>
<td>0x0000</td>
<td>最新分配，还没有使用</td>
</tr>
<tr>
<td><code>FIL_PAGE_UNDO_LOG</code></td>
<td>0x0002</td>
<td>Undo日志页</td>
</tr>
<tr>
<td>FIL_PAGE_INODE</td>
<td>0x0003</td>
<td>段信息节点</td>
</tr>
<tr>
<td>FIL_PAGE_IBUF_FREE_LIST</td>
<td>0x0004</td>
<td>Insert Buffer空闲列表</td>
</tr>
<tr>
<td>FIL_PAGE_IBUF_BITMAP</td>
<td>0x0005</td>
<td>Insert Buffer位图</td>
</tr>
<tr>
<td><code>FIL_PAGE_TYPE_SYS</code></td>
<td>0x0006</td>
<td>系统页</td>
</tr>
<tr>
<td>FIL_PAGE_TYPE_TRX_SYS</td>
<td>0x0007</td>
<td>事务系统数据</td>
</tr>
<tr>
<td>FIL_PAGE_TYPE_FSP_HDR</td>
<td>0x0008</td>
<td>表空间头部信息</td>
</tr>
<tr>
<td>FIL_PAGE_TYPE_XDES</td>
<td>0x0009</td>
<td>扩展描述页</td>
</tr>
<tr>
<td>FIL_PAGE_TYPE_BLOB</td>
<td>0x000A</td>
<td>溢出页</td>
</tr>
<tr>
<td><code>FIL_PAGE_INDEX</code></td>
<td>0x45BF</td>
<td>索引页，也就是我们所说的<code>数据页</code></td>
</tr>
</tbody></table>
<ul>
<li><code>FIL_PAGE_PREV（4字节）和FIL_PAGE_NEXT（4字节）</code>：InnoDB都是以页为单位存放数据的，如果数据分散到多个不连续的页中存储的话需要把这些页关联起来，FIL_PAGE_PREV和FIL_PAGE_NEXT就分别代表本页的上一个和下一个页的页号。这样通过建立一个双向链表把许许多多的页就都串联起来了，保证这些页之间<strong>不需要是物理上的连续，而是逻辑上的连续。</strong></li>
<li><code>FIL_PAGE_SPACE_OR_CHKSUM（4字节）</code>：代表当前页面的校验和（checksum）。文件头部和文件尾部都有属性：FIL_PAGE_SPACE_OR_CHKSUM</li>
</ul>
<p><strong>作用：</strong></p>
<p>InnoDB存储引擎以页为单位把数据加载到内存中处理，如果该页中的数据在内存中被修改了，那么<code>在修改后的某个时间需要把数据同步到磁盘中。</code>但是在同步了一半的时候断电了，造成了该页传输的不完整。</p>
<p>为了检测一个页是否完整（也就是在同步的时候有没有发生只同步一半的尴尬情况），这时可以通过文件尾的校验和（checksum 值）与文件头的校验和做比对，如果两个值不相等则证明页的传输有问题，需要重新进行传输，否则认为页的传输已经完成。</p>
<ul>
<li><code>FIL_PAGE_LSN（8字节）</code>：页面被最后修改时对应的日志序列位置（英文名是：Log Sequence Number）</li>
</ul>
<h6 id="2-1-2-File-Trailer（文件尾部）（8字节）"><a href="#2-1-2-File-Trailer（文件尾部）（8字节）" class="headerlink" title="2.1.2 File Trailer（文件尾部）（8字节）"></a>2.1.2 File Trailer（文件尾部）（8字节）</h6><ul>
<li>前4个字节代表页的校验和：这个部分是和File Header中的校验和相对应的。</li>
<li>后4个字节代表页面被最后修改时对应的日志序列位置（LSN）：这个部分也是为了校验页的完整性的，如果首部和尾部的LSN值校验不成功的话，就说明同步过程出现了问题。</li>
</ul>
<h5 id="2-2-第2部分：空闲空间、用户记录和最小最大记录"><a href="#2-2-第2部分：空闲空间、用户记录和最小最大记录" class="headerlink" title="2.2 第2部分：空闲空间、用户记录和最小最大记录"></a>2.2 第2部分：空闲空间、用户记录和最小最大记录</h5><h6 id="2-2-1-Free-Space-空闲空间"><a href="#2-2-1-Free-Space-空闲空间" class="headerlink" title="2.2.1 Free Space (空闲空间)"></a>2.2.1 Free Space (空闲空间)</h6><p>我们自己存储的记录会按照指定的<code>行格式</code>存储到<code>User Records</code>部分。但是在一开始生成页的时候，其实并没有User Records这个部分，<code>每当我们插入一条记录，都会从Free Space部分，也就是尚未使用的存储空间中申请一个记录大小的空间划分到User Records部分</code>，当Free Space部分的空间全部被User Records部分替代掉之后，也就意味着这个页使用完了，如果还有新的记录插入的话，就需要去<code>申请新的页</code>了。</p>
<h6 id="2-2-2-User-Records-用户记录"><a href="#2-2-2-User-Records-用户记录" class="headerlink" title="2.2.2 User Records (用户记录)"></a>2.2.2 User Records (用户记录)</h6><p>User Records中的这些记录按照<code>指定的行格式</code>一条一条摆在User Records部分，相互之间形成<code>单链表</code>。</p>
<h6 id="2-2-3-Infimum-Supremum（最小最大记录）"><a href="#2-2-3-Infimum-Supremum（最小最大记录）" class="headerlink" title="2.2.3 Infimum + Supremum（最小最大记录）"></a>2.2.3 Infimum + Supremum（最小最大记录）</h6><p><strong>记录可以比较大小吗</strong>？<br>是的，记录可以比大小，对于一条完整的记录来说，比较记录的大小就是<code>比较主键</code>的大小。比方说我们插入的4行记录的主键值分别是：1、2、3、4，这也就意味着这4条记录是从小到大依次递增。</p>
<p>InnoDB规定的最小记录与最大记录这两条记录的构造十分简单，都是由5字节大小的记录头信息和8字节大小的一个固定的部分组成的。</p>
<p><img src="https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202203301913664.png" alt="image-20220330191335574"></p>
<p>这两条记录<code>不是我们自己定义的记录</code>，所以它们并不存放在页的User Records部分，他们被单独放在一个称为Infimum + Supremum的部分</p>
<p><img src="https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202203301914167.png" alt="image-20220330191446070"></p>
<h5 id="2-3-第3部分：页目录和页面头部"><a href="#2-3-第3部分：页目录和页面头部" class="headerlink" title="2.3 第3部分：页目录和页面头部"></a>2.3 第3部分：页目录和页面头部</h5><h6 id="2-3-1-Page-Directory（页目录）"><a href="#2-3-1-Page-Directory（页目录）" class="headerlink" title="2.3.1 Page Directory（页目录）"></a>2.3.1 Page Directory（页目录）</h6><p><strong>为什么需要页目录</strong>？<br>在页中，记录是以<code>单向链表</code>的形式进行存储的。单向链表的特点就是插入、删除非常方便，但是<code>检索效率不高</code>，最差的情况下需要遍历链表上的所有节点才能完成检索。因此在页结构中专门设计了页目录这个模块，<code>专门给记录做一个目录</code>，通过<code>二分查找法</code>的方式进行检索，提升效率。</p>
<p><strong>页目录，二分法查找</strong></p>
<ol>
<li>将所有的记录<code>分成几个组</code>，这些记录包括最小记录和最大记录，但不包括标记为“已删除”的记录。</li>
<li>第 1 组，也就是最小记录所在的分组只有 1 个记录；<br> 最后一组，就是最大记录所在的分组，会有 1-8 条记录；<br> 其余的组记录数量在 4-8 条之间。<br> 这样做的好处是，除了第 1 组（最小记录所在组）以外，其余组的记录数会<code>尽量平分</code>。</li>
<li>在每个组中最后一条记录的头信息中会存储该组一共有多少条记录，作为 n_owned 字段。</li>
<li><code>页目录用来存储每组最后一条记录的地址偏移量</code>，这些地址偏移量会按照<code>先后顺序存储</code>起来，每组的地址偏移量也被称之为<code>槽（slot）</code>，每个槽相当于指针指向了不同组的最后一个记录。</li>
</ol>
<p><strong>举例：</strong></p>
<p>现在的page_demo表中正常的记录共有6条，InnoDB会把它们分成两组，第一组中只有一个最小记录，第二组中是剩余的5条记录。如下图：</p>
<p><img src="https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202203301921631.png" alt="image-20220330192130497"></p>
<p>从这个图中我们需要注意这么几点：</p>
<ul>
<li>现在页目录部分中有两个槽，也就意味着我们的记录被分成了两个组，槽1中的值是112，代表最大记录的地址偏移量（就是从页面的0字节开始数，数112个字节）；槽0中的值是99，代表最小记录的地址偏移量。</li>
<li>注意最小和最大记录的头信息中的n_owned属性<ul>
<li>最小记录的n_owned值为1，这就代表着以最小记录结尾的这个分组中只有1条记录，也就是最小记录本身。</li>
<li>最大记录的n_owned值为5，这就代表着以最大记录结尾的这个分组中只有5条记录，包括最大记录本身还有我们自己插入的4条记录。</li>
</ul>
</li>
</ul>
<p>用箭头指向的方式替代数字，这样更易于我们理解，修改后如下</p>
<p><img src="https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202203301924874.png" alt="image-20220330192413776"></p>
<p><strong>为什么最小记录的n_owned值为1，而最大记录的n_owned值为5呢？</strong></p>
<p>InnoDB规定：对于最小记录所在的分组只能有1条记录，最大记录所在的分组拥有的记录条数只能在1<del>8条之间，剩下的分组中记录的条数范围只能在是 4</del>8 条之间。</p>
<p>分组是按照下边的步骤进行的：</p>
<ul>
<li>初始情况下一个数据页里只有最小记录和最大记录两条记录，它们分属于两个分组。</li>
<li>之后每插入一条记录，都会从页目录中找到主键值比本记录的主键值大并且差值最小的槽，然后把该槽对应的记录的n_owned值加1，表示本组内又添加了一条记录，直到该组中的记录数等于8个。</li>
<li>在一个组中的记录数等于8个后再插入一条记录时，会将组中的记录拆分成两个组，一个组中4条记录，另一个5条记录。这个过程会在页目录中新增一个槽来记录这个新增分组中最大的那条记录的偏移量。</li>
</ul>
<h6 id="2-3-2-Page-Header（页面头部）"><a href="#2-3-2-Page-Header（页面头部）" class="headerlink" title="2.3.2 Page Header（页面头部）"></a>2.3.2 Page Header（页面头部）</h6><p>为了能得到一个数据页中存储的记录的状态信息，比如本页中已经存储了多少条记录，第一条记录的地址是什么，页目录中存储了多少个槽等等，特意在页中定义了一个叫Page Header的部分，这个部分占用固定的56个字节，专门存储各种状态信息。</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>占用空间大小</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>PAGE_N_DIR_SLOTS</td>
<td>2字节</td>
<td>在页目录中的槽数量</td>
</tr>
<tr>
<td>PAGE_HEAP_TOP</td>
<td>2字节</td>
<td>还未使用的空间最小地址，也就是说从该地址之后就是<code>Free Space</code></td>
</tr>
<tr>
<td>PAGE_N_HEAP</td>
<td>2字节</td>
<td>本页中的记录的数量（包括最小和最大记录以及标记为删除的记录）</td>
</tr>
<tr>
<td>PAGE_FREE</td>
<td>2字节</td>
<td>第一个已经标记为删除的记录的记录地址（各个已删除的记录通过<code>next_record</code>也会组成一个单链表，这个单链表中的记录可以被重新利用）</td>
</tr>
<tr>
<td>PAGE_GARBAGE</td>
<td>2字节</td>
<td>已删除记录占用的字节数</td>
</tr>
<tr>
<td>PAGE_LAST_INSERT</td>
<td>2字节</td>
<td>最后插入记录的位置</td>
</tr>
<tr>
<td>PAGE_DIRECTION</td>
<td>2字节</td>
<td>记录插入的方向</td>
</tr>
<tr>
<td>PAGE_N_DIRECTION</td>
<td>2字节</td>
<td>一个方向连续插入的记录数量</td>
</tr>
<tr>
<td>PAGE_N_RECS</td>
<td>2字节</td>
<td>该页中记录的数量（不包括最小和最大记录以及被标记为删除的记录）</td>
</tr>
<tr>
<td>PAGE_MAX_TRX_ID</td>
<td>8字节</td>
<td>修改当前页的最大事务ID，该值仅在二级索引中定义</td>
</tr>
<tr>
<td>PAGE_LEVEL</td>
<td>2字节</td>
<td>当前页在B+树中所处的层级</td>
</tr>
<tr>
<td>PAGE_INDEX_ID</td>
<td>8字节</td>
<td>索引ID，表示当前页属于哪个索引</td>
</tr>
<tr>
<td>PAGE_BTR_SEG_LEAF</td>
<td>10字节</td>
<td>B+树叶子段的头部信息，仅在B+树的Root页定义</td>
</tr>
<tr>
<td>PAGE_BTR_SEG_TOP</td>
<td>10字节</td>
<td>B+树非叶子段的头部信息，仅在B+树的Root页定义</td>
</tr>
</tbody></table>
<h4 id="3-InnoDB行格式（或记录格式）"><a href="#3-InnoDB行格式（或记录格式）" class="headerlink" title="3. InnoDB行格式（或记录格式）"></a>3. InnoDB行格式（或记录格式）</h4><h5 id="3-1-指定行格式的语法"><a href="#3-1-指定行格式的语法" class="headerlink" title="3.1 指定行格式的语法"></a>3.1 指定行格式的语法</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE 表名 (列的信息) ROW_FORMAT&#x3D;行格式名称</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ALTER TABLE 表名 ROW_FORMAT&#x3D;行格式名称</span><br></pre></td></tr></table></figure>

<h5 id="3-2-COMPACT行格式"><a href="#3-2-COMPACT行格式" class="headerlink" title="3.2 COMPACT行格式"></a>3.2 COMPACT行格式</h5><p>在MySQL 5.1版本中，默认设置为Compact行格式。一条完整的记录其实可以被分为记录的额外信息和记录的真实数据两大部分。</p>
<p><img src="https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202203301939611.png" alt="image-20220330193949517"></p>
<h6 id="3-2-1-变长字段长度列表"><a href="#3-2-1-变长字段长度列表" class="headerlink" title="3.2.1 变长字段长度列表"></a>3.2.1 变长字段长度列表</h6><p>MySQL支持一些变长的数据类型，比如VARCHAR(M)、VARBINARY(M)、TEXT类型，BLOB类型，这些数据类型修饰列称为<code>变长字段</code>，变长字段中存储多少字节的数据不是固定的，所以我们在存储真实数据的时候需要顺便把这些数据占用的字节数也存起来。<code>在Compact行格式中，把所有变长字段的真实数据占用的字节长度都存放在记录的开头部位，从而形成一个变长字段长度列表。</code></p>
<blockquote>
<p> 注意：这里面存储的变长长度和字段顺序是反过来的。比如两个varchar字段在表结构的顺序是a(10)，b(15)。那么在变长字段长度列表中存储的长度顺序就是15，10，是反过来的。</p>
</blockquote>
<h6 id="3-2-2-NULL值列表"><a href="#3-2-2-NULL值列表" class="headerlink" title="3.2.2 NULL值列表"></a>3.2.2 NULL值列表</h6><p>Compact行格式会把可以为NULL的列统一管理起来，存在一个标记为NULL值列表中。如果表中没有允许存储 NULL 的列，则 NULL值列表也不存在了。<br><strong>为什么定义NULL值列表？</strong><br>之所以要存储NULL是因为数据都是需要对齐的，如果<code>没有标注出来NULL值的位置</code>，就有可能在查询数据的时候<code>出现混乱</code>。如果使用<code>一个特定的符号</code>放到相应的数据位表示空置的话，虽然能达到效果，但是这样很浪费空间，所以直接就在行数据得头部开辟出一块空间专门用来记录该行数据哪些是非空数据，哪些是空数据，格式如下：</p>
<ol>
<li>二进制位的值为1时，代表该列的值为NULL。</li>
<li>二进制位的值为0时，代表该列的值不为NULL。</li>
</ol>
<blockquote>
<p>注意：同样顺序也是反过来存放的</p>
</blockquote>
<h6 id="3-2-3-记录头信息（5字节）"><a href="#3-2-3-记录头信息（5字节）" class="headerlink" title="3.2.3 记录头信息（5字节）"></a>3.2.3 记录头信息（5字节）</h6><p><img src="https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202203301945235.png" alt="image-20220330194534127"></p>
<table>
<thead>
<tr>
<th>名称</th>
<th>大小（单位：bit）</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>预留位1</code></td>
<td>1</td>
<td>没有使用</td>
</tr>
<tr>
<td><code>预留位2</code></td>
<td>1</td>
<td>没有使用</td>
</tr>
<tr>
<td><code>delete_mask</code></td>
<td>1</td>
<td>标记该记录是否被删除</td>
</tr>
<tr>
<td><code>mini_rec_mask</code></td>
<td>1</td>
<td>B+树的每层非叶子节点中的最小记录都会添加该标记</td>
</tr>
<tr>
<td><code>n_owned</code></td>
<td>4</td>
<td>表示当前记录拥有的记录数</td>
</tr>
<tr>
<td><code>heap_no</code></td>
<td>13</td>
<td>表示当前记录在记录堆的位置信息</td>
</tr>
<tr>
<td><code>record_type</code></td>
<td>3</td>
<td>表示当前记录的类型，<code>0</code>表示普通记录，<code>1</code>表示B+树非叶子节点记录，<code>2</code>表示最小记录，<code>3</code>表示最大记录</td>
</tr>
<tr>
<td><code>next_record</code></td>
<td>16</td>
<td>表示下一条记录的相对位置</td>
</tr>
</tbody></table>
<ul>
<li><code>delete_mask</code>：这个属性标记着当前记录是否被删除，占用1个二进制位。<ul>
<li>值为0：代表记录并没有被删除</li>
<li>值为1：代表记录被删除掉了</li>
</ul>
</li>
</ul>
<p><strong>被删除的记录为什么还在页中存储呢？</strong><br>你以为它删除了，可它还在真实的磁盘上。这些被删除的记录之所以不立即从磁盘上移除，是因为移除它们之后其他的记录在磁盘上需要<code>重新排列，导致性能消耗</code>。所以只是打一个删除标记而已，所有被删除掉的记录都会组成一个所谓的<code>垃圾链表</code>，在这个链表中的记录占用的空间称之为<code>可重用空间</code>，之后如果有新记录插入到表中的话，可能把这些被删除的记录占用的存储空间覆盖掉。</p>
<ul>
<li><code>min_rec_mask</code>：B+树的每层非叶子节点中的最小记录都会添加该标记，min_rec_mask值为1。我们自己插入的四条记录的min_rec_mask值都是0，意味着它们都不是B+树的非叶子节点中的最小记录。</li>
<li><code>record_type</code>：这个属性表示当前记录的类型，一共有4种类型的记录：<ul>
<li>0：表示普通记录</li>
<li>1：表示B+树非叶节点记录</li>
<li>2：表示最小记录</li>
<li>3：表示最大记录</li>
</ul>
</li>
<li><code>heap_no</code>：这个属性表示当前记录在本页中的位置。</li>
</ul>
<p><strong>怎么不见heap_no值为0和1的记录呢</strong>？<br>MySQL会自动给每个页里加了两个记录，由于这两个记录并不是我们自己插入的，所以有时候也称为<code>伪记录</code>或者<code>虚拟记录</code>。这两个伪记录一个代表<code>最小记录</code>，一个代表<code>最大记录</code>。最小记录和最大记录的heap_no值分别是0和1，也就是说它们的位置最靠前</p>
<ul>
<li><code>n_owned</code>：页目录中每个组中最后一条记录的头信息中会存储该组一共有多少条记录，作为 n_owned 字段</li>
<li><code>next_record</code>：记录头信息里该属性非常重要，它表示从当前记录的真实数据到下一条记录的真实数据的<code>地址偏移量</code>。</li>
</ul>
<h6 id="3-2-4-记录的真实数据"><a href="#3-2-4-记录的真实数据" class="headerlink" title="3.2.4 记录的真实数据"></a>3.2.4 记录的真实数据</h6><table>
<thead>
<tr>
<th>列名</th>
<th>是否必须</th>
<th>占用空间</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>row_id</td>
<td>否</td>
<td>6字节</td>
<td>行ID，唯一标识一条记录</td>
</tr>
<tr>
<td>transaction_id</td>
<td>是</td>
<td>6字节</td>
<td>事务ID</td>
</tr>
<tr>
<td>roll_pointer</td>
<td>是</td>
<td>7字节</td>
<td>回滚指针</td>
</tr>
</tbody></table>
<p>一个表没有手动定义主键，则会选取一个Unique键作为主键，如果连Unique键都没有定义的话，则会为表默认添加一个名为row_id的隐藏列作为主键。所以row_id是在没有自定义主键以及Unique键的情况下才会存在的。</p>
<h5 id="3-3-Dynamic和Compressed行格式"><a href="#3-3-Dynamic和Compressed行格式" class="headerlink" title="3.3 Dynamic和Compressed行格式"></a>3.3 Dynamic和Compressed行格式</h5><p>我们可以知道一个页的大小一般是16KB，也就是16384字节，而一个VARCHAR(M)类型的列就最多可以存储65533个字节，这样就可能出现一个页存放不了一条记录，这种现象称为<code>行溢出</code></p>
<p>在Compact和Reduntant行格式中，对于占用存储空间非常大的列，在记录的真实数据处只会存储该列的一部分数据，把剩余的数据分散存储在几个其他的页中进行<code>分页存储</code>，然后记录的真实数据处用20个字节存储指向这些页的地址（当然这20个字节中还包括这些分散在其他页面中的数据的占用的字节数），从而可以找到剩余数据所在的页。这称为<code>页的扩展</code>。</p>
<p>在MySQL 8.0中，默认行格式就是Dynamic，Dynamic、Compressed行格式和Compact行格式挺像，只不过在处理行溢出数据时有分歧</p>
<ul>
<li>Compressed和Dynamic两种记录格式对于存放在BLOB中的数据采用了完全的行溢出的方式。如图，在数据页中只存放20个字节的指针（溢出页的地址），实际的数据都存放在Off Page（溢出页）中。</li>
<li>Compact和Redundant两种格式会在记录的真实数据处存储一部分数据（存放768个前缀字节）。</li>
</ul>
<h4 id="4-区、段和碎片区"><a href="#4-区、段和碎片区" class="headerlink" title="4. 区、段和碎片区"></a>4. 区、段和碎片区</h4><h5 id="4-1-为什么要有区？"><a href="#4-1-为什么要有区？" class="headerlink" title="4.1 为什么要有区？"></a>4.1 为什么要有区？</h5><p><code>B+</code>树的每一层中的页都会形成一个双向链表，如果是以<code>页为单位</code>来分配存储空间的话，双向链表相邻的两个页之间的<code>物理位置可能离得非常远</code>。我们介绍B+树索引的使用场景的时候特别提到范围查询只需要定位到最左边的记录和最右边的记录，然后沿着双向链表一直扫描就可以了，而如果链表中相邻的两个页物理位置离得非常远，就是所谓的<code>随机I/O</code>。再一次强调，磁盘的速度和内存的速度差了好几个数量级，<code>随机I/O是非常慢</code>的，所以我们应该尽量让链表中相邻的页的物理位置也相邻，这样进行范围查询的时候才可以使用所谓的<code>顺序I/O</code>。</p>
<p>引入<code>区</code>的概念，一个区就是物理位置上连续的<code>64个页</code>。因为InnoDB中的页的大小默认是16KB，所以一个区的大小是64*16KB=<code>1MB</code>。在表中<code>数据量大</code>的时候，为某个索引分配空间的时候就不再按照页的单位分配了，而是按照<code>区为单位分配</code>，甚至在表中的数据特别多的时候，可以一次性分配多个连续的区。虽然可能造成<code>一点点空间的浪费</code>（数据不足以填充满整个区），但是从性能角度看，可以消除很多的随机I/O，<code>功大于过</code>！</p>
<h5 id="4-2-为什么要有段？"><a href="#4-2-为什么要有段？" class="headerlink" title="4.2 为什么要有段？"></a>4.2 为什么要有段？</h5><p>对于范围查询，其实是对B+树叶子节点中的记录进行顺序扫描，而如果不区分叶子节点和非叶子节点，统统把节点代表的页面放到申请到的区中的话，进行范围扫描的效果就大打折扣了。所以InnoDB对B+树的<code>叶子节点</code>和<code>非叶子节点</code>进行了区别对待，也就是说叶子节点有自己独有的区，非叶子节点也有自己独有的区。存放叶子节点的区的集合就算是一个<code>段（segment）</code>，存放非叶子节点的区的集合也算是一个段。也就是说一个索引会生成2个段，一个<code>叶子节点段</code>，一个<code>非叶子节点段</code>。</p>
<p>除了索引的叶子节点段和非叶子节点段之外，InnoDB中还有为存储一些特殊的数据而定义的段，比如回滚段。所以，常见的段有<code>数据段</code>、<code>索引段</code>、<code>回滚段</code>。数据段即为B+树的叶子节点，索引段即为B+树的非叶子节点。</p>
<p>在InnoDB存储引擎中，对段的管理都是由引擎自身所完成，DBA不能也没有必要对其进行控制。这从一定程度上简化了DBA对于段的管理。</p>
<p>段其实不对应表空间中的某一个连续的物理区域，而是一个逻辑上的概念，由若干个零散的页面以及一些完整的区组成。</p>
<h5 id="4-3-为什么要有碎片区？"><a href="#4-3-为什么要有碎片区？" class="headerlink" title="4.3 为什么要有碎片区？"></a>4.3 为什么要有碎片区？</h5><p>默认情况下，一个使用InnoDB存储引擎的表只有一个聚簇索引，一个索引会生成2个段，而段是以区为单位申请存储空间的，一个区默认占用1M（64*16KB=1024KB）存储空间，所以<strong>默认情况下一个只存在几条记录的小表也需要2M的存储空间么？</strong>以后每次添加一个索引都要多申请2M的存储空间么？这对于存储记录比较少的表简直是天大的浪费。这个问题的症结在于到现在为止我们介绍的区都是非常<code>纯粹</code>的，也就是一个区被整个分配给某一个段，或者说区中的所有页面都是为了存储同一个段的数据而存在的，即使段的数据填不满区中所有的页面，那余下的页面也不能挪作他用。</p>
<p>为了考虑以完整的区为单位分配给某个段对于<code>数据量较小</code>的表太浪费存储空间的这种情况，InnoDB提出了一个<code>碎片（fragment）区</code>的概念。在一个碎片区中，并不是所有的页都是为了存储同一个段的数据而存在的，而是碎片区中的页可以用于不同的目的，比如有些页面用于段A，有些页面用于段B，有些页甚至哪个段都不属于。<code>碎片区直属于表空间</code>，并不属于任何一个段。</p>
<p>所以此后为某个段分配存储空间的策略是这样的：</p>
<ul>
<li>在刚开始向表中插入数据的时候，段是从某个碎片区以单个页面为单位来分配存储空间的。</li>
<li>当某个段已经占用了<code>32个碎片区</code>页面之后，就会申请以完整的区为单位来分配存储空间。</li>
</ul>
<p>所以现在段不能仅定义为是某些区的集合，更精确的应该是<code>某些零散的页面</code>已经<code>一些完整的区</code>的集合。</p>
<h5 id="4-4-区的分类"><a href="#4-4-区的分类" class="headerlink" title="4.4 区的分类"></a>4.4 区的分类</h5><p>区大体上可以分为4种类型：</p>
<ul>
<li><code>空闲的区(FREE)</code>：现在还没有用到这个区中的任何页面。</li>
<li><code>有剩余空间的碎片区(FREE_FRAG)</code>：表示碎片区中还有可用的页面。</li>
<li><code>没有剩余空间的碎片区(FULL_FRAG)</code>：表示碎片区中的所有页面都被使用，没有空闲页面。</li>
<li><code>附属于某个段的区(FSEG)</code>：每一索引都可以分为叶子节点段和非叶子节点段</li>
</ul>
<p>处于<code>FREE</code>、<code>FREE_FRAG</code>以及<code>FULL_FRAG</code>这三种状态的区都是独立的，直属于表空间。而处于<code>FSEG</code>状态的区是附属于某个段的。</p>
<h3 id="第08章-索引的创建与设计原则"><a href="#第08章-索引的创建与设计原则" class="headerlink" title="第08章 索引的创建与设计原则"></a>第08章 索引的创建与设计原则</h3><h4 id="1-索引的声明与使用"><a href="#1-索引的声明与使用" class="headerlink" title="1. 索引的声明与使用"></a><strong>1.</strong> <strong>索引的声明与使用</strong></h4><h5 id="1-1-索引的分类"><a href="#1-1-索引的分类" class="headerlink" title="1.1 索引的分类"></a><strong>1.1</strong> <strong>索引的分类</strong></h5><ul>
<li>从<code>功能逻辑</code>上说，索引主要有 4 种，分别是普通索引、唯一索引、主键索引、全文索引。</li>
<li>按照<code>物理实现方式</code>，索引可以分为 2 种：聚簇索引和非聚簇索引。</li>
<li>按照<code>作用字段个数</code>进行划分，分成单列索引和联合索引。</li>
</ul>
<h5 id="1-2-创建索引"><a href="#1-2-创建索引" class="headerlink" title="1.2 创建索引"></a><strong>1.2</strong> <strong>创建索引</strong></h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE table_name [col_name data_type] </span><br><span class="line">[UNIQUE | FULLTEXT | SPATIAL] [INDEX | KEY] [index_name] (col_name [length]) [ASC | DESC]</span><br></pre></td></tr></table></figure>

<ul>
<li><code>UNIQUE</code>、<code>FULLTEXT</code>和<code>SPATIAL</code>为可选参数，分别表示唯一索引、全文索引和空间索引；</li>
<li><code>INDEX</code>与<code>KEY</code>为同义词，两者的作用相同，用来指定创建索引；</li>
<li><code>index_name</code>指定索引的名称，为可选参数，如果不指定，那么MySQL默认col_name为索引名；</li>
<li><code>col_name</code>为需要创建索引的字段列，该列必须从数据表中定义的多个列中选择；</li>
<li><code>length</code>为可选参数，表示索引的长度，只有字符串类型的字段才能指定索引长度；</li>
<li><code>ASC</code>或<code>DESC</code>指定升序或者降序的索引值存储。</li>
</ul>
<p><strong>1.</strong> <strong>创建普通索引</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE book( </span><br><span class="line">    book_id INT , </span><br><span class="line">    book_name VARCHAR(100), </span><br><span class="line">    authors VARCHAR(100), </span><br><span class="line">    info VARCHAR(100) , </span><br><span class="line">    comment VARCHAR(100), </span><br><span class="line">    year_publication YEAR, </span><br><span class="line">    INDEX(year_publication) </span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p><strong>2.</strong> <strong>创建唯一索引</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE test1( </span><br><span class="line">    id INT NOT NULL, </span><br><span class="line">    name varchar(30) NOT NULL, </span><br><span class="line">    UNIQUE INDEX uk_idx_id(id) </span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p><strong>3.</strong> <strong>主键索引</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE student ( </span><br><span class="line">    id INT(10) UNSIGNED AUTO_INCREMENT, </span><br><span class="line">    student_no VARCHAR(200),</span><br><span class="line">    student_name VARCHAR(200), </span><br><span class="line">    PRIMARY KEY(id) </span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 删除主键索引</span><br><span class="line">ALTER TABLE student drop PRIMARY KEY ;</span><br></pre></td></tr></table></figure>

<p><strong>4.</strong> <strong>创建单列索引</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE test2( </span><br><span class="line">    id INT NOT NULL, </span><br><span class="line">    name CHAR(50) NULL, </span><br><span class="line">    INDEX single_idx_name(name(20)) </span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p><strong>5.</strong> <strong>创建组合索引</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE test3( </span><br><span class="line">    id INT(11) NOT NULL, </span><br><span class="line">    name CHAR(30) NOT NULL, </span><br><span class="line">    age INT(11) NOT NULL, </span><br><span class="line">    info VARCHAR(255), </span><br><span class="line">    INDEX multi_idx(id,name,age) </span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p><strong>6.</strong> <strong>创建全文索引</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE &#96;papers&#96; ( </span><br><span class="line">    id&#96; int(10) unsigned NOT NULL AUTO_INCREMENT, </span><br><span class="line">    &#96;title&#96; varchar(200) DEFAULT NULL, </span><br><span class="line">    &#96;content&#96; text, PRIMARY KEY (&#96;id&#96;), </span><br><span class="line">    FULLTEXT KEY &#96;title&#96; (&#96;title&#96;,&#96;content&#96;) </span><br><span class="line">) ENGINE&#x3D;MyISAM DEFAULT CHARSET&#x3D;utf8;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT * FROM papers WHERE MATCH(title,content) AGAINST (‘查询字符串’);</span><br></pre></td></tr></table></figure>

<p><strong>7.</strong> <strong>创建空间索引</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE test5( </span><br><span class="line">    geo GEOMETRY NOT NULL, </span><br><span class="line">    SPATIAL INDEX spa_idx_geo(geo) </span><br><span class="line">) ENGINE&#x3D;MyISAM;</span><br></pre></td></tr></table></figure>

<p><strong>2.</strong> <strong>在已经存在的表上创建索引</strong></p>
<p><strong>1.</strong> <strong>使用ALTER TABLE语句创建索引</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ALTER TABLE table_name </span><br><span class="line">ADD [UNIQUE | FULLTEXT | SPATIAL] [INDEX | KEY] [index_name] (col_name[length],...) [ASC | DESC]</span><br></pre></td></tr></table></figure>

<p><strong>2.</strong> <strong>使用CREATE INDEX创建索引</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE [UNIQUE | FULLTEXT | SPATIAL] INDEX index_name </span><br><span class="line">ON table_name (col_name[length],...) [ASC | DESC]</span><br></pre></td></tr></table></figure>

<h5 id="1-3-删除索引"><a href="#1-3-删除索引" class="headerlink" title="1.3 删除索引"></a><strong>1.3</strong> <strong>删除索引</strong></h5><p><strong>1.</strong> <strong>使用ALTER TABLE删除索引</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ALTER TABLE table_name DROP INDEX index_name;</span><br></pre></td></tr></table></figure>

<p><strong>2.</strong> <strong>使用DROP INDEX语句删除索引</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DROP INDEX index_name ON table_name;</span><br></pre></td></tr></table></figure>

<h4 id="2-MySQL8-0索引新特性"><a href="#2-MySQL8-0索引新特性" class="headerlink" title="2. MySQL8.0索引新特性"></a><strong>2. MySQL8.0索引新特性</strong></h4><h5 id="2-1-支持降序索引"><a href="#2-1-支持降序索引" class="headerlink" title="2.1 支持降序索引"></a><strong>2.1</strong> <strong>支持降序索引</strong></h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE ts1(a int,b int,index idx_a_b(a,b desc));</span><br></pre></td></tr></table></figure>

<h5 id="2-2-隐藏索引"><a href="#2-2-隐藏索引" class="headerlink" title="2.2 隐藏索引"></a><strong>2.2</strong> <strong>隐藏索引</strong></h5><p>从MySQL 8.x开始支持<code>隐藏索引（invisible indexes）</code>，只需要将待删除的索引设置为隐藏索引，使查询优化器不再使用这个索引（即使使用force index（强制使用索引），优化器也不会使用该索引），确认将索引设置为隐藏索引后系统不受任何响应，就可以彻底删除索引。<code>这种通过先将索引设置为隐藏索引，再删除索引的方式就是软删除</code>。</p>
<p><strong>1.</strong> <strong>创建表时直接创建</strong> </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE tablename( </span><br><span class="line">    propname1 type1[CONSTRAINT1], </span><br><span class="line">    propname2 type2[CONSTRAINT2], </span><br><span class="line">    ……</span><br><span class="line">    propnamen typen, </span><br><span class="line">    INDEX [indexname](propname1 [(length)]) INVISIBLE </span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p><strong>2.</strong> <strong>在已经存在的表上创建</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE INDEX indexname </span><br><span class="line">ON tablename(propname[(length)]) INVISIBLE;</span><br></pre></td></tr></table></figure>

<p><strong>3.</strong> <strong>通过ALTER TABLE语句创建</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ALTER TABLE tablename </span><br><span class="line">ADD INDEX indexname (propname [(length)]) INVISIBLE;</span><br></pre></td></tr></table></figure>

<p><strong>4.</strong> <strong>切换索引可见状态</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ALTER TABLE tablename ALTER INDEX index_name INVISIBLE; #切换成隐藏索引 </span><br><span class="line">ALTER TABLE tablename ALTER INDEX index_name VISIBLE; #切换成非隐藏索引</span><br></pre></td></tr></table></figure>

<h4 id="3-索引的设计原则"><a href="#3-索引的设计原则" class="headerlink" title="3. 索引的设计原则"></a><strong>3.</strong> <strong>索引的设计原则</strong></h4><h5 id="3-1-哪些情况适合创建索引"><a href="#3-1-哪些情况适合创建索引" class="headerlink" title="3.1 哪些情况适合创建索引"></a><strong>3.1</strong> <strong>哪些情况适合创建索引</strong></h5><p><strong>1.</strong> <strong>字段的数值有唯一性的限制</strong></p>
<p>索引本身可以起到约束的作用，比如唯一索引、主键索引都可以起到唯一性约束的，因此在我们的数据表中，如果<code>某个字段是唯一的</code>，就可以直接<code>创建唯一性索引</code>，或者<code>主键索引</code>。这样可以更快速地通过该索引来确定某条记录。</p>
<blockquote>
<p>业务上具有唯一特性的字段，即使是组合字段，也必须建成唯一索引。（来源：Alibaba）</p>
<p>说明：不要以为唯一索引影响了insert速度，这个速度损耗可以忽略，但提高查找速度是明显的。</p>
</blockquote>
<p><strong>2.</strong> <strong>频繁作为</strong> <strong>WHERE</strong> <strong>查询条件的字段</strong></p>
<p>某个字段在SELECT语句的 WHERE 条件中经常被使用到，那么就需要给这个字段创建索引了。尤其是在数据量大的情况下，创建普通索引就可以大幅提升数据查询的效率。</p>
<p><strong>3.</strong> <strong>经常</strong> <strong>GROUP BY</strong> <strong>和</strong> <strong>ORDER BY</strong> <strong>的列</strong></p>
<p>索引就是让数据按照某种顺序进行存储或检索，因此当我们使用 GROUP BY 对数据进行分组查询，或者使用 ORDER BY 对数据进行排序的时候，就需要<code>对分组或者排序的字段进行索引</code>。如果待排序的列有多个，那么可以在这些列上建立<code>组合索引</code>。</p>
<p><strong>4. UPDATE、DELETE</strong> <strong>的</strong> <strong>WHERE</strong> <strong>条件列</strong></p>
<p>对数据按照某个条件进行查询后再进行 UPDATE 或 DELETE 的操作，如果对 WHERE 字段创建了索引，就能大幅提升效率。原理是因为我们需要先根据 WHERE 条件列检索出来这条记录，然后再对它进行更新或删除。<strong>如果进行更新的时候，更新的字段是非索引字段，提升的效率会更明显，这是因为非索引字段更新不需要对索引进行维护。</strong></p>
<p><strong>5.DISTINCT</strong> <strong>字段需要创建索引</strong></p>
<p>有时候我们需要对某个字段进行去重，使用 DISTINCT，那么对这个字段创建索引，也会提升查询效率。</p>
<p><strong>6.</strong> <strong>多表</strong> <strong>JOIN</strong> <strong>连接操作时，创建索引注意事项</strong></p>
<p>首先，<code>连接表的数量尽量不要超过 3 张</code>，因为每增加一张表就相当于增加了一次嵌套的循环，数量级增长会非常快，严重影响查询的效率。</p>
<p>其次，<code>对 WHERE 条件创建索引</code>，因为 WHERE 才是对数据条件的过滤。如果在数据量非常大的情况下，没有 WHERE 条件过滤是非常可怕的。</p>
<p>最后，<code>对用于连接的字段创建索引</code>，并且该字段在多张表中的<code>类型必须一致</code>。</p>
<p><strong>7.</strong> <strong>使用列的类型小的创建索引</strong> </p>
<p>我们这里所说的<code>类型大小</code>指的就是该类型表示的数据范围的大小。</p>
<ul>
<li>数据类型越小，在查询时进行的比较操作越快</li>
<li>数据类型越小，索引占用的存储空间就越少，在一个数据页内就可以<code>放下更多的记录</code>，从而减少磁盘<code>I/O</code>带来的性能损耗，也就意味着可以把更多的数据页缓存在内存中，从而加快读写效率。</li>
</ul>
<p>这个建议对于表的<code>主键来说更加适用</code>，因为不仅是聚簇索引中会存储主键值，其他所有的二级索引的节点处都会存储一份记录的主键值，如果主键使用更小的数据类型，也就意味着节省更多的存储空间和更高效的I/O。</p>
<p><strong>8.</strong> <strong>使用字符串前缀创建索引</strong></p>
<p>区分度计算公式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">count(distinct left(列名, 索引长度))&#x2F;count(*)</span><br></pre></td></tr></table></figure>

<p><strong>拓展：Alibaba《Java开发手册》</strong></p>
<p>【<code>强制</code>】在 varchar 字段上建立索引时，必须指定索引长度，没必要对全字段建立索引，根据实际文本区分度决定索引长度。</p>
<p>说明：索引的长度与区分度是一对矛盾体，一般对字符串类型数据，长度为 20 的索引，区分度会<code>高达 90% 以上</code>。</p>
<p><strong>9.</strong> <strong>区分度高(散列性高)的列适合作为索引</strong></p>
<p><code>列的基数</code>指的是某一列中不重复数据的个数，比方说某个列包含值<code>2,5,8,2,5,8,2,5,8</code>，虽然有<code>9</code>条记录，但该列的基数却是<code>3</code>。也就是说，<strong>在记录行数一定的情况下，列的基数越大，该列中的值越分散；列的基数越小，该列中的值越集中。</strong>这个列的基数指标非常重要，直接影响我们是否能有效的利用索引。最好为列的基数大的列建立索引，为基数太小的列建立索引效果可能不好。</p>
<p>可以使用公式<code>select count(distinct a)/count(*) from t1</code>计算区分度，越接近1越好，一般超过<code>33%</code>就算是比较高效的索引了。</p>
<p>拓展：联合索引把区分度高（散列性高）的列放在前面。</p>
<p><strong>10.</strong> <strong>使用最频繁的列放到联合索引的左侧</strong></p>
<p><strong>11.</strong> <strong>在多个字段都要创建索引的情况下，联合索引优于单值索引</strong></p>
<h5 id="3-2-限制索引的数目"><a href="#3-2-限制索引的数目" class="headerlink" title="3.2 限制索引的数目"></a><strong>3.2</strong> <strong>限制索引的数目</strong></h5><p>在实际工作中，我们也需要注意平衡，索引的数目不是越多越好。我们需要限制每张表上的索引数量，建议单张表索引数量<code>不超过6个</code>。原因：</p>
<ul>
<li>每个索引都需要占用<code>磁盘空间</code>，索引越多，需要的磁盘空间就越大。</li>
<li>索引会影响<code>INSERT、DELETE、UPDATE等语句的性能</code>，因为表中的数据更改的同时，索引也会进行调整和更新，会造成负担。</li>
<li>优化器在选择如何优化查询时，会根据统一信息，对每一个可以用到的<code>索引来进行评估</code>，以生成出一个最好的执行计划，如果同时有很多个索引都可以用于查询，会增加MySQL优化器生成执行计划时间，降低查询性能。</li>
</ul>
<h5 id="3-3-哪些情况不适合创建索引"><a href="#3-3-哪些情况不适合创建索引" class="headerlink" title="3.3 哪些情况不适合创建索引"></a><strong>3.3</strong> <strong>哪些情况不适合创建索引</strong></h5><p><strong>1.</strong> <strong>在where中使用不到的字段，不要设置索引</strong></p>
<p><strong>2.</strong> <strong>数据量小的表最好不要使用索引</strong></p>
<p><strong>3.</strong> <strong>有大量重复数据的列上不要建立索引</strong></p>
<p><strong>4.</strong> <strong>避免对经常更新的表创建过多的索引</strong> </p>
<p><strong>5.</strong> <strong>不建议用无序的值作为索引</strong></p>
<p>例如身份证、UUID(在索引比较时需要转为ASCII，并且插入时可能造成页分裂)、MD5、HASH、无序长字符串等。</p>
<p><strong>6.</strong> <strong>删除不再使用或者很少使用的索引</strong></p>
<p><strong>7.</strong> <strong>不要定义冗余或重复的索引</strong></p>
<h3 id="第09章-性能分析工具的使用"><a href="#第09章-性能分析工具的使用" class="headerlink" title="第09章 性能分析工具的使用"></a>第09章 性能分析工具的使用</h3><h4 id="1-统计SQL的查询成本：last-query-cost"><a href="#1-统计SQL的查询成本：last-query-cost" class="headerlink" title="1. 统计SQL的查询成本：last_query_cost"></a><strong>1.</strong> <strong>统计SQL的查询成本：last_query_cost</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SHOW STATUS LIKE &#39;last_query_cost&#39;;</span><br></pre></td></tr></table></figure>

<p>使用场景：它对于比较开销是非常有用的，特别是我们有好几种查询方式可选的时候。</p>
<blockquote>
<p>SQL 查询是一个动态的过程，从页加载的角度来看，我们可以得到以下两点结论：</p>
<ol>
<li><code>位置决定效率</code>。如果页就在数据库<code>缓冲池</code>中，那么效率是最高的，否则还需要从<code>内存</code>或者<code>磁盘</code>中进行读取，当然针对单个页的读取来说，如果页存在于内存中，会比在磁盘中读取效率高很多。</li>
<li><code>批量决定效率</code>。如果我们从磁盘中对单一页进行随机读，那么效率是很低的（差不多10ms），而采用顺序读取的方式，批量对页进行读取，平均一页的读取效率就会提升很多，甚至要快于单个页面在内存中的随机读取。</li>
</ol>
<p>所以说，遇到I/O并不用担心，方法找对了，效率还是很高的。我们首先要考虑数据存放的位置，如果是经常使用的数据就要尽量放到<code>缓冲池</code>中，其次我们可以充分利用磁盘的吞吐能力，一次性批量读取数据，这样单个页的读取效率也就得到了提升。</p>
</blockquote>
<h4 id="2-定位执行慢的SQL：慢查询日志"><a href="#2-定位执行慢的SQL：慢查询日志" class="headerlink" title="2. 定位执行慢的SQL：慢查询日志"></a><strong>2.</strong> <strong>定位执行慢的SQL：慢查询日志</strong></h4><p>MySQL的慢查询日志，用来记录在MySQL中<code>响应时间超过阈值</code>的语句，具体指运行时间超过<code>long_query_time</code>的值的SQL，则会被记录到慢查询日志中。long_query_time的默认值为<code>10</code>，意思是运行10秒以上（不含10秒）的语句，认为是超出了我们的最大忍耐时间值。</p>
<p>默认情况下，MySQL数据库<code>没有开启慢查询日志</code>，需要我们手动来设置这个参数。<code>如果不是调优需要的话，一般不建议启动该参数</code>，因为开启慢查询日志会或多或少带来一定的性能影响。</p>
<h5 id="2-1-开启慢查询日志参数"><a href="#2-1-开启慢查询日志参数" class="headerlink" title="2.1 开启慢查询日志参数"></a><strong>2.1</strong> <strong>开启慢查询日志参数</strong></h5><p><strong>1.</strong> <strong>开启slow_query_log</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">set global slow_query_log&#x3D;&#39;ON&#39;;</span><br></pre></td></tr></table></figure>

<p>查看下慢查询日志是否开启，以及慢查询日志文件的位置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">show variables like &#96;%slow_query_log%&#96;;</span><br></pre></td></tr></table></figure>

<p><strong>2.</strong> <strong>修改long_query_time阈值</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">show variables like &#39;%long_query_time%&#39;;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#测试发现：设置global的方式对当前session的long_query_time失效。对新连接的客户端有效。所以可以一并 执行下述语句 </span><br><span class="line">mysql &gt; set global long_query_time &#x3D; 1; </span><br><span class="line">mysql&gt; show global variables like &#39;%long_query_time%&#39;; </span><br><span class="line"></span><br><span class="line">mysql&gt; set long_query_time&#x3D;1; </span><br><span class="line">mysql&gt; show variables like &#39;%long_query_time%&#39;;</span><br></pre></td></tr></table></figure>

<h5 id="2-2-查看慢查询数目"><a href="#2-2-查看慢查询数目" class="headerlink" title="2.2 查看慢查询数目"></a><strong>2.2</strong> <strong>查看慢查询数目</strong></h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SHOW GLOBAL STATUS LIKE &#39;%Slow_queries%&#39;;</span><br></pre></td></tr></table></figure>

<h5 id="2-3-慢查询日志分析工具：mysqldumpslow"><a href="#2-3-慢查询日志分析工具：mysqldumpslow" class="headerlink" title="2.3 慢查询日志分析工具：mysqldumpslow"></a><strong>2.3</strong> <strong>慢查询日志分析工具：mysqldumpslow</strong></h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">得到返回记录集最多的10个SQL</span> </span><br><span class="line">mysqldumpslow -s r -t 10 /var/lib/mysql/atguigu-slow.log </span><br><span class="line"><span class="meta">#</span><span class="bash">得到访问次数最多的10个SQL</span> </span><br><span class="line">mysqldumpslow -s c -t 10 /var/lib/mysql/atguigu-slow.log</span><br><span class="line"><span class="meta">#</span><span class="bash">得到按照时间排序的前10条里面含有左连接的查询语句</span> </span><br><span class="line">mysqldumpslow -s t -t 10 -g &quot;left join&quot; /var/lib/mysql/atguigu-slow.log </span><br><span class="line"><span class="meta">#</span><span class="bash">另外建议在使用这些命令时结合 | 和more 使用 ，否则有可能出现爆屏情况</span> </span><br><span class="line">mysqldumpslow -s r -t 10 /var/lib/mysql/atguigu-slow.log | more</span><br></pre></td></tr></table></figure>

<h5 id="2-4-关闭慢查询日志"><a href="#2-4-关闭慢查询日志" class="headerlink" title="2.4 关闭慢查询日志"></a><strong>2.4</strong> <strong>关闭慢查询日志</strong></h5><p><strong>方式1：永久性方式</strong></p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="section">[mysqld]</span> </span><br><span class="line"><span class="attr">slow_query_log</span>=<span class="literal">OFF</span></span><br><span class="line"><span class="comment">#或</span></span><br><span class="line"><span class="section">[mysqld]</span> </span><br><span class="line"><span class="comment">#slow_query_log =OFF</span></span><br></pre></td></tr></table></figure>

<p><strong>方式2：临时性方式</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SET GLOBAL slow_query_log&#x3D;off;</span><br></pre></td></tr></table></figure>

<h4 id="3-查看-SQL-执行成本：SHOW-PROFILE"><a href="#3-查看-SQL-执行成本：SHOW-PROFILE" class="headerlink" title="3. 查看 SQL 执行成本：SHOW PROFILE"></a><strong>3.</strong> <strong>查看</strong> <strong>SQL</strong> <strong>执行成本：SHOW PROFILE</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">show variables like &#39;profiling&#39;;</span><br><span class="line">#开启</span><br><span class="line">set profiling &#x3D; &#39;ON&#39;;</span><br><span class="line">#查看</span><br><span class="line">show profiles;</span><br><span class="line">show profile cpu,block io for query 2;</span><br></pre></td></tr></table></figure>

<h4 id="4-分析查询语句：EXPLAIN"><a href="#4-分析查询语句：EXPLAIN" class="headerlink" title="4. 分析查询语句：EXPLAIN"></a><strong>4.</strong> <strong>分析查询语句：EXPLAIN</strong></h4><h5 id="4-1-基本语法"><a href="#4-1-基本语法" class="headerlink" title="4.1 基本语法"></a><strong>4.1</strong> <strong>基本语法</strong></h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">EXPLAIN SELECT select_options </span><br><span class="line">#或者</span><br><span class="line">DESCRIBE SELECT select_options</span><br></pre></td></tr></table></figure>

<p>EXPLAIN 语句输出的各个列的作用如下：</p>
<table>
<thead>
<tr>
<th>列名</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>id</td>
<td>在一个大的查询语句中每个SELECT关键字都对应一个<code>唯一的id</code></td>
</tr>
<tr>
<td>select_type</td>
<td>SELECT关键字对应的那个查询的类型</td>
</tr>
<tr>
<td>table</td>
<td>表名</td>
</tr>
<tr>
<td>partitions</td>
<td>匹配的分区信息</td>
</tr>
<tr>
<td>type</td>
<td>针对单表的访问方法</td>
</tr>
<tr>
<td>possible_keys</td>
<td>可能用到的索引</td>
</tr>
<tr>
<td>key</td>
<td>实际上使用的索引</td>
</tr>
<tr>
<td>key_len</td>
<td>实际使用到的索引长度</td>
</tr>
<tr>
<td>ref</td>
<td>当使用索引列等值查询时，与索引列进行等值匹配的对象信息</td>
</tr>
<tr>
<td>rows</td>
<td>预估的需要读取的记录条数</td>
</tr>
<tr>
<td>filtered</td>
<td>某个表经过搜索条件过滤后剩余记录条数的百分比</td>
</tr>
<tr>
<td>Extra</td>
<td>一些额外的信息</td>
</tr>
</tbody></table>
<h5 id="4-2-EXPLAIN各列作用"><a href="#4-2-EXPLAIN各列作用" class="headerlink" title="4.2 EXPLAIN各列作用"></a><strong>4.2 EXPLAIN各列作用</strong></h5><p><strong>1. table</strong></p>
<p>不论我们的查询语句有多复杂，包含了多少个表 ，到最后也是需要对每个表进行<code>单表访问</code>的，所以MySQL规定<strong>EXPLAIN语句输出的每条记录都对应着某个单表的访问方法</strong>，该条记录的table列代表着该表的表名（有时不是真实的表名字，可能是简称）。</p>
<p><strong>2. id</strong></p>
<ul>
<li><strong>id如果相同，可以认为是一组，从上往下顺序执行</strong></li>
<li><strong>在所有组中，id值越大，优先级越高，越先执行</strong></li>
<li><strong>关注点：id号每个号码，表示一趟独立的查询,一个sql的查询趟数越少越好</strong></li>
</ul>
<p><strong>3. select_type</strong></p>
<p><strong>4. partitions</strong></p>
<p><strong>5. type（重点）</strong></p>
<p><strong>结果值从最好到最坏依次是：</strong> <strong>system &gt; const &gt; eq_ref &gt; ref</strong> <strong>&gt; fulltext &gt; ref_or_null &gt; index_merge &gt; unique_subquery &gt; index_subquery &gt;</strong> <strong>range &gt; index &gt; ALL</strong> </p>
<p><strong>SQL性能优化的目标：至少要达到 range级别，要求是ref级别，最好是consts级别。（阿里巴巴开发手册要求）</strong></p>
<p><strong>6. possible_keys和key</strong></p>
<p><strong>7. key_len（重点）</strong></p>
<p><strong>key_len的长度计算公式：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">varchar(10)变长字段且允许NULL &#x3D; 10 * ( character set： utf8&#x3D;3,gbk&#x3D;2,latin1&#x3D;1)+1(NULL)+2(变长字段) </span><br><span class="line"></span><br><span class="line">varchar(10)变长字段且不允许NULL &#x3D; 10 * ( character set：utf8&#x3D;3,gbk&#x3D;2,latin1&#x3D;1)+2(变长字段)</span><br><span class="line"></span><br><span class="line">char(10)固定字段且允许NULL &#x3D; 10 * ( character set：utf8&#x3D;3,gbk&#x3D;2,latin1&#x3D;1)+1(NULL) </span><br><span class="line"></span><br><span class="line">char(10)固定字段且不允许NULL &#x3D; 10 * ( character set：utf8&#x3D;3,gbk&#x3D;2,latin1&#x3D;1)</span><br></pre></td></tr></table></figure>

<p><strong>8. ref</strong> </p>
<p><strong>9. rows（重点）</strong></p>
<p>预估的需要读取的记录条数</p>
<p><strong>10. filtered</strong></p>
<p><strong>11. Extra</strong></p>
<h4 id="5-EXPLAIN的进一步使用"><a href="#5-EXPLAIN的进一步使用" class="headerlink" title="5. EXPLAIN的进一步使用"></a><strong>5. EXPLAIN的进一步使用</strong></h4><h5 id="5-1-EXPLAIN四种输出格式"><a href="#5-1-EXPLAIN四种输出格式" class="headerlink" title="5.1 EXPLAIN四种输出格式"></a><strong>5.1 EXPLAIN四种输出格式</strong></h5><p>这里谈谈EXPLAIN的输出格式。EXPLAIN可以输出四种格式：<code>传统格式</code>，<code>JSON格式</code>，<code>TREE格式</code>以及<code>可视化输出</code>。用户可以根据需要选择适用于自己的格式。</p>
<p><strong>1.</strong> <strong>传统格式</strong></p>
<p><strong>2. JSON格式</strong> </p>
<p>JSON格式：在EXPLAIN单词和真正的查询语句中间加上<code>FORMAT=JSON</code>。用于查看执行成本<code>cost_info</code></p>
<p><strong>3. TREE格式</strong></p>
<p>TREE格式是8.0.16版本之后引入的新格式，主要根据查询的<code>各个部分之间的关系</code>和<code>各部分的执行顺序</code>来描述如何查询。</p>
<p><strong>4.</strong> <strong>可视化输出</strong></p>
<p>可视化输出，可以通过MySQL Workbench可视化查看MySQL的执行计划。</p>
<h5 id="5-2-SHOW-WARNINGS的使用"><a href="#5-2-SHOW-WARNINGS的使用" class="headerlink" title="5.2 SHOW WARNINGS的使用"></a><strong>5.2 SHOW WARNINGS的使用</strong></h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT s1.key1, s2.key1 FROM s1 LEFT JOIN s2 ON s1.key1 &#x3D; s2.key1 WHERE s2.common_field IS NOT NULL;</span><br><span class="line"># 查看优化后的执行语句</span><br><span class="line">mysql&gt; SHOW WARNINGS\G</span><br></pre></td></tr></table></figure>

<h4 id="6-分析优化器执行计划：trace"><a href="#6-分析优化器执行计划：trace" class="headerlink" title="6. 分析优化器执行计划：trace"></a><strong>6.</strong> <strong>分析优化器执行计划：trace</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 开启</span><br><span class="line">SET optimizer_trace&#x3D;&quot;enabled&#x3D;on&quot;,end_markers_in_json&#x3D;on; </span><br><span class="line"># 设置大小</span><br><span class="line">set optimizer_trace_max_mem_size&#x3D;1000000;</span><br><span class="line"># 使用</span><br><span class="line">select * from student where id &lt; 10;</span><br><span class="line">select * from information_schema.optimizer_trace\G</span><br></pre></td></tr></table></figure>

<h4 id="7-MySQL监控分析视图-sys-schema"><a href="#7-MySQL监控分析视图-sys-schema" class="headerlink" title="7. MySQL监控分析视图-sys schema"></a><strong>7. MySQL监控分析视图-sys schema</strong></h4><p><strong>7.1 Sys schema视图使用场景</strong></p>
<p><strong>索引情况</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#1. 查询冗余索引 </span><br><span class="line">select * from sys.schema_redundant_indexes; </span><br><span class="line">#2. 查询未使用过的索引 </span><br><span class="line">select * from sys.schema_unused_indexes; </span><br><span class="line">#3. 查询索引的使用情况 </span><br><span class="line">select index_name,rows_selected,rows_inserted,rows_updated,rows_deleted from sys.schema_index_statistics where table_schema&#x3D;&#39;dbname&#39; ;</span><br></pre></td></tr></table></figure>

<p><strong>表相关</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 1. 查询表的访问量 </span><br><span class="line">select table_schema,table_name,sum(io_read_requests+io_write_requests) as io from sys.schema_table_statistics group by table_schema,table_name order by io desc; </span><br><span class="line"># 2. 查询占用bufferpool较多的表 </span><br><span class="line">select object_schema,object_name,allocated,data</span><br><span class="line">from sys.innodb_buffer_stats_by_table order by allocated limit 10; </span><br><span class="line"># 3. 查看表的全表扫描情况 </span><br><span class="line">select * from sys.statements_with_full_table_scans where db&#x3D;&#39;dbname&#39;;</span><br></pre></td></tr></table></figure>

<p><strong>语句相关</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#1. 监控SQL执行的频率 </span><br><span class="line">select db,exec_count,query from sys.statement_analysis order by exec_count desc; </span><br><span class="line">#2. 监控使用了排序的SQL </span><br><span class="line">select db,exec_count,first_seen,last_seen,query</span><br><span class="line">from sys.statements_with_sorting limit 1; </span><br><span class="line">#3. 监控使用了临时表或者磁盘临时表的SQL </span><br><span class="line">select db,exec_count,tmp_tables,tmp_disk_tables,query</span><br><span class="line">from sys.statement_analysis where tmp_tables&gt;0 or tmp_disk_tables &gt;0 order by (tmp_tables+tmp_disk_tables) desc;</span><br></pre></td></tr></table></figure>

<p><strong>IO相关</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#1. 查看消耗磁盘IO的文件 </span><br><span class="line">select file,avg_read,avg_write,avg_read+avg_write as avg_io</span><br><span class="line">from sys.io_global_by_file_by_bytes order by avg_read limit 10;</span><br></pre></td></tr></table></figure>

<p><strong>Innodb</strong> <strong>相关</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#1. 行锁阻塞情况 </span><br><span class="line">select * from sys.innodb_lock_waits;</span><br></pre></td></tr></table></figure>

<h3 id="第10章-索引优化与查询优化"><a href="#第10章-索引优化与查询优化" class="headerlink" title="第10章 索引优化与查询优化"></a>第10章 索引优化与查询优化</h3><h4 id="1-索引失效案例"><a href="#1-索引失效案例" class="headerlink" title="1. 索引失效案例"></a><strong>1.</strong> <strong>索引失效案例</strong></h4><p>MySQL中<code>提高性能</code>的一个最有效的方式是对数据表<code>设计合理的索引</code>。索引提供了访问高效数据的方法，并且加快查询的速度，因此索引对查询的速度有着至关重要的影响。</p>
<ul>
<li>使用索引可以<code>快速地定位</code>表中的某条记录，从而提高数据库查询的速度，提高数据库的性能。</li>
<li>如果查询时没有使用索引，查询语句就会<code>扫描表中的所有记录</code>。在数据量大的情况下，这样查询的速度会很慢。</li>
</ul>
<p>大多数情况下都（默认）采用<code>B+树</code>来构建索引。只是空间列类型的索引使用<code>R-树</code>，并且MEMORY表还支持<code>hash索引</code>。</p>
<p>其实，用不用索引，最终都是优化器说了算。优化器是基于什么的优化器？基于<code>cost开销(CostBaseOptimizer)</code>，它不是基于<code>规则(Rule-BasedOptimizer)</code>，也不是基于<code>语义</code>。怎么样开销小就怎么来。另外，<strong>SQL语句是否使用索引，跟数据库版本、数据量、数据选择度都有关系。</strong></p>
<h5 id="1-1-全值匹配我最爱"><a href="#1-1-全值匹配我最爱" class="headerlink" title="1.1 全值匹配我最爱"></a><strong>1.1</strong> <strong>全值匹配我最爱</strong></h5><h5 id="1-2-最佳左前缀法则"><a href="#1-2-最佳左前缀法则" class="headerlink" title="1.2 最佳左前缀法则"></a><strong>1.2</strong> <strong>最佳左前缀法则</strong></h5><p>在MySQL建立联合索引时会遵守最佳左前缀匹配原则，即最左优先，在检索数据时从联合索引的最左边开始匹配。</p>
<p>结论：MySQL可以为多个字段创建索引，一个索引可以包括16个字段。对于多列索引，<strong>过滤条件要使用索引必须按照索引建立时的顺序，依次满足，一旦跳过某个字段，索引后面的字段都无法被使用。</strong>如果查询条件中没有使用这些字段中第1个字段时，多列（或联合）索引不会被使用。</p>
<h5 id="1-3-主键插入顺序"><a href="#1-3-主键插入顺序" class="headerlink" title="1.3 主键插入顺序"></a><strong>1.3</strong> <strong>主键插入顺序</strong></h5><p>对于一个使用<code>InnoDB</code>存储引擎的表来说，在我们没有显示的创建索引时，表中的数据实际上都是存储在<code>聚簇索引</code>的叶子节点的。而记录又存储在数据页中的，数据页和记录又是按照记录<code>主键值从小到大</code>的顺序进行排序，所以如果我们<code>插入</code>的记录的<code>主键值是依次增大</code>的话，那我们每插满一个数据页就换到下一个数据页继续插，而如果我们插入的<code>主键值忽小忽大</code>的话，则可能会造成<code>页面分裂</code>和<code>记录移位</code>。</p>
<h5 id="1-4-计算、函数、类型转换-自动或手动-导致索引失效"><a href="#1-4-计算、函数、类型转换-自动或手动-导致索引失效" class="headerlink" title="1.4 计算、函数、类型转换(自动或手动)导致索引失效"></a><strong>1.4</strong> <strong>计算、函数、类型转换(自动或手动)导致索引失效</strong></h5><h5 id="1-5-类型转换导致索引失效"><a href="#1-5-类型转换导致索引失效" class="headerlink" title="1.5 类型转换导致索引失效"></a><strong>1.5</strong> <strong>类型转换导致索引失效</strong></h5><h5 id="1-6-范围条件右边的列索引失效"><a href="#1-6-范围条件右边的列索引失效" class="headerlink" title="1.6 范围条件右边的列索引失效"></a><strong>1.6</strong> <strong>范围条件右边的列索引失效</strong></h5><blockquote>
<p>应用开发中范围查询，例如：金额查询，日期查询往往都是范围查询。应将查询条件放置where语句最后。（创建的联合索引中，务必把范围涉及到的字段写在最后）</p>
</blockquote>
<h5 id="1-7-不等于-或者-lt-gt-索引失效"><a href="#1-7-不等于-或者-lt-gt-索引失效" class="headerlink" title="1.7 不等于(!= 或者&lt;&gt;)索引失效"></a><strong>1.7</strong> <strong>不等于(!= 或者&lt;&gt;)索引失效</strong></h5><h5 id="1-8-is-null可以使用索引，is-not-null无法使用索引"><a href="#1-8-is-null可以使用索引，is-not-null无法使用索引" class="headerlink" title="1.8 is null可以使用索引，is not null无法使用索引"></a><strong>1.8 is null可以使用索引，is not null无法使用索引</strong></h5><blockquote>
<p>结论：最好在设计数据表的时候就将<code>字段设置为 NOT NULL 约束</code>，比如你可以将INT类型的字段，默认值设置为0。将字符类型的默认值设置为空字符串(‘’)</p>
<p>拓展：同理，在查询中使用<code>not like</code>也无法使用索引，导致全表扫描</p>
</blockquote>
<h5 id="1-9-like以通配符-开头索引失效"><a href="#1-9-like以通配符-开头索引失效" class="headerlink" title="1.9 like以通配符%开头索引失效"></a><strong>1.9 like以通配符%开头索引失效</strong></h5><blockquote>
<p>拓展：Alibaba《Java开发手册》</p>
<p>【强制】页面搜索严禁左模糊或者全模糊，如果需要请走搜索引擎来解决。</p>
</blockquote>
<h5 id="1-10-OR-前后存在非索引的列，索引失效"><a href="#1-10-OR-前后存在非索引的列，索引失效" class="headerlink" title="1.10 OR 前后存在非索引的列，索引失效"></a><strong>1.10 OR</strong> <strong>前后存在非索引的列，索引失效</strong></h5><p>在WHERE子句中，如果在OR前的条件列进行了索引，而在OR后的条件列没有进行索引，那么索引会失效。也就是说，<strong>OR前后的两个条件中的列都是索引时，查询中才使用索引。</strong></p>
<h5 id="1-11-数据库和表的字符集统一使用utf8mb4"><a href="#1-11-数据库和表的字符集统一使用utf8mb4" class="headerlink" title="1.11 数据库和表的字符集统一使用utf8mb4"></a><strong>1.11</strong> <strong>数据库和表的字符集统一使用utf8mb4</strong></h5><p>统一使用utf8mb4( 5.5.3版本以上支持)兼容性更好，统一字符集可以避免由于字符集转换产生的乱码。不同的<code>字符集</code>进行比较前需要进行<code>转换</code>会造成索引失效。</p>
<h4 id="2-关联查询优化"><a href="#2-关联查询优化" class="headerlink" title="2. 关联查询优化"></a><strong>2.</strong> <strong>关联查询优化</strong></h4><blockquote>
<p>结论1：对于内连接来说，查询优化器可以决定谁来作为驱动表，谁作为被驱动表出现</p>
<p>结论2：对于内连接来讲，如果表的连接条件中只能有一个字段有索引，则有索引的字段所在的表会被作为被驱动表</p>
<p>结论3：对于内连接来说，在两个表的连接条件都存在索引的情况下，会选择小表作为驱动表。<code>小表驱动大表</code></p>
</blockquote>
<h5 id="2-1-Index-Nested-Loop-Join（索引嵌套循环连接）"><a href="#2-1-Index-Nested-Loop-Join（索引嵌套循环连接）" class="headerlink" title="2.1 Index Nested-Loop Join（索引嵌套循环连接）"></a>2.1 Index Nested-Loop Join（索引嵌套循环连接）</h5><p>Index Nested-Loop Join其优化的思路主要是为了<code>减少内层表数据的匹配次数</code>，所以要求被驱动表上必须<code>有索引</code>才行。</p>
<p><img src="https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202204011826671.png" alt="image-20220401182649509"></p>
<h5 id="2-2-Block-Nested-Loop-Join（块嵌套循环连接）"><a href="#2-2-Block-Nested-Loop-Join（块嵌套循环连接）" class="headerlink" title="2.2 Block Nested-Loop Join（块嵌套循环连接）"></a>2.2 Block Nested-Loop Join（块嵌套循环连接）</h5><p>如果存在索引，那么会使用index的方式进行join，如果join的列没有索引，被驱动表要扫描的次数太多了。每次访问被驱动表，其表中的记录都会被加载到内存中，然后再从驱动表中取一条与其匹配，匹配结束后清除内存，然后再从驱动表中加载一条记录，然后把被驱动表的记录再加载到内存匹配，这样周而复始，大大增加了IO的次数。为了减少被驱动表的IO次数，就出现了Block Nested-Loop Join的方式。</p>
<p>不再是逐条获取驱动表的数据，而是一块一块的获取，引入了<code>join buffer缓冲区</code>，将驱动表join相关的部分数据列（大小受join buffer的限制）缓存到join buffer中，然后全表扫描被驱动表，被驱动表的每一条记录一次性和join buffer中的所有驱动表记录进行匹配（内存中操作），将简单嵌套循环中的多次比较合并成一次，降低了被驱动表的访问频率。</p>
<p><img src="https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202204011833000.png" alt="image-20220401183344880"></p>
<h5 id="2-3-Hash-Join"><a href="#2-3-Hash-Join" class="headerlink" title="2.3 Hash Join"></a>2.3 Hash Join</h5><p><strong>从MySQL的8.0.20版本开始将废弃BNLJ，因为从MySQL8.0.18版本开始就加入了hash join默认都会使用hash join</strong></p>
<ul>
<li>Nested Loop：对于被连接的数据子集较小的情况下，Nested Loop是个较好的选择。</li>
<li>Hash Join是做<code>大数据集连接</code>时的常用方式，优化器使用两个表中较小（相对较小）的表利用Join Key在内存中建立<code>散列值</code>，然后扫描较大的表并探测散列值，找出与Hash表匹配的行。<ul>
<li>这种方式适用于较小的表完全可以放入内存中的情况，这样总成本就是访问两个表的成本之和。</li>
<li>在表很大的情况下并不能完全放入内存，这时优化器会将它分割成<code>若干不同的分区</code>，不能放入内存的部分就把该分区写入磁盘的临时段，此时要求有较大的临时段从而尽量提高I/O的性能。</li>
<li>它能够很好的工作于没有索引的大表和并行查询的环境中，并提供最好的性能。Hash Join只能应用于等值连接，这是由Hash的特点决定的。</li>
</ul>
</li>
</ul>
<h4 id="3-子查询优化"><a href="#3-子查询优化" class="headerlink" title="3. 子查询优化"></a><strong>3.</strong> <strong>子查询优化</strong></h4><p><strong>子查询是</strong> <strong>MySQL</strong> <strong>的一项重要的功能，可以帮助我们通过一个</strong> <strong>SQL</strong> <strong>语句实现比较复杂的查询。但是，子查询的执行效率不高。</strong>原因：</p>
<p>① 执行子查询时，MySQL需要为内层查询语句的查询结果<code>建立一个临时表</code>，然后外层查询语句从临时表中查询记录。查询完毕后，再<code>撤销这些临时表</code>。这样会消耗过多的CPU和IO资源，产生大量的慢查询。</p>
<p>② 子查询的结果集存储的临时表，不论是内存临时表还是磁盘临时表都<code>不会存在索引</code>，所以查询性能会受到一定的影响。</p>
<p>③ 对于返回结果集比较大的子查询，其对查询性能的影响也就越大。</p>
<p><strong>在MySQL中，可以使用连接（JOIN）查询来替代子查询。</strong>连接查询<code>不需要建立临时表</code>，其<code>速度比子查询要快</code>，如果查询中使用索引的话，性能就会更好。</p>
<blockquote>
<p>结论：尽量不要使用NOT IN 或者 NOT EXISTS，用LEFT JOIN xxx ON xx WHERE xx IS NULL替代</p>
</blockquote>
<h4 id="4-排序优化"><a href="#4-排序优化" class="headerlink" title="4. 排序优化"></a><strong>4.</strong> <strong>排序优化</strong></h4><ol>
<li><p>SQL 中，可以在 WHERE 子句和 ORDER BY 子句中使用索引，目的是在 WHERE 子句中 <code>避免全表扫描</code>，在 ORDER BY 子句<code>避免使用 FileSort 排序</code>。当然，某些情况下全表扫描，或者 FileSort 排序不一定比索引慢。但总的来说，我们还是要避免，以提高查询效率。</p>
</li>
<li><p>尽量使用 Index 完成 ORDER BY 排序。如果 WHERE 和 ORDER BY 后面是相同的列就使用单索引列；如果不同就使用联合索引。</p>
</li>
<li><p>无法使用 Index 时，需要对 FileSort 方式进行调优。</p>
</li>
</ol>
<h4 id="5-GROUP-BY优化"><a href="#5-GROUP-BY优化" class="headerlink" title="5. GROUP BY优化"></a><strong>5. GROUP BY优化</strong></h4><ul>
<li>group by 使用索引的原则几乎跟order by一致 ，group by 即使没有过滤条件用到索引，也可以直接使用索引。</li>
<li>group by 先排序再分组，遵照索引建的最佳左前缀法则</li>
<li>当无法使用索引列，可以增大<code>max_length_for_sort_data</code>和<code>sort_buffer_size</code>参数的设置</li>
<li>where效率高于having，能写在where限定的条件就不要写在having中了</li>
<li>减少使用order by，和业务沟通能不排序就不排序，或将排序放到程序端去做。Order by、group by、distinct这些语句较为耗费CPU，数据库的CPU资源是极其宝贵的。</li>
<li>包含了order by、group by、distinct这些查询的语句，where条件过滤出来的结果集请保持在1000行以内，否则SQL会很慢。</li>
</ul>
<h4 id="6-优化分页查询"><a href="#6-优化分页查询" class="headerlink" title="6. 优化分页查询"></a><strong>6.</strong> <strong>优化分页查询</strong></h4><p><strong>优化思路一</strong></p>
<p>在索引上完成排序分页操作，最后根据主键关联回原表查询所需要的其他列内容。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM student t,(SELECT id FROM student ORDER BY id LIMIT 2000000,10) a</span><br><span class="line">WHERE t.id &#x3D; a.id;</span><br></pre></td></tr></table></figure>

<p><strong>优化思路二</strong></p>
<p>该方案适用于主键自增的表，可以把Limit 查询转换成某个位置的查询。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM student WHERE id &gt; 2000000 LIMIT 10;</span><br></pre></td></tr></table></figure>

<h4 id="7-优先考虑覆盖索引"><a href="#7-优先考虑覆盖索引" class="headerlink" title="7. 优先考虑覆盖索引"></a><strong>7.</strong> <strong>优先考虑覆盖索引</strong></h4><h5 id="7-1-什么是覆盖索引？"><a href="#7-1-什么是覆盖索引？" class="headerlink" title="7.1 什么是覆盖索引？"></a><strong>7.1</strong> <strong>什么是覆盖索引？</strong></h5><p><strong>理解方式一</strong>：索引是高效找到行的一个方法，但是一般数据库也能使用索引找到一个列的数据，因此它不必读取整个行。毕竟索引叶子节点存储了它们索引的数据；当能通过读取索引就可以得到想要的数据，那就不需要读取行了。<strong>一个索引包含了满足查询结果的数据就叫做覆盖索引。</strong></p>
<p><strong>理解方式二</strong>：非聚簇复合索引的一种形式，它包括在查询里的SELECT、JOIN和WHERE子句用到的所有列（即建索引的字段正好是覆盖查询条件中所涉及的字段）。</p>
<p>简单说就是，<code>索引列+主键</code>包含<code>SELECT 到 FROM之间查询的列</code>。</p>
<h5 id="7-2-覆盖索引的利弊"><a href="#7-2-覆盖索引的利弊" class="headerlink" title="7.2 覆盖索引的利弊"></a><strong>7.2</strong> <strong>覆盖索引的利弊</strong></h5><p><strong>好处：</strong></p>
<p><strong>1.</strong> <strong>避免Innodb表进行索引的二次查询（回表）</strong></p>
<p><strong>2.</strong> <strong>可以把随机IO变成顺序IO加快查询效率</strong></p>
<p><strong>弊端：</strong></p>
<p><code>索引字段的维护</code>总是有代价的。因此，在建立冗余索引来支持覆盖索引时就需要权衡考虑了。这是业务DBA，或者称为业务数据架构师的工作。</p>
<h4 id="8-索引条件下推"><a href="#8-索引条件下推" class="headerlink" title="8. 索引条件下推"></a><strong>8.</strong> <strong>索引条件下推</strong></h4><h5 id="8-1-使用前后的扫描过程"><a href="#8-1-使用前后的扫描过程" class="headerlink" title="8.1 使用前后的扫描过程"></a><strong>8.1</strong> <strong>使用前后的扫描过程</strong></h5><p><strong>在不使用ICP索引扫描的过程：</strong></p>
<p>storage层：只将满足index key条件的索引记录对应的整行记录取出，返回给server层 </p>
<p>server 层：对返回的数据，使用后面的where条件过滤，直至返回最后一行。</p>
<p><strong>使用ICP扫描的过程：</strong></p>
<p>storage层：首先将index key条件满足的索引记录区间确定，然后在索引上使用index filter进行过滤。将满足的index filter条件的索引记录才去回表取出整行记录返回server层。不满足index filter条件的索引记录丢弃，不回表、也不会返回server层。</p>
<p>server 层：对返回的数据，使用table filter条件做最后的过滤。</p>
<h4 id="9-其它查询优化策略"><a href="#9-其它查询优化策略" class="headerlink" title="9. 其它查询优化策略"></a><strong>9.</strong> <strong>其它查询优化策略</strong></h4><h5 id="9-1-EXISTS-和-IN-的区分"><a href="#9-1-EXISTS-和-IN-的区分" class="headerlink" title="9.1 EXISTS 和 IN 的区分"></a><strong>9.1 EXISTS</strong> <strong>和</strong> <strong>IN</strong> <strong>的区分</strong></h5><p>索引是个前提，其实选择与否还会要看表的大小。你可以将选择的标准理解为<code>小表驱动大表</code>。</p>
<h5 id="9-2-COUNT-与COUNT-具体字段-效率"><a href="#9-2-COUNT-与COUNT-具体字段-效率" class="headerlink" title="9.2 COUNT(*)与COUNT(具体字段)效率"></a><strong>9.2 COUNT(*)与COUNT(具体字段)效率</strong></h5><p><strong>环节1：</strong><code>COUNT(*)</code>和<code>COUNT(1)</code>都是对所有结果进行<code>COUNT</code>，<code>COUNT(*)</code>和<code>COUNT(1)</code>本质上并没有区别（二者执行时间可能略有差别，不过你还是可以把它俩的执行效率看成是相等的）。如果有WHERE子句，则是对所有符合筛选条件的数据行进行统计；如果没有WHERE子句，则是对数据表的数据行数进行统计。</p>
<p><strong>环节2：</strong>如果是MyISAM存储引擎，统计数据表的行数只需要<code>O(1)</code>的复杂度，这是因为每张MyISAM的数据表都有一个meta信息存储了<code>row_count</code>值，而一致性则是由表级锁来保证的。</p>
<p>如果是InnoDB存储引擎，因为InnoDB支持事务，采用行级锁和MVCC机制，所以无法像MyISAM一样，维护一个row_count变量，因此需要采用<code>扫描全表</code>，是<code>O(n)</code>的复杂度，进行循环+计数的方式来完成统计。</p>
<p><strong>环节3：</strong>在InnoDB引擎中，如果采用<code>COUNT(具体字段)</code>来统计数据行数，要尽量采用二级索引。因为主键采用的索引是聚簇索引，聚簇索引包含的信息多，明显会大于二级索引（非聚簇索引）。对于<code>COUNT(*)</code>和<code>COUNT(1)</code>来说，它们不需要查找具体的行，只是统计行数，系统会<code>自动</code>采用占用空间更小的二级索引来进行统计。</p>
<p>如果有多个二级索引，会使用key_len小的二级索引进行扫描。当没有二级索引的时候，才会采用主键索引来进行统计。</p>
<h5 id="9-3-关于SELECT"><a href="#9-3-关于SELECT" class="headerlink" title="9.3 关于SELECT(*)"></a><strong>9.3</strong> <strong>关于SELECT(*)</strong></h5><p>在表查询中，建议明确字段，不要使用 * 作为查询的字段列表，推荐使用SELECT &lt;字段列表&gt; 查询。原因：</p>
<p>① MySQL 在解析的过程中，会通过<code>查询数据字典</code>将”*”按序转换成所有列名，这会大大的耗费资源和时间。</p>
<p>② 无法使用<code>覆盖索引</code></p>
<h5 id="9-4-LIMIT-1-对优化的影响"><a href="#9-4-LIMIT-1-对优化的影响" class="headerlink" title="9.4 LIMIT 1 对优化的影响"></a><strong>9.4 LIMIT 1</strong> <strong>对优化的影响</strong></h5><p>针对的是会扫描全表的 SQL 语句，如果你可以确定结果集只有一条，那么加上<code>LIMIT 1</code>的时候，当找到一条结果的时候就不会继续扫描了，这样会加快查询速度。</p>
<p>如果数据表已经对字段建立了唯一索引，那么可以通过索引进行查询，不会全表扫描的话，就不需要加上<code>LIMIT 1</code>了。</p>
<h5 id="9-5-多使用COMMIT"><a href="#9-5-多使用COMMIT" class="headerlink" title="9.5 多使用COMMIT"></a><strong>9.5</strong> <strong>多使用COMMIT</strong></h5><p>只要有可能，在程序中尽量多使用 COMMIT，这样程序的性能得到提高，需求也会因为 COMMIT 所释放的资源而减少。</p>
<p>COMMIT 所释放的资源：</p>
<ul>
<li><p>回滚段上用于恢复数据的信息</p>
</li>
<li><p>被程序语句获得的锁</p>
</li>
<li><p>redo / undo log buffer 中的空间</p>
</li>
<li><p>管理上述 3 种资源中的内部花费</p>
</li>
</ul>
<h3 id="第11章-数据库的设计规范"><a href="#第11章-数据库的设计规范" class="headerlink" title="第11章 数据库的设计规范"></a>第11章 数据库的设计规范</h3><h4 id="1-范-式"><a href="#1-范-式" class="headerlink" title="1. 范 式"></a><strong>1.</strong> <strong>范 式</strong></h4><h5 id="1-1-范式简介"><a href="#1-1-范式简介" class="headerlink" title="1.1 范式简介"></a><strong>1.1</strong> <strong>范式简介</strong></h5><p><strong>在关系型数据库中，关于数据表设计的基本原则、规则就称为范式。</strong>可以理解为，一张数据表的设计结构需要满足的某种设计标准的<code>级别</code>。要想设计一个结构合理的关系型数据库，必须满足一定的范式。</p>
<h5 id="1-2-范式都包括哪些"><a href="#1-2-范式都包括哪些" class="headerlink" title="1.2 范式都包括哪些"></a><strong>1.2</strong> <strong>范式都包括哪些</strong></h5><p>目前关系型数据库有六种常见范式，按照范式级别，从低到高分别是：<strong>第一范式（1NF）、第二范式（2NF）、第三范式（3NF）、巴斯-科德范式（BCNF）、第四范式(4NF）和第五范式（5NF，又称完美范式）</strong>。</p>
<p><img src="https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202204030928295.png" alt="image-20220403092826169"></p>
<h5 id="1-3-键和相关属性的概念"><a href="#1-3-键和相关属性的概念" class="headerlink" title="1.3 键和相关属性的概念"></a><strong>1.3</strong> <strong>键和相关属性的概念</strong></h5><p>这里有两个表：</p>
<p><code>球员表(player)</code>：球员编号 | 姓名 | 身份证号 | 年龄 | 球队编号</p>
<p><code>球队表(team)</code>：球队编号 | 主教练 | 球队所在地</p>
<ul>
<li><code>超键</code>：对于球员表来说，超键就是包括球员编号或者身份证号的任意组合，比如（球员编号）（球员编号，姓名）（身份证号，年龄）等。</li>
<li><code>候选键</code>：就是最小的超键，对于球员表来说，候选键就是（球员编号）或者（身份证号）。</li>
<li><code>主键</code>：我们自己选定，也就是从候选键中选择一个，比如（球员编号）。</li>
<li><code>外键</code>：球员表中的球队编号。</li>
<li><code>主属性</code>、<code>非主属性</code>：在球员表中，主属性是（球员编号）（身份证号），其他的属性（姓名）（年龄）（球队编号）都是非主属性。</li>
</ul>
<h5 id="1-4-第一范式-1st-NF"><a href="#1-4-第一范式-1st-NF" class="headerlink" title="1.4 第一范式(1st NF)"></a><strong>1.4</strong> <strong>第一范式(1st NF)</strong></h5><p>第一范式主要是确保数据表中每个字段的值必须具有<code>原子性</code>，也就是说数据表中每个字段的值为<code>不可再次拆分</code>的最小数据单位。</p>
<h5 id="1-5-第二范式-2nd-NF"><a href="#1-5-第二范式-2nd-NF" class="headerlink" title="1.5 第二范式(2nd NF)"></a><strong>1.5</strong> <strong>第二范式(2nd NF)</strong></h5><p>第二范式要求，在满足第一范式的基础上，还要<strong>满足数据表里的每一条数据记录，都是可唯一标识的。而且所有非主键字段，都必须完全依赖主键，不能只依赖主键的一部分。</strong>如果知道主键的所有属性的值，就可以检索到任何元组（行）的任何属性的任何值。</p>
<h5 id="1-6-第三范式-3rd-NF"><a href="#1-6-第三范式-3rd-NF" class="headerlink" title="1.6 第三范式(3rd NF)"></a><strong>1.6</strong> <strong>第三范式(3rd NF)</strong></h5><p>第三范式是在第二范式的基础上，确保数据表中的每一个非主键字段都和主键字段直接相关，也就是说，<strong>要求数据表中的所有非主键字段不能依赖于其他非主键字段。</strong>（即，不能存在非主属性A依赖于非主属性B，非主属性B依赖于主键C的情况，即存在”A–&gt;B–&gt;C”的决定关系）通俗地讲，该规则的意思是所有<code>非主键属性</code>之间不能有依赖关系，必须<code>相互独立</code>。</p>
<h5 id="1-7-小结"><a href="#1-7-小结" class="headerlink" title="1.7 小结"></a>1.7 小结</h5><p>关于数据表的设计，有三个范式要遵循。</p>
<p>（1）第一范式（1NF），确保每列保持<code>原子性</code></p>
<p>数据库的每一列都是不可分割的原子数据项，不可再分的最小数据单元，而不能是集合、数组、记录等非原子数据项。</p>
<p>（2）第二范式（2NF），确保每列都和主键<code>完全依赖</code></p>
<p>尤其在复合主键的情况向下，非主键部分不应该依赖于部分主键。</p>
<p>（3）第三范式（3NF），确保每列都和主键<code>直接相关</code>，而不是间接相关</p>
<p><strong>范式的优点：</strong>数据的标准化有助于消除数据库中的<code>数据冗余</code>，第三范式（3NF）通常被认为在性能、拓展性和数据完整性方面达到了最好的平衡。</p>
<p><strong>范式的缺点：</strong>范式的使用，可能<code>降低查询的效率</code>。因为范式等级越高，设计出来的数据表就越多、越精细，数据的冗余度就越低，进行数据查询的时候就可能需要<code>关联多张表</code>，这不但代价昂贵，也可能使一些<code>索引策略无效</code>。</p>
<p>范式只是提出了设计的标准，实际上设计数据表时，未必一定要符合这些标准。开发中，我们会出现为了性能和读取效率违反范式化的原则，通过<code>增加少量的冗余</code>或重复的数据来提高数据库的<code>读性能</code>，减少关联查询，join表的次数，实现<code>空间换取时间</code>的目的。因此在实际的设计过程中要理论结合实际，灵活运用。</p>
<h4 id="2-反范式化"><a href="#2-反范式化" class="headerlink" title="2. 反范式化"></a><strong>2.</strong> <strong>反范式化</strong></h4><h5 id="2-1-概述"><a href="#2-1-概述" class="headerlink" title="2.1 概述"></a><strong>2.1</strong> <strong>概述</strong></h5><p><strong>规范化</strong> <strong>vs</strong> <strong>性能</strong></p>
<ol>
<li><p>为满足某种商业目标 , 数据库性能比规范化数据库更重要</p>
</li>
<li><p>在数据规范化的同时 , 要综合考虑数据库的性能</p>
</li>
<li><p>通过在给定的表中添加额外的字段，以大量减少需要从中搜索信息所需的时间</p>
</li>
<li><p>通过在给定的表中插入计算列，以方便查询</p>
</li>
</ol>
<h5 id="2-2-反范式的新问题"><a href="#2-2-反范式的新问题" class="headerlink" title="2.2 反范式的新问题"></a><strong>2.2</strong> <strong>反范式的新问题</strong></h5><ul>
<li>存储<code>空间变大</code>了</li>
<li>一个表中字段做了修改，另一个表中冗余的字段也需要做同步修改，否则<code>数据不一致</code></li>
<li>若采用存储过程来支持数据的更新、删除等额外操作，如果更新频繁，会非常<code>消耗系统资源</code></li>
<li>在<code>数据量小</code>的情况下，反范式不能体现性能的优势，可能还会让数据库的设计更加<code>复杂</code></li>
</ul>
<h5 id="2-3-反范式的适用场景"><a href="#2-3-反范式的适用场景" class="headerlink" title="2.3 反范式的适用场景"></a><strong>2.3</strong> <strong>反范式的适用场景</strong></h5><p>当冗余信息有价值或者能<code>大幅度提高查询效率</code>的时候，我们才会采取反范式的优化。</p>
<p><strong>1.</strong> <strong>增加冗余字段的建议</strong> </p>
<p>1）这个冗余字段<code>不需要经常进行修改</code></p>
<p>2）这个冗余字段<code>查询的时候不可或缺</code></p>
<p><strong>2.</strong> <strong>历史快照、历史数据的需要</strong></p>
<p>在现实生活中，我们经常需要一些冗余信息，比如订单中的收货人信息，包括姓名、电话和地址等。每次发生的<code>订单收货信息</code>都属于<code>历史快照</code>，需要进行保存，但用户可以随时修改自己的信息，这时保存这些冗余信息是非常有必要的。</p>
<p>反范式优化也常用在<code>数据仓库</code>的设计中，因为数据仓库通常<code>存储历史数据</code>，对增删改的实时性要求不强，对历史数据的分析需求强。这时适当允许数据的冗余度，更方便进行数据分析。</p>
<h4 id="3-BCNF-巴斯范式"><a href="#3-BCNF-巴斯范式" class="headerlink" title="3. BCNF(巴斯范式)"></a><strong>3. BCNF(巴斯范式)</strong></h4><p>主属性（仓库名）对于候选键（管理员，物品名）是部分依赖的关系，这样就有可能导致异常情况。因此引入BCNF，<strong>它在</strong> <strong>3NF</strong> <strong>的基础上消除了主属性对候选键的部分依赖或者传递依赖关系</strong>。</p>
<p>如果在关系R中，U为主键，A属性是主键的一个属性，若存在A-&gt;Y，Y为主属性，则该关系不属于BCNF。</p>
<h4 id="4-ER模型"><a href="#4-ER模型" class="headerlink" title="4. ER模型"></a><strong>4. ER模型</strong></h4><p>ER模型也叫做<code>实体关系模型</code>，是用来描述现实生活中客观存在的事物、事物的属性，以及事物之间关系的一种数据模型。<strong>在开发基于数据库的信息系统的设计阶段，通常使用ER模型来描述信息需要和信息特性，帮助我们理清业务逻辑，从而设计出优秀的数据库。</strong></p>
<h5 id="4-1-ER-模型包括那些要素？"><a href="#4-1-ER-模型包括那些要素？" class="headerlink" title="4.1 ER 模型包括那些要素？"></a>4.1 ER 模型包括那些要素？</h5><p><strong>ER</strong> <strong>模型中有三个要素，分别是实体、属性和关系</strong>。 </p>
<p><code>实体</code>，可以看做是数据对象，往往对应于现实生活中的真实存在的个体。在 ER 模型中，用<code>矩形</code>来表示。实体分为两类，分别是<code>强实体</code>和<code>弱实体</code>。强实体是指不依赖于其他实体的实体；弱实体是指对另一个实体有很强的依赖关系的实体。</p>
<p><code>属性</code>，则是指实体的特性。比如超市的地址、联系电话、员工数等。在 ER 模型中用<code>椭圆形</code>来表示。</p>
<p><code>关系</code>，则是指实体之间的联系。比如超市把商品卖给顾客，就是一种超市与顾客之间的联系。在 ER 模型中用<code>菱形</code>来表示。</p>
<p>注意：实体和属性不容易区分。这里提供一个原则：我们要从系统整体的角度出发去看，<strong>可以独立存在的是实体，不可再分的是属性</strong>。也就是说，属性不能包含其他属性。</p>
<h5 id="4-2-关系的类型"><a href="#4-2-关系的类型" class="headerlink" title="4.2 关系的类型"></a><strong>4.2</strong> <strong>关系的类型</strong></h5><p>在 ER 模型的 3 个要素中，关系又可以分为 3 种类型，分别是 一对一、一对多、多对多。</p>
<p><code>一对一</code>：指实体之间的关系是一一对应的</p>
<p><code>一对多</code>：指一边的实体通过关系，可以对应多个另外一边的实体。相反，另外一边的实体通过这个关系，则只能对应唯一的一边的实体</p>
<p><code>多对多</code>：指关系两边的实体都可以通过关系对应多个对方的实体</p>
<h4 id="5-数据表的设计原则"><a href="#5-数据表的设计原则" class="headerlink" title="5. 数据表的设计原则"></a><strong>5.</strong> <strong>数据表的设计原则</strong></h4><p>数据表设计的一般原则：”三少一多” </p>
<p><strong>1.</strong> <strong>数据表的个数越少越好</strong> </p>
<p><strong>2.</strong> <strong>数据表中的字段个数越少越好</strong></p>
<p><strong>3.</strong> <strong>数据表中联合主键的字段个数越少越好</strong></p>
<p><strong>4.</strong> <strong>使用主键和外键越多越好</strong></p>
<blockquote>
<p>注意：这个原则并不是绝对的，有时候我们需要牺牲数据的冗余度来换取数据处理的效率。</p>
</blockquote>
<h4 id="6-数据库对象编写建议"><a href="#6-数据库对象编写建议" class="headerlink" title="6. 数据库对象编写建议"></a><strong>6.</strong> <strong>数据库对象编写建议</strong></h4><h5 id="6-1-关于库"><a href="#6-1-关于库" class="headerlink" title="6.1 关于库"></a><strong>6.1</strong> <strong>关于库</strong></h5><ol>
<li><p>【强制】库的名称必须控制在32个字符以内，只能使用英文字母、数字和下划线，建议以英文字母开头。</p>
</li>
<li><p>【强制】库名中英文<code>一律小写</code>，不同单词采用<code>下划线</code>分割。须见名知意。</p>
</li>
<li><p>【强制】库的名称格式：业务系统名称_子系统名。</p>
</li>
<li><p>【强制】库名禁止使用关键字（如type,order等）。</p>
</li>
<li><p>【强制】创建数据库时必须<code>显式指定字符集</code>，并且字符集只能是utf8或者utf8mb4。创建数据库SQL举例：CREATE DATABASE crm_fund <code>DEFAULT CHARACTER SET &#39;utf8&#39;</code>; </p>
</li>
<li><p>【建议】对于程序连接数据库账号，遵循<code>权限最小原则</code>。使用数据库账号只能在一个DB下使用，不准跨库。程序使用的账号<code>原则上不准有drop权限</code>。 </p>
</li>
<li><p>【建议】临时库以<code>tmp_</code>为前缀，并以日期为后缀；备份库以<code>bak_</code>为前缀，并以日期为后缀。</p>
</li>
</ol>
<h5 id="6-2-关于表、列"><a href="#6-2-关于表、列" class="headerlink" title="6.2 关于表、列"></a><strong>6.2</strong> <strong>关于表、列</strong></h5><ol>
<li><p>【强制】表和列的名称必须控制在32个字符以内，表名只能使用英文字母、数字和下划线，建议以<code>英文字母开头</code>。 </p>
</li>
<li><p>【强制】 <code>表名、列名一律小写</code>，不同单词采用下划线分割。须见名知意。</p>
</li>
<li><p>【强制】表名要求有模块名强相关，同一模块的表名尽量使用<code>统一前缀</code>。比如：crm_fund_item </p>
</li>
<li><p>【强制】创建表时必须<code>显式指定字符集</code>为utf8或utf8mb4。 </p>
</li>
<li><p>【强制】表名、列名禁止使用关键字（如type,order等）。</p>
</li>
<li><p>【强制】创建表时必须<code>显式指定表存储引擎</code>类型。如无特殊需求，一律为InnoDB。 </p>
</li>
<li><p>【强制】建表必须有comment。 </p>
</li>
<li><p>【强制】字段命名应尽可能使用表达实际含义的英文单词或<code>缩写</code>。如：公司 ID，不要使用 corporation_id, 而用corp_id 即可。</p>
</li>
<li><p>【强制】布尔值类型的字段命名为<code>is_描述</code>。如member表上表示是否为enabled的会员的字段命名为 is_enabled。 </p>
</li>
<li><p>【强制】禁止在数据库中存储图片、文件等大的二进制数据。通常文件很大，短时间内造成数据量快速增长，数据库进行数据库读取时，通常会进行大量的随机IO操作，文件很大时，IO操作很耗时。通常存储于文件服务器，数据库只存储文件地址信息。</p>
</li>
<li><p>【建议】建表时关于主键：<code>表必须有主键 </code>(1)强制要求主键为id，类型为int或bigint，且为auto_increment 建议使用unsigned无符号型。 (2)标识表里每一行主体的字段不要设为主键，建议设为其他字段如user_id，order_id等，并建立unique key索引。因为如果设为主键且主键值为随机插入，则会导致innodb内部页分裂和大量随机I/O，性能下降。</p>
</li>
<li><p>【建议】核心表（如用户表）必须有行数据的<code>创建时间字段</code>（create_time）和<code>最后更新时间字段</code>（update_time），便于查问题。</p>
</li>
<li><p>【建议】表中所有字段尽量都是<code>NOT NULL</code>属性，业务可以根据需要定义<code>DEFAULT值</code>。 因为使用NULL值会存在每一行都会占用额外存储空间、数据迁移容易出错、聚合函数计算结果偏差等问题。</p>
</li>
<li><p>【建议】所有存储相同数据的<code>列名和列类型必须一致</code>（一般作为关联列，如果查询时关联列类型不一致会自动进行数据类型隐式转换，会造成列上的索引失效，导致查询效率降低）。</p>
</li>
<li><p>【建议】中间表（或临时表）用于保留中间结果集，名称以<code>tmp_</code>开头。备份表用于备份或抓取源表快照，名称以<code>bak_</code>开头。中间表和备份表定期清理。</p>
</li>
<li><p>【示范】一个较为规范的建表语句：</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE user_info ( </span><br><span class="line">    &#96;id&#96; int unsigned NOT NULL AUTO_INCREMENT COMMENT &#39;自增主键&#39;, </span><br><span class="line">    &#96;user_id&#96; bigint(11) NOT NULL COMMENT &#39;用户id&#39;, </span><br><span class="line">    &#96;username&#96; varchar(45) NOT NULL COMMENT &#39;真实姓名&#39;, </span><br><span class="line">    &#96;email&#96; varchar(30) NOT NULL COMMENT &#39;用户邮箱&#39;, </span><br><span class="line">    &#96;nickname&#96; varchar(45) NOT NULL COMMENT &#39;昵称&#39;, </span><br><span class="line">    &#96;birthday&#96; date NOT NULL COMMENT &#39;生日&#39;, </span><br><span class="line">    &#96;sex&#96; tinyint(4) DEFAULT &#39;0&#39; COMMENT &#39;性别&#39;, </span><br><span class="line">    &#96;short_introduce&#96; varchar(150) DEFAULT NULL COMMENT &#39;一句话介绍自己，最多50个汉字&#39;, </span><br><span class="line">    &#96;user_resume&#96; varchar(300) NOT NULL COMMENT &#39;用户提交的简历存放地址&#39;, </span><br><span class="line">    &#96;user_register_ip&#96; int NOT NULL COMMENT &#39;用户注册时的源ip&#39;, </span><br><span class="line">    &#96;create_time&#96; timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT &#39;创建时间&#39;, </span><br><span class="line">    &#96;update_time&#96; timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT &#39;修改时间&#39;, </span><br><span class="line">    &#96;user_review_status&#96; tinyint NOT NULL COMMENT &#39;用户资料审核状态，1为通过，2为审核中，3为未 通过，4为还未提交审核&#39;,</span><br><span class="line">    PRIMARY KEY (&#96;id&#96;), </span><br><span class="line">    UNIQUE KEY &#96;uniq_user_id&#96; (&#96;user_id&#96;), </span><br><span class="line">    KEY &#96;idx_username&#96;(&#96;username&#96;), </span><br><span class="line">    KEY &#96;idx_create_time_status&#96;(&#96;create_time&#96;,&#96;user_review_status&#96;) </span><br><span class="line">) ENGINE&#x3D;InnoDB DEFAULT CHARSET&#x3D;utf8 COMMENT&#x3D;&#39;网站用户基本信息&#39;</span><br></pre></td></tr></table></figure>

<ol start="17">
<li>【建议】创建表时，可以使用可视化工具。这样可以确保表、字段相关的约定都能设置上。实际上，我们通常很少自己写 DDL 语句，可以使用一些可视化工具来创建和操作数据库和数据表。可视化工具除了方便，还能直接帮我们将数据库的结构定义转化成 SQL 语言，方便数据库和数据表结构的导出和导入。</li>
</ol>
<h5 id="6-3-关于索引"><a href="#6-3-关于索引" class="headerlink" title="6.3 关于索引"></a><strong>6.3</strong> <strong>关于索引</strong></h5><ol>
<li><p>【强制】InnoDB表必须主键为id int/bigint auto_increment，且主键值<code>禁止被更新</code>。 </p>
</li>
<li><p>【强制】InnoDB和MyISAM存储引擎表，索引类型必须为<code>BTREE</code>。 </p>
</li>
<li><p>【建议】主键的名称以<code>pk_</code>开头，唯一键以<code>uni_</code>或<code>uk_</code>开头，普通索引以<code>idx_</code>开头，一律使用小写格式，以字段的名称或缩写作为后缀。</p>
</li>
<li><p>【建议】多单词组成的columnname，取前几个单词首字母，加末单词组成column_name。如: sample 表 member_id 上的索引：idx_sample_mid。 </p>
</li>
<li><p>【建议】单个表上的索引个数<code>不能超过6个</code>。 </p>
</li>
<li><p>【建议】在建立索引时，多考虑建立<code>联合索引</code>，并把区分度最高的字段放在最前面。</p>
</li>
<li><p>【建议】在多表 JOIN 的SQL里，保证被驱动表的连接列上有索引，这样JOIN 执行效率最高。</p>
</li>
<li><p>【建议】建表或加索引时，保证表里互相不存在<code>冗余索引</code>。 比如：如果表里已经存在key(a,b)， 则key(a)为冗余索引，需要删除。</p>
</li>
</ol>
<h5 id="6-4-SQL编写"><a href="#6-4-SQL编写" class="headerlink" title="6.4 SQL编写"></a><strong>6.4 SQL编写</strong></h5><ol>
<li><p>【强制】程序端SELECT语句必须指定具体字段名称，禁止写成 *。 </p>
</li>
<li><p>【建议】程序端insert语句指定具体字段名称，不要写成INSERT INTO t1 VALUES(…)。 </p>
</li>
<li><p>【建议】除静态表或小表（100行以内），DML语句必须有WHERE条件，且使用索引查找。</p>
</li>
<li><p>【建议】INSERT INTO…VALUES(XX),(XX),(XX).. 这里XX的值不要超过5000个。 值过多虽然上线很快，但会引起主从同步延迟。</p>
</li>
<li><p>【建议】SELECT语句不要使用UNION，推荐使用UNION ALL，并且UNION子句个数限制在5个以内。</p>
</li>
<li><p>【建议】线上环境，多表 JOIN 不要超过5个表。</p>
</li>
<li><p>【建议】减少使用ORDER BY，和业务沟通能不排序就不排序，或将排序放到程序端去做。ORDER BY、GROUP BY、DISTINCT 这些语句较为耗费CPU，数据库的CPU资源是极其宝贵的。</p>
</li>
<li><p>【建议】包含了ORDER BY、GROUP BY、DISTINCT 这些查询的语句，WHERE 条件过滤出来的结果集请保持在1000行以内，否则SQL会很慢。</p>
</li>
<li><p>【建议】对单表的多次alter操作必须合并为一次。对于超过100W行的大表进行alter table，必须经过DBA审核，并在业务低峰期执行，多个alter需整合在一起。 因为alter table会产生<code>表锁</code>，期间阻塞对于该表的所有写入，对于业务可能会产生极大影响。</p>
</li>
<li><p>【建议】批量操作数据时，需要控制事务处理间隔时间，进行必要的sleep。 </p>
</li>
<li><p>【建议】事务里包含SQL不超过5个。因为过长的事务会导致锁数据较久，MySQL内部缓存、连接消耗过多等问题。</p>
</li>
<li><p>【建议】事务里更新语句尽量基于主键或UNIQUE KEY，如UPDATE… WHERE id=XX;否则会产生间隙锁，内部扩大锁定范围，导致系统性能下降，产生死锁。</p>
</li>
</ol>
<h3 id="第12章-数据库其它调优策略"><a href="#第12章-数据库其它调优策略" class="headerlink" title="第12章 数据库其它调优策略"></a>第12章 数据库其它调优策略</h3><h4 id="1-数据库调优的措施"><a href="#1-数据库调优的措施" class="headerlink" title="1. 数据库调优的措施"></a><strong>1.</strong> <strong>数据库调优的措施</strong></h4><h5 id="1-1-调优的目标"><a href="#1-1-调优的目标" class="headerlink" title="1.1 调优的目标"></a><strong>1.1</strong> <strong>调优的目标</strong></h5><ul>
<li>尽可能<code>节省系统资源</code>，以便系统可以提供更大负荷的服务。（吞吐量更大）</li>
<li>合理的结构设计和参数调整，以提高用户操<code> 响应的速度</code>。（响应速度更快）</li>
<li>减少系统的瓶颈，提高MySQL数据库整体的性能。</li>
</ul>
<h5 id="1-2-如何定位调优问题"><a href="#1-2-如何定位调优问题" class="headerlink" title="1.2 如何定位调优问题"></a><strong>1.2</strong> <strong>如何定位调优问题</strong></h5><ul>
<li><strong>用户的反馈（主要）</strong></li>
<li><strong>日志分析（主要）</strong></li>
<li><strong>服务器资源使用监控</strong></li>
<li><strong>数据库内部状况监控</strong></li>
<li><strong>其它</strong></li>
</ul>
<h5 id="1-3-调优的维度和步骤"><a href="#1-3-调优的维度和步骤" class="headerlink" title="1.3 调优的维度和步骤"></a><strong>1.3</strong> <strong>调优的维度和步骤</strong></h5><p><strong>第1步：选择适合的</strong> <strong>DBMS</strong> </p>
<p><strong>第2步：优化表设计</strong> </p>
<p><strong>第3步：优化逻辑查询</strong></p>
<p><strong>第4步：优化物理查询</strong></p>
<p>物理查询优化是在确定了逻辑查询优化之后，采用物理优化技术（比如索引等），通过计算代价模型对各种可能的访问路径进行估算，从而找到执行方式中代价最小的作为执行计划。</p>
<p><strong>第5步：使用</strong> <strong>Redis</strong> <strong>或</strong> <strong>Memcached</strong> <strong>作为缓存</strong></p>
<p><strong>第6步：库级优化</strong> </p>
<p><strong>1、读写分离</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202204031025279.png" alt="image-20220403102536170"></p>
<p><strong>2、数据分片</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202204031026743.png" alt="image-20220403102618627"></p>
<h4 id="2-优化MySQL服务器"><a href="#2-优化MySQL服务器" class="headerlink" title="2. 优化MySQL服务器"></a><strong>2.</strong> <strong>优化MySQL服务器</strong></h4><h5 id="2-1-优化服务器硬件"><a href="#2-1-优化服务器硬件" class="headerlink" title="2.1 优化服务器硬件"></a><strong>2.1</strong> <strong>优化服务器硬件</strong></h5><p><strong>服务器的硬件性能直接决定着MySQL数据库的性能。</strong>硬件的性能瓶颈直接决定MySQL数据库的运行速度和效率。针对性能瓶颈提高硬件配置，可以提高MySQL数据库查询、更新的速度。 </p>
<p>（1）<code>配置较大的内存</code></p>
<p>（2）<code>配置高速磁盘系统</code></p>
<p>（3）<code>合理分布磁盘I/O</code></p>
<p>（4）<code>配置多处理器</code></p>
<h5 id="2-2-优化MySQL的参数"><a href="#2-2-优化MySQL的参数" class="headerlink" title="2.2 优化MySQL的参数"></a><strong>2.2</strong> <strong>优化MySQL的参数</strong></h5><ul>
<li><code>innodb_buffer_pool_size</code>：这个参数是Mysql数据库最重要的参数之一，表示InnoDB类型的<code>表和索引的最大缓存</code>。它不仅仅缓存<code>索引数据</code>，还会缓存<code>表的数据</code>。这个值越大，查询的速度就会越快。但是这个值太大会影响操作系统的性能。</li>
<li><code>key_buffer_size</code>：表示<code>索引缓冲区的大小</code>。索引缓冲区是所有的<code>线程共享</code>。增加索引缓冲区可以得到更好处理的索引（对所有读和多重写）。当然，这个值不是越大越好，它的大小取决于内存的大小。如果这个值太大，就会导致操作系统频繁换页，也会降低系统性能。对于内存在<code>4GB</code>左右的服务器该参数可设置为<code>256M</code>或<code>384M</code>。</li>
<li><code>table_cache</code>：表示<code>同时打开的表的个数</code>。这个值越大，能够同时打开的表的个数越多。物理内存越大，设置就越大。默认为2402，调到512-1024最佳。这个值不是越大越好，因为同时打开的表太多会影响操作系统的性能。</li>
<li><code>query_cache_size</code>：表示<code>查询缓冲区的大小</code>。可以通过在MySQL控制台观察，如果Qcache_lowmem_prunes的值非常大，则表明经常出现缓冲不够的情况，就要增加Query_cache_size的值；如果Qcache_hits的值非常大，则表明查询缓冲使用非常频繁，如果该值较小反而会影响效率，那么可以考虑不用查询缓存；Qcache_free_blocks，如果该值非常大，则表明缓冲区中碎片很多。MySQL8.0之后失效。该参数需要和query_cache_type配合使用。</li>
<li><code>query_cache_type</code>的值是0时，所有的查询都不使用查询缓存区。但是query_cache_type=0并不会导致MySQL释放query_cache_size所配置的缓存区内存。<ul>
<li>当query_cache_type=1时，所有的查询都将使用查询缓存区，除非在查询语句中指定<code>SQL_NO_CACHE</code>，如SELECT SQL_NO_CACHE * FROM tbl_name。 </li>
<li>当query_cache_type=2时，只有在查询语句中使用<code>SQL_CACHE</code>关键字，查询才会使用查询缓存区。使用查询缓存区可以提高查询的速度，这种方式只适用于修改操作少且经常执行相同的查询操作的情况。</li>
</ul>
</li>
<li><code>sort_buffer_size</code>：表示每个<code>需要进行排序的线程分配的缓冲区的大小</code>。增加这个参数的值可以提高<code>ORDER BY</code>或<code>GROUP BY</code>操作的速度。默认数值是2 097 144字节（约2MB）。对于内存在4GB左右的服务器推荐设置为6-8M，如果有100个连接，那么实际分配的总共排序缓冲区大小为100 × 6 ＝ 600MB。 </li>
<li><code>join_buffer_size = 8M</code>：表示<code>联合查询操作所能使用的缓冲区大小</code>，和sort_buffer_size一样，该参数对应的分配内存也是每个连接独享。</li>
<li><code>read_buffer_size</code>：表示<code>每个线程连续扫描时为扫描的每个表分配的缓冲区的大小（字节）</code>。当线程从表中连续读取记录时需要用到这个缓冲区。SET SESSION read_buffer_size=n可以临时设置该参数的值。默认为64K，可以设置为4M。 </li>
<li><code>innodb_flush_log_at_trx_commit</code>：表示<code>何时将缓冲区的数据写入日志文件</code>，并且将日志文件写入磁盘中。该参数对于innoDB引擎非常重要。该参数有3个值，分别为0、1和2。该参数的默认值为1。<ul>
<li>值为<code>0</code>时，表示<code>每秒1次</code>的频率将数据写入日志文件并将日志文件写入磁盘。每个事务的commit并不会触发前面的任何操作。该模式速度最快，但不太安全，mysqld进程的崩溃会导致上一秒钟所有事务数据的丢失。</li>
<li>值为<code>1</code>时，表示<code>每次提交事务时</code>将数据写入日志文件并将日志文件写入磁盘进行同步。该模式是最安全的，但也是最慢的一种方式。因为每次事务提交或事务外的指令都需要把日志写入（flush）硬盘。</li>
<li>值为<code>2</code>时，表示<code>每次提交事务时</code>将数据写入日志文件，<code>每隔1秒</code>将日志文件写入磁盘。该模式速度较快，也比0安全，只有在操作系统崩溃或者系统断电的情况下，上一秒钟所有事务数据才可能丢失。</li>
</ul>
</li>
<li><code>innodb_log_buffer_size</code>：这是 InnoDB 存储引擎的<code>事务日志所使用的缓冲区</code>。为了提高性能，也是先将信息写入 Innodb Log Buffer 中，当满足 innodb_flush_log_trx_commit 参数所设置的相应条件（或者日志缓冲区写满）之后，才会将日志写到文件（或者同步到磁盘）中。</li>
<li><code>max_connections</code>：表示 允许连接到MySQL数据库的最大数量 ，默认值是 151 。如果状态变量connection_errors_max_connections 不为零，并且一直增长，则说明不断有连接请求因数据库连接数已达到允许最大值而失败，这是可以考虑增大max_connections 的值。在Linux 平台下，性能好的服务器，支持 500-1000 个连接不是难事，需要根据服务器性能进行评估设定。这个连接数 不是越大 越好 ，因为这些连接会浪费内存的资源。过多的连接可能会导致MySQL服务器僵死。</li>
<li><code>back_log</code>：用于<code>控制MySQL监听TCP端口时设置的积压请求栈大小</code>。如果MySql的连接数达到max_connections时，新来的请求将会被存在堆栈中，以等待某一连接释放资源，该堆栈的数量即back_log，如果等待连接的数量超过back_log，将不被授予连接资源，将会报错。5.6.6 版本之前默认值为 50 ， 之后的版本默认为 50 + （max_connections / 5）， 对于Linux系统推荐设置为小于512的整数，但最大不超过900。如果需要数据库在较短的时间内处理大量连接请求， 可以考虑适当增大back_log 的值。</li>
<li><code>thread_cache_size</code>：<code>线程池缓存线程数量的大小</code>，当客户端断开连接后将当前线程缓存起来，当在接到新的连接请求时快速响应无需创建新的线程 。这尤其对那些使用短连接的应用程序来说可以极大的提高创建连接的效率。那么为了提高性能可以增大该参数的值。默认为60，可以设置为120。</li>
<li><code>wait_timeout</code>：指定<code>一个请求的最大连接时间</code>，对于4GB左右内存的服务器可以设置为5-10。 </li>
<li><code>interactive_timeout</code>：表示服务器在关闭连接前等待行动的秒数。</li>
</ul>
<h4 id="3-优化数据库结构"><a href="#3-优化数据库结构" class="headerlink" title="3. 优化数据库结构"></a><strong>3.</strong> <strong>优化数据库结构</strong></h4><h5 id="3-1-拆分表：冷热数据分离"><a href="#3-1-拆分表：冷热数据分离" class="headerlink" title="3.1 拆分表：冷热数据分离"></a><strong>3.1</strong> <strong>拆分表：冷热数据分离</strong></h5><h5 id="3-2-增加中间表"><a href="#3-2-增加中间表" class="headerlink" title="3.2 增加中间表"></a><strong>3.2</strong> <strong>增加中间表</strong></h5><h5 id="3-3-增加冗余字段"><a href="#3-3-增加冗余字段" class="headerlink" title="3.3 增加冗余字段"></a><strong>3.3</strong> <strong>增加冗余字段</strong></h5><h5 id="3-4-优化数据类型"><a href="#3-4-优化数据类型" class="headerlink" title="3.4 优化数据类型"></a><strong>3.4</strong> <strong>优化数据类型</strong></h5><p><strong>情况1：对整数类型数据进行优化。</strong></p>
<p>遇到整数类型的字段可以用<code>INT 型</code>。这样做的理由是，INT 型数据有足够大的取值范围，不用担心数据超出取值范围的问题。刚开始做项目的时候，首先要保证系统的稳定性，这样设计字段类型是可以的。但在数据量很大的时候，数据类型的定义，在很大程度上会影响到系统整体的执行效率。</p>
<p>对于<code>非负型</code>的数据（如自增ID、整型IP）来说，要优先使用无符号整型<code>UNSIGNED</code>来存储。因为无符号相对于有符号，同样的字节数，存储的数值范围更大。如tinyint有符号为-128-127，无符号为0-255，多出一倍的存储空间。</p>
<p><strong>情况2：既可以使用文本类型也可以使用整数类型的字段，要选择使用整数类型</strong>。</p>
<p>跟文本类型数据相比，大整数往往占用<code>更少的存储空间</code>，因此，在存取和比对的时候，可以占用更少的内存空间。所以，在二者皆可用的情况下，尽量使用整数类型，这样可以提高查询的效率。如：将IP地址转换成整型数据。</p>
<p><strong>情况3：避免使用TEXT、BLOB数据类型</strong></p>
<p><strong>情况4：避免使用ENUM类型</strong></p>
<p><strong>情况5：使用TIMESTAMP存储时间</strong></p>
<p><strong>情况6：用DECIMAL代替FLOAT和DOUBLE存储精确浮点数</strong></p>
<p><strong>总之，遇到数据量大的项目时，一定要在充分了解业务需求的前提下，合理优化数据类型，这样才能充分发挥资源的效率，使系统达到最优</strong>。</p>
<h5 id="3-5-优化插入记录的速度"><a href="#3-5-优化插入记录的速度" class="headerlink" title="3.5 优化插入记录的速度"></a><strong>3.5</strong> <strong>优化插入记录的速度</strong></h5><p><strong>1. MyISAM引擎的表：</strong></p>
<p><strong>① 禁用索引</strong></p>
<p><strong>② 禁用唯一性检查</strong></p>
<p><strong>③ 使用批量插入</strong></p>
<p><strong>④ 使用LOAD DATA INFILE 批量导入</strong></p>
<p><strong>2. InnoDB引擎的表：</strong></p>
<p> <strong>① 禁用唯一性检查</strong></p>
<p><strong>② 禁用外键检查</strong></p>
<p><strong>③ 禁止自动提交</strong></p>
<h5 id="3-6-使用非空约束"><a href="#3-6-使用非空约束" class="headerlink" title="3.6 使用非空约束"></a><strong>3.6</strong> <strong>使用非空约束</strong></h5><p><strong>在设计字段的时候，如果业务允许，建议尽量使用非空约束</strong></p>
<h5 id="3-7-分析表、检查表与优化表"><a href="#3-7-分析表、检查表与优化表" class="headerlink" title="3.7 分析表、检查表与优化表"></a><strong>3.7</strong> <strong>分析表、检查表与优化表</strong></h5><p><strong>1.</strong> <strong>分析表</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ANALYZE [LOCAL | NO_WRITE_TO_BINLOG] TABLE tbl_name[,tbl_name]…</span><br></pre></td></tr></table></figure>

<p>默认的，MySQL服务会将 ANALYZE TABLE语句写到binlog中，以便在主从架构中，从服务能够同步数据。可以添加参数LOCAL 或者 NO_WRITE_TO_BINLOG取消将语句写到binlog中。</p>
<p>使用<code>ANALYZE TABLE</code>分析表的过程中，数据库系统会自动对表加一个<code>只读锁</code>。在分析期间，只能读取表中的记录，不能更新和插入记录。ANALYZE TABLE语句能够分析InnoDB和MyISAM类型的表，但是不能作用于视图。</p>
<p>ANALYZE TABLE分析后的统计结果会反应到<code>cardinality</code>的值，该值统计了表中某一键所在的列不重复的值的个数。<strong>该值越接近表中的总行数，则在表连接查询或者索引查询时，就越优先被优化器选择使用。</strong></p>
<p><strong>2.</strong> <strong>检查表</strong> </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CHECK TABLE tbl_name [, tbl_name] ... [option] ... option &#x3D; &#123;QUICK | FAST | MEDIUM | EXTENDED | CHANGED&#125;</span><br></pre></td></tr></table></figure>

<p>MySQL中可以使用<code>CHECK TABLE</code>语句来检查表。CHECK TABLE语句能够检查InnoDB和MyISAM类型的表是否存在错误。CHECK TABLE语句在执行过程中也会给表加上<code>只读锁</code>。</p>
<p><strong>3.</strong> <strong>优化表</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">OPTIMIZE [LOCAL | NO_WRITE_TO_BINLOG] TABLE tbl_name [, tbl_name] ...</span><br></pre></td></tr></table></figure>

<p>MySQL中使用<code>OPTIMIZE TABLE</code>语句来优化表。但是，OPTILMIZE TABLE语句只能优化表中的<code>VARCHAR</code>、<code>BLOB</code>或<code>TEXT</code>类型的字段。一个表使用了这些字段的数据类型，若已经<code>删除</code>了表的一大部分数据，或者已经对含有可变长度行的表（含有VARCHAR、BLOB或TEXT列的表）进行了很多<code>更新</code>，则应使用OPTIMIZE TABLE来重新利用未使用的空间，并整理数据文件的<code>碎片</code>。 </p>
<p>OPTIMIZE TABLE 语句对InnoDB和MyISAM类型的表都有效。该语句在执行过程中也会给表加上<code>只读锁</code>。</p>
<h3 id="第13章-事务基础知识"><a href="#第13章-事务基础知识" class="headerlink" title="第13章 事务基础知识"></a>第13章 事务基础知识</h3><h4 id="1-数据库事务概述"><a href="#1-数据库事务概述" class="headerlink" title="1. 数据库事务概述"></a><strong>1.</strong> <strong>数据库事务概述</strong></h4><h5 id="1-1-基本概念"><a href="#1-1-基本概念" class="headerlink" title="1.1 基本概念"></a><strong>1.1</strong> <strong>基本概念</strong></h5><p><strong>事务：</strong>一组逻辑操作单元，使数据从一种状态变换到另一种状态。</p>
<p><strong>事务处理的原则：</strong>保证所有事务都作为<code>一个工作单元</code>来执行，即使出现了故障，都不能改变这种执行方式。当在一个事务中执行多个操作时，要么所有的事务都被提交(<code>commit</code>)，那么这些修改就<code>永久</code>地保存下来；要么数据库管理系统将<code>放弃</code>所作的所有<code>修改</code>，整个事务回滚(<code>rollback</code>)到最初状态。</p>
<h5 id="1-2-事务的ACID特性"><a href="#1-2-事务的ACID特性" class="headerlink" title="1.2 事务的ACID特性"></a><strong>1.2</strong> <strong>事务的ACID特性</strong></h5><ul>
<li><strong>原子性（atomicity）：</strong></li>
</ul>
<p>原子性是指事务是一个不可分割的工作单位，要么全部提交，要么全部失败回滚。</p>
<ul>
<li><strong>一致性（consistency）：</strong></li>
</ul>
<p>一致性是指事务执行前后，数据从一个<code>合法性状态</code>变换到另外一个<code>合法性状态</code>。这种状态是<code>语义上</code>的而不是语法上的，跟具体的业务有关。</p>
<ul>
<li><strong>隔离型（isolation）：</strong></li>
</ul>
<p>事务的隔离性是指一个事务的执行<code>不能被其他事务干扰</code>，即一个事务内部的操作及使用的数据对<code>并发</code>的其他事务是隔离的，并发执行的各个事务之间不能互相干扰。</p>
<ul>
<li><strong>持久性（durability）：</strong></li>
</ul>
<p>持久性是指一个事务一旦被提交，它对数据库中数据的改变就是<code>永久性的</code>，接下来的其他操作和数据库故障不应该对其有任何影响。</p>
<p>持久性是通过<code>事务日志</code>来保证的。日志包括了<code>重做日志</code>和<code>回滚日志</code>。当我们通过事务对数据进行修改的时候，首先会将数据库的变化信息记录到重做日志中，然后再对数据库中对应的行进行修改。这样做的好处是，即使数据库系统崩溃，数据库重启后也能找到没有更新到数据库系统中的重做日志，重新执行，从而使事务具有持久性。</p>
<h5 id="1-3-事务的状态"><a href="#1-3-事务的状态" class="headerlink" title="1.3 事务的状态"></a><strong>1.3</strong> <strong>事务的状态</strong></h5><ul>
<li><strong>活动的（active）</strong></li>
</ul>
<p>事务对应的数据库操作正在执行过程中时，我们就说该事务处在<code>活动的</code>状态。</p>
<ul>
<li><strong>部分提交的（partially committed）</strong></li>
</ul>
<p>当事务中的最后一个操作执行完成，但由于操作都在内存中执行，所造成的影响并<code>没有刷新到磁盘</code>时，我们就说该事务处在<code>部分提交的</code>状态。</p>
<ul>
<li><strong>失败的（failed）</strong></li>
</ul>
<p>当事务处在<code>活动的</code>或者<code>部分提交的</code>状态时，可能遇到了某些错误（数据库自身的错误、操作系统错误或者直接断电等）而无法继续执行，或者人为的停止当前事务的执行，我们就说该事务处在<code>失败的</code>状态。</p>
<ul>
<li><strong>中止的（aborted）</strong></li>
</ul>
<p>如果事务执行了一部分而变为<code>失败的</code>状态，那么就需要把已经修改的事务中的操作还原到事务执行前的状态。换句话说，就是要撤销失败事务对当前数据库造成的影响。我们把这个撤销的过程称之为<code>回滚</code>。当<code>回滚</code>操作执行完毕时，也就是数据库恢复到了执行事务之前的状态，我们就说该事务处在了<code>中止的</code>状态。</p>
<ul>
<li><strong>提交的（committed）</strong></li>
</ul>
<p>当一个处在<code>部分提交的</code>状态的事务将修改过的数据都<code>同步到磁盘</code>上之后，我们就可以说该事务处在了<code>提交的</code>状态。</p>
<p><img src="https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202204031104063.png" alt="image-20220403110448951"></p>
<h4 id="2-如何使用事务"><a href="#2-如何使用事务" class="headerlink" title="2. 如何使用事务"></a><strong>2.</strong> <strong>如何使用事务</strong></h4><h5 id="2-1-显式事务"><a href="#2-1-显式事务" class="headerlink" title="2.1 显式事务"></a><strong>2.1</strong> <strong>显式事务</strong></h5><p><strong>步骤1：</strong> <code>START TRANSACTION</code>或者<code>BEGIN</code>，作用是显式开启一个事务。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; BEGIN; </span><br><span class="line">#或者 </span><br><span class="line">mysql&gt; START TRANSACTION;</span><br></pre></td></tr></table></figure>

<p><code>START TRANSACTION</code>语句相较于<code>BEGIN</code>特别之处在于，后边能跟随几个<code>修饰符</code>： </p>
<p>①<code>READ ONLY</code>：标识当前事务是一个<code>只读事务</code>，也就是属于该事务的数据库操作只能读取数据，而不能修改数据。</p>
<p>②<code>READ WRITE</code>：标识当前事务是一个<code>读写事务</code>，也就是属于该事务的数据库操作既可以读取数据，也可以修改数据。</p>
<p>③<code>WITH CONSISTENT SNAPSHOT</code>：启动一致性读。</p>
<p><strong>步骤2：</strong>一系列事务中的操作（主要是DML，不含DDL）</p>
<p><strong>步骤3：</strong>提交事务 或 中止事务（即回滚事务）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 提交事务。当提交事务后，对数据库的修改是永久性的。</span><br><span class="line">mysql&gt; COMMIT;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 回滚事务。即撤销正在进行的所有没有提交的修改 </span><br><span class="line">mysql&gt; ROLLBACK; </span><br><span class="line"></span><br><span class="line"># 将事务回滚到某个保存点。 </span><br><span class="line">mysql&gt; ROLLBACK TO [SAVEPOINT]</span><br></pre></td></tr></table></figure>

<p>其中关于SAVEPOINT相关操作有：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 在事务中创建保存点，方便后续针对保存点进行回滚。一个事物中可以存在多个保存点。</span><br><span class="line">SAVEPOINT 保存点名称;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 删除某个保存点</span><br><span class="line">RELEASE SAVEPOINT 保存点名称;</span><br></pre></td></tr></table></figure>

<h5 id="2-2-隐式事务"><a href="#2-2-隐式事务" class="headerlink" title="2.2 隐式事务"></a><strong>2.2</strong> <strong>隐式事务</strong></h5><ul>
<li>显式的的使用<code>START TRANSACTION</code>或者<code>BEGIN</code>语句开启一个事务。这样在本次事务提交或者回滚前会暂时关闭掉自动提交的功能。</li>
<li>把系统变量<code>autocommit</code>的值设置为<code>OFF</code></li>
</ul>
<h5 id="2-3-隐式提交数据的情况"><a href="#2-3-隐式提交数据的情况" class="headerlink" title="2.3 隐式提交数据的情况"></a><strong>2.3</strong> <strong>隐式提交数据的情况</strong></h5><ul>
<li><p><strong>数据定义语言（Data definition language，缩写为：DDL）</strong></p>
</li>
<li><p><strong>隐式使用或修改mysql数据库中的表</strong></p>
</li>
<li><p><strong>事务控制或关于锁定的语句</strong></p>
<ul>
<li> 当我们在一个事务还没提交或者回滚时就又使用<code>START TRANSACTION</code>或者<code>BEGIN</code>语句开启了另一个事务时，会<code>隐式的提交</code>上一个事务。</li>
<li>当前的<code>autocommit</code>系统变量的值为<code>OFF</code>，我们手动把它调为<code>ON</code>时，也会<code>隐式的提交</code>前边语句所属的事务。</li>
<li>使用<code>LOCK TABLES</code>、<code>UNLOCK TABLES</code>等关于锁定的语句也会<code>隐式的提交</code>前边语句所属的事务。</li>
</ul>
</li>
</ul>
<h4 id="3-事务隔离级别"><a href="#3-事务隔离级别" class="headerlink" title="3. 事务隔离级别"></a><strong>3.</strong> <strong>事务隔离级别</strong></h4><h5 id="3-1-数据并发问题"><a href="#3-1-数据并发问题" class="headerlink" title="3.1 数据并发问题"></a><strong>3.1</strong> <strong>数据并发问题</strong></h5><p><strong>1.</strong> <strong>脏写（</strong><code>Dirty Write</code><strong>）</strong></p>
<p>对于两个事务 Session A、Session B，如果事务Session A<code>修改了</code>另一个<code>未提交</code>事务Session B<code>修改过</code>的数据，那就意味着发生了<code>脏写</code></p>
<p><img src="https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202204031124086.png" alt="image-20220403112416944"></p>
<p><strong>2.</strong> <strong>脏读（</strong><code>Dirty Read</code><strong>）</strong></p>
<p>对于两个事务 Session A、Session B，Session A<code>读取</code>了已经被 Session B<code>更新</code>但还<code>没有被提交</code>的字段。之后若 Session B<code>回滚</code>，Session A<code>读取</code>的内容就是<code>临时且无效</code>的。</p>
<p><img src="https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202204031124136.png" alt="image-20220403112435995"></p>
<p><strong>3.</strong> <strong>不可重复读（</strong><code>Non-Repeatable Read</code><strong>）</strong></p>
<p>对于两个事务Session A、Session B，Session A<code>读取</code>了一个字段，然后 Session B<code>更新</code>了该字段。 之后Session A<code>再次读取</code>同一个字段，<code>值就不同</code>了。那就意味着发生了不可重复读。</p>
<p><img src="https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202204031124331.png" alt="image-20220403112458183"></p>
<p><strong>4.</strong> <strong>幻读（</strong><code>Phantom</code><strong>）</strong></p>
<p>对于两个事务Session A、Session B, Session A 从一个表中<code>读取</code>了一个字段, 然后 Session B 在该表中<code>插入</code>了一些新的行。 之后, 如果 Session A<code>再次读取</code>同一个表, 就会多出几行。那就意味着发生了幻读。</p>
<p><img src="https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202204031125847.png" alt="image-20220403112514712"></p>
<p><strong>注意1：</strong></p>
<p>有的同学会有疑问，那如果Session B中<code>剔除了</code>一些符合<code>studentno &gt; 0</code>的记录而不是插入新记录，那么Session A之后再根据<code>studentno &gt; 0</code>的条件读取的<code>记录变少了</code>，这种现象算不算<code>幻读</code>呢？这种现象<code>不属于幻读</code>，幻读强调的是一个事物按照某个<code>相同条件多次读取</code>记录时，后读取时读到了之前<code>没有读到的记录</code>。</p>
<p><strong>注意2：</strong></p>
<p>那对于先前已经读到的记录，之后又读取不到这种情况，算啥呢？这相当于对每一条记录都发生了<code>不可重复读</code>的现象。幻读只是重点强调了读取到之前读取没有获取到的记录。</p>
<h5 id="3-2-SQL中的四种隔离级别"><a href="#3-2-SQL中的四种隔离级别" class="headerlink" title="3.2 SQL中的四种隔离级别"></a><strong>3.2 SQL中的四种隔离级别</strong></h5><p><code>SQL标准</code>中设立了4个<code>隔离级别</code>：</p>
<ul>
<li><code>READ UNCOMMITTED</code>：读未提交，在该隔离级别，所有事务都可以看到其他未提交事务的执行结果。不能避免脏读、不可重复读、幻读。</li>
<li><code>READ COMMITTED</code>：读已提交，它满足了隔离的简单定义：一个事务只能看见已经提交事务所做的改变。这是大多数数据库系统的默认隔离级别（但不是MySQL默认的）。可以避免脏读，但不可重复读、幻读问题仍然存在。</li>
<li><code>REPEATABLE READ</code>：可重复读，事务A在读到一条数据之后，此时事务B对该数据进行了修改并提交，那么事务A再读该数据，读到的还是原来的内容。可以避免脏读、不可重复读，但幻读问题仍然存在。<code>这是MySQL的默认隔离级别</code>。</li>
<li><code>SERIALIZABLE</code>：可串行化，确保事务可以从一个表中读取相同的行。在这个事务持续期间，禁止其他事务对该表执行插入、更新和删除操作。所有的并发问题都可以避免，但性能十分低下。能避免脏读、不可重复读和幻读。</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202204031127542.png" alt="image-20220403112740425"></p>
<h5 id="3-3-如何设置事务的隔离级别"><a href="#3-3-如何设置事务的隔离级别" class="headerlink" title="3.3 如何设置事务的隔离级别"></a><strong>3.3</strong> <strong>如何设置事务的隔离级别</strong></h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SET [GLOBAL|SESSION] TRANSACTION ISOLATION LEVEL 隔离级别; </span><br><span class="line">#其中，隔离级别格式： </span><br><span class="line">&gt; READ UNCOMMITTED </span><br><span class="line">&gt; READ COMMITTED </span><br><span class="line">&gt; REPEATABLE READ </span><br><span class="line">&gt; SERIALIZABLE</span><br></pre></td></tr></table></figure>

<p>或者：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SET [GLOBAL|SESSION] TRANSACTION_ISOLATION &#x3D; &#39;隔离级别&#39; </span><br><span class="line">#其中，隔离级别格式： </span><br><span class="line">&gt; READ-UNCOMMITTED </span><br><span class="line">&gt; READ-COMMITTED </span><br><span class="line">&gt; REPEATABLE-READ </span><br><span class="line">&gt; SERIALIZABLE</span><br></pre></td></tr></table></figure>

<h3 id="第14章-MySQL事务日志"><a href="#第14章-MySQL事务日志" class="headerlink" title="第14章 MySQL事务日志"></a>第14章 MySQL事务日志</h3><p>事务有4种特性：原子性、一致性、隔离性和持久性。那么事务的四种特性到底是基于什么机制实现呢？</p>
<ul>
<li>事务的隔离性由<code>锁机制</code>实现。</li>
<li>而事务的原子性、一致性和持久性由事务的 redo 日志和undo 日志来保证。<ul>
<li>REDO LOG 称为<code>重做日志</code>，提供再写入操作，恢复提交事务修改的页操作，用来保证事务的持久性。</li>
<li>UNDO LOG 称为<code>回滚日志</code>，回滚行记录到某个特定版本，用来保证事务的原子性、一致性。</li>
</ul>
</li>
</ul>
<h4 id="1-redo日志"><a href="#1-redo日志" class="headerlink" title="1. redo日志"></a><strong>1. redo日志</strong></h4><h5 id="1-1-为什么需要REDO日志"><a href="#1-1-为什么需要REDO日志" class="headerlink" title="1.1 为什么需要REDO日志"></a><strong>1.1</strong> <strong>为什么需要REDO日志</strong></h5><p>一方面，缓冲池可以帮助我们消除CPU和磁盘之间的鸿沟，checkpoint机制可以保证数据的最终落盘，然而由于checkpoint<code>并不是每次变更的时候就触发</code>的，而是master线程隔一段时间去处理的。所以最坏的情况就是事务提交后，刚写完缓冲池，数据库宕机了，那么这段数据就是丢失的，无法恢复。</p>
<p>另一方面，事务包含<code>持久性</code>的特性，就是说对于一个已经提交的事务，在事务提交后即使系统发生了崩溃，这个事务对数据库中所做的更改也不能丢失。</p>
<p>那么如何保证这个持久性呢？<code>一个简单的做法</code>：在事务提交完成之前把该事务所修改的所有页面都刷新到磁盘，但是这个简单粗暴的做法有些问题</p>
<p><code>另一个解决的思路</code>：我们只是想让已经提交了的事务对数据库中数据所做的修改永久生效，即使后来系统崩溃，在重启后也能把这种修改恢复出来。所以我们其实没有必要在每次事务提交时就把该事务在内存中修改过的全部页面刷新到磁盘，只需要把<code>修改</code>了哪些东西<code>记录一下</code>就好。比如，某个事务将系统表空间中<code>第10号</code>页面中偏移量为<code>100</code>处的那个字节的值<code>1</code>改成<code>2</code>。我们只需要记录一下：将第0号表空间的10号页面的偏移量为100处的值更新为 2 。</p>
<h5 id="1-2-REDO日志的好处、特点"><a href="#1-2-REDO日志的好处、特点" class="headerlink" title="1.2 REDO日志的好处、特点"></a><strong>1.2 REDO日志的好处、特点</strong></h5><p><strong>1.</strong> <strong>好处</strong></p>
<ul>
<li><strong>redo日志降低了刷盘频率</strong></li>
<li><strong>redo日志占用的空间非常小</strong></li>
</ul>
<p><strong>2.</strong> <strong>特点</strong></p>
<ul>
<li><strong>redo日志是顺序写入磁盘的</strong></li>
<li><strong>事务执行过程中，redo log不断记录</strong></li>
</ul>
<h5 id="1-3-redo的组成"><a href="#1-3-redo的组成" class="headerlink" title="1.3 redo的组成"></a><strong>1.3 redo的组成</strong></h5><p>Redo log可以简单分为以下两个部分：</p>
<ul>
<li><code>重做日志的缓冲 (redo log buffer) </code>，保存在内存中，是易失的。</li>
</ul>
<p><strong>参数设置：innodb_log_buffer_size：</strong></p>
<p>redo log buffer 大小，默认<code>16M</code>，最大值是4096M，最小值为1M。 </p>
<ul>
<li><code>重做日志文件 (redo log file)</code>，保存在硬盘中，是持久的。</li>
</ul>
<h5 id="1-4-redo的整体流程"><a href="#1-4-redo的整体流程" class="headerlink" title="1.4 redo的整体流程"></a><strong>1.4 redo的整体流程</strong></h5><p><img src="https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202204031147714.png" alt="image-20220403114709581"></p>
<p>第1步：先将原始数据从磁盘中读入内存中来，修改数据的内存拷贝 </p>
<p>第2步：生成一条重做日志并写入redo log buffer，记录的是数据被修改后的值 </p>
<p>第3步：当事务commit时，将redo log buffer中的内容刷新到 redo log file，对 redo log file采用追加写的方式 </p>
<p>第4步：定期将内存中修改的数据刷新到磁盘中</p>
<blockquote>
<p>Write-Ahead Log(预先日志持久化)：在持久化一个数据页之前，先将内存中相应的日志页持久化。</p>
</blockquote>
<h5 id="1-5-redo-log的刷盘策略"><a href="#1-5-redo-log的刷盘策略" class="headerlink" title="1.5 redo log的刷盘策略"></a><strong>1.5 redo log的刷盘策略</strong></h5><p>redo log buffer刷盘到redo log file的过程并不是真正的刷到磁盘中去，只是刷入到<code>文件系统缓存</code>（page cache）中去（这是现代操作系统为了提高文件写入效率做的一个优化），真正的写入会交给系统自己来决定（比如page cache足够大了）。那么对于InnoDB来说就存在一个问题，如果交给系统来同步，同样如果系统宕机，那么数据也丢失了（虽然整个系统宕机的概率还是比较小的）。</p>
<p>针对这种情况，InnoDB给出<code>innodb_flush_log_at_trx_commit</code>参数，该参数控制 commit提交事务时，如何将 redo log buffer 中的日志刷新到 redo log file 中。它支持三种策略：</p>
<ul>
<li><code>设置为0</code>：表示每次事务提交时不进行刷盘操作。（系统默认master thread每隔1s进行一次重做日志的同步）</li>
<li><code>设置为1</code>：表示每次事务提交时都将进行同步，刷盘操作（<code>默认值</code>） </li>
<li><code>设置为2</code>：表示每次事务提交时都只把 redo log buffer 内容写入 page cache，不进行同步。由os自己决定什么时候同步到磁盘文件。</li>
</ul>
<h5 id="1-6-不同刷盘策略演示"><a href="#1-6-不同刷盘策略演示" class="headerlink" title="1.6 不同刷盘策略演示"></a><strong>1.6</strong> <strong>不同刷盘策略演示</strong></h5><p><strong>1.</strong> <strong>流程图</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202204031152952.png" alt="image-20220403115232833"></p>
<p><img src="https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202204031152607.png" alt="image-20220403115249492"></p>
<p><img src="https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202204031153931.png" alt="image-20220403115300809"></p>
<h5 id="1-7-写入redo-log-buffer过程"><a href="#1-7-写入redo-log-buffer过程" class="headerlink" title="1.7 写入redo log buffer过程"></a><strong>1.7</strong> <strong>写入redo log buffer过程</strong></h5><p><strong>1.</strong> <strong>补充概念：Mini-Transaction</strong></p>
<p>一个事务可以包含若干条语句，每一条语句其实是由若干个<code>mtr</code>组成，每一个<code>mtr</code>又可以包含若干条redo日志</p>
<p><img src="https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202204040912119.png" alt="image-20220404091224993"></p>
<p><strong>2. redo</strong> <strong>日志写入log buffer</strong></p>
<p>不同的事务可能是<code>并发</code>执行的，所以<code>事务T1</code>、<code>事务T2</code>之间的<code>mtr</code>可能是<code>交替执行</code>的。</p>
<p><img src="https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202204040915708.png" alt="image-20220404091511602"></p>
<h5 id="1-8-redo-log-file"><a href="#1-8-redo-log-file" class="headerlink" title="1.8 redo log file"></a><strong>1.8 redo log file</strong></h5><p><strong>1.</strong> <strong>相关参数设置</strong> </p>
<ul>
<li><p><code>innodb_log_group_home_dir</code>：指定 redo log 文件组所在的路径，默认值为<code>./</code>，表示在数据库的数据目录下。MySQL的默认数据目录（<code>var/lib/mysql</code>）下默认有两个名为<code>ib_logfile0</code>和<code>ib_logfile1</code>的文件，log buffer中的日志默认情况下就是刷新到这两个磁盘文件中。此redo日志文件位置还可以修改。</p>
</li>
<li><p><code>innodb_log_files_in_group</code>：指明redo log file的个数，命名方式如：ib_logfile0，ib_logfile1… ib_logfilen。默认2个，最大100个。</p>
</li>
<li><p><code>innodb_flush_log_at_trx_commit</code>：控制 redo log 刷新到磁盘的策略，默认为<code>1</code>。 </p>
</li>
<li><p><code>innodb_log_file_size</code>：单个 redo log 文件设置大小，默认值为 48M 。最大值为512G，注意最大值指的是整个 redo log 系列文件之和，即（innodb_log_files_in_group * innodb_log_file_size ）不能大于最大值512G。</p>
</li>
</ul>
<p><strong>2.</strong> <strong>日志文件组</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202204040920532.png" alt="image-20220404092038421"></p>
<p><strong>3. checkpoint</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202204040921715.png" alt="image-20220404092106617"></p>
<p>如果 write pos 追上 checkpoint ，表示<strong>日志文件组</strong>满了，这时候不能再写入新的 redo log记录，MySQL 得停下来，清空一些记录，把 checkpoint 推进一下。</p>
<h4 id="2-Undo日志"><a href="#2-Undo日志" class="headerlink" title="2. Undo日志"></a><strong>2. Undo日志</strong></h4><p>redo log是事务持久性的保证，undo log是事务原子性的保证。在事务中<code>更新数据</code>的<code>前置操作</code>其实是要先写入一个 undo log 。</p>
<h5 id="2-1-如何理解Undo日志"><a href="#2-1-如何理解Undo日志" class="headerlink" title="2.1 如何理解Undo日志"></a><strong>2.1</strong> <strong>如何理解Undo日志</strong></h5><p>事务需要保证<code>原子性</code>，也就是事务中的操作要么全部完成，要么什么也不做。但有时候事务执行到一半会出现一些情况，比如：</p>
<ul>
<li>情况一：事务执行过程中可能遇到各种错误，比如<code>服务器本身的错误</code>，<code>操作系统错误</code>，甚至是突然<code>断电</code>导致的错误。</li>
<li>情况二：程序员可以在事务执行过程中手动输入<code>ROLLBACK</code>语句结束当前事务的执行。</li>
</ul>
<p>以上情况出现，我们需要把数据改回原先的样子，这个过程称之为<code>回滚</code>，这样就可以造成一个假象：这个事务看起来什么都没做，所以符合<code>原子性</code>要求。</p>
<h5 id="2-2-Undo日志的作用"><a href="#2-2-Undo日志的作用" class="headerlink" title="2.2 Undo日志的作用"></a><strong>2.2 Undo日志的作用</strong></h5><ul>
<li><strong>作用1：回滚数据</strong></li>
<li><strong>作用2：MVCC（详情看第16章）</strong></li>
</ul>
<h5 id="2-3-undo的存储结构"><a href="#2-3-undo的存储结构" class="headerlink" title="2.3 undo的存储结构"></a><strong>2.3 undo的存储结构</strong></h5><p><strong>1.</strong> <strong>回滚段与undo页</strong></p>
<p>InnoDB对undo log的管理采用段的方式，也就是<code>回滚段（rollback segment）</code>。每个回滚段记录了<code>1024</code>个<code>undo log segment</code>，而在每个undo log segment段中进行<code>undo页</code>的申请。</p>
<p><strong>2.</strong> <strong>回滚段与事务</strong> </p>
<ol>
<li><p>每个事务只会使用一个回滚段，一个回滚段在同一时刻可能会服务于多个事务。</p>
</li>
<li><p>当一个事务开始的时候，会制定一个回滚段，在事务进行的过程中，当数据被修改时，原始的数据会被复制到回滚段。</p>
</li>
<li><p>在回滚段中，事务会不断填充盘区，直到事务结束或所有的空间被用完。如果当前的盘区不够用，事务会在段中请求扩展下一个盘区，如果所有已分配的盘区都被用完，事务会覆盖最初的盘区或者在回滚段允许的情况下扩展新的盘区来使用。</p>
</li>
<li><p>回滚段存在于undo表空间中，在数据库中可以存在多个undo表空间，但同一时刻只能使用一个undo表空间。</p>
</li>
<li><p>当事务提交时，InnoDB存储引擎会做以下两件事情：</p>
<ul>
<li>将undo log放入列表中，以供之后的purge操作</li>
<li>判断undo log所在的页是否可以重用，若可以分配给下个事务使用</li>
</ul>
</li>
</ol>
<p><strong>3.</strong> <strong>回滚段中的数据分类</strong></p>
<ol>
<li><p>未提交的回滚数据(uncommitted undo information) </p>
</li>
<li><p>已经提交但未过期的回滚数据(committed undo information) </p>
</li>
<li><p>事务已经提交并过期的数据(expired undo information) </p>
</li>
</ol>
<h5 id="2-4-undo的类型"><a href="#2-4-undo的类型" class="headerlink" title="2.4 undo的类型"></a><strong>2.4 undo的类型</strong></h5><p>在InnoDB存储引擎中，undo log分为：</p>
<ul>
<li>insert undo log </li>
<li>update undo log</li>
</ul>
<h5 id="2-5-undo-log的生命周期"><a href="#2-5-undo-log的生命周期" class="headerlink" title="2.5 undo log的生命周期"></a><strong>2.5 undo log的生命周期</strong></h5><p><strong>1.</strong> <strong>简要生成过程</strong></p>
<p><strong>只有Buffer Pool的流程：</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202204040937761.png" alt="image-20220404093706650"></p>
<p><strong>有了Redo Log和Undo Log之后：</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202204040938657.png" alt="image-20220404093832512"></p>
<p><strong>2.</strong> <strong>详细生成过程</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202204040939231.png" alt="image-20220404093950136"></p>
<p><strong>当我们执行INSERT时：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">begin; </span><br><span class="line">INSERT INTO user (name) VALUES (&quot;tom&quot;);</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202204040940543.png" alt="image-20220404094033441"></p>
<p><strong>当我们执行UPDATE时：</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202204040941624.png" alt="image-20220404094105525"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">UPDATE user SET id&#x3D;2 WHERE id&#x3D;1;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202204040941449.png" alt="image-20220404094142337"></p>
<p><strong>3. undo log是如何回滚的</strong></p>
<p>以上面的例子来说，假设执行rollback，那么对应的流程应该是这样：</p>
<ol>
<li><p>通过undo no=3的日志把id=2的数据删除</p>
</li>
<li><p>通过undo no=2的日志把id=1的数据的deletemark还原成0 </p>
</li>
<li><p>通过undo no=1的日志把id=1的数据的name还原成Tom </p>
</li>
<li><p>通过undo no=0的日志把id=1的数据删除</p>
</li>
</ol>
<p><strong>4. undo log的删除</strong></p>
<ul>
<li>针对于insert undo log</li>
</ul>
<p>因为insert操作的记录，只对事务本身可见，对其他事务不可见。故该undo log可以在事务提交后直接删除，不需要进行purge操作。</p>
<ul>
<li>针对于update undo log </li>
</ul>
<p>该undo log可能需要提供MVCC机制，因此不能在事务提交时就进行删除。提交时放入undo log链表，等待purge线程进行最后的删除。</p>
<h5 id="2-6-小结"><a href="#2-6-小结" class="headerlink" title="2.6 小结"></a><strong>2.6</strong> <strong>小结</strong></h5><p><img src="https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202204040944948.png" alt="image-20220404094436830"></p>
<p>undo log是逻辑日志，对事务回滚时，只是将数据库逻辑地恢复到原来的样子。</p>
<p>redo log是物理日志，记录的是数据页的物理变化，undo log不是redo log的逆过程。</p>
<h3 id="第15章-锁"><a href="#第15章-锁" class="headerlink" title="第15章 锁"></a>第15章 锁</h3><h4 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a><strong>1.</strong> <strong>概述</strong></h4><p>在数据库中，除传统的计算资源（如CPU、RAM、I/O等）的争用以外，数据也是一种供许多用户共享的资源。为保证数据的一致性，需要对<code>并发操作进行控制</code>，因此产生了<code>锁</code>。同时<code>锁机制</code>也为实现MySQL的各个隔离级别提供了保证。 锁冲突 也是影响数据库<code>并发访问性能</code>的一个重要因素。所以锁对数据库而言显得尤其重要，也更加复杂。</p>
<h4 id="2-MySQL并发事务访问相同记录"><a href="#2-MySQL并发事务访问相同记录" class="headerlink" title="2. MySQL并发事务访问相同记录"></a><strong>2. MySQL并发事务访问相同记录</strong></h4><h5 id="2-1-读-读情况"><a href="#2-1-读-读情况" class="headerlink" title="2.1 读-读情况"></a><strong>2.1</strong> <strong>读-读情况</strong></h5><p><code>读-读</code>情况，即并发事务相继<code>读取相同的记录</code>。读取操作本身不会对记录有任何影响，并不会引起什么问题，所以允许这种情况的发生。</p>
<h5 id="2-2-写-写情况"><a href="#2-2-写-写情况" class="headerlink" title="2.2 写-写情况"></a><strong>2.2</strong> <strong>写-写情况</strong></h5><p><code>写-写</code>情况，即并发事务相继对相同的记录做出改动。</p>
<p>在这种情况下会发生<code>脏写</code>的问题，任何一种隔离级别都不允许这种问题的发生。所以在多个未提交事务相继对一条记录做改动时，需要让它们<code>排队执行</code>，这个排队的过程其实是通过<code>锁</code>来实现的。</p>
<h5 id="2-3-读-写或写-读情况"><a href="#2-3-读-写或写-读情况" class="headerlink" title="2.3 读-写或写-读情况"></a><strong>2.3</strong> <strong>读-写或写-读情况</strong></h5><p><code>读-写</code>或<code>写-读</code>，即一个事务进行读取操作，另一个进行改动操作。这种情况下可能发生<code>脏读</code>、<code>不可重复读</code>、<code>幻读</code>的问题。</p>
<h5 id="2-4-并发问题的解决方案"><a href="#2-4-并发问题的解决方案" class="headerlink" title="2.4 并发问题的解决方案"></a><strong>2.4</strong> <strong>并发问题的解决方案</strong></h5><p>怎么解决<code>脏读</code>、<code>不可重复读</code>、<code>幻读</code>这些问题呢？其实有两种可选的解决方案：</p>
<ul>
<li>方案一：读操作利用多版本并发控制（<code>MVCC</code>，下章讲解），写操作进行<code>加锁</code>。</li>
</ul>
<p>所谓的<code>MVCC</code>，就是生成一个<code>ReadView</code>，通过ReadView找到符合条件的记录版本（历史版本由<code>undo日志</code>构建）。查询语句只能<code>读</code>到在生成ReadView之前<code>已提交事务所做的更改</code>，在生成ReadView之前未提交的事务或者之后才开启的事务所做的更改是看不到的。而<code>写操作</code>肯定针对的是<code>最新版本的记录</code>，读记录的历史版本和改动记录的最新版本本身并不冲突，也就是采用MVCC时，<code>读-写</code>操作并不冲突。</p>
<blockquote>
<p>普通的SELECT语句在READ COMMITTED和REPEATABLE READ隔离级别下会使用到MVCC读取记录。</p>
<ul>
<li>在<code>READ COMMITTED</code>隔离级别下，一个事务在执行过程中每次执行SELECT操作时都会生成一个ReadView，ReadView的存在本身就保证了<code>事务不可以读取到未提交的事务所做的更改</code>，也就是避免了脏读现象；</li>
<li>在<code>REPEATABLE READ</code>隔离级别下，一个事务在执行过程中只有<code>第一次执行SELECT操作 </code>才会生成一个ReadView，之后的SELECT操作都<code>复用</code>这ReadView，这样也就避免了不可重复读和幻读的问题。</li>
</ul>
</blockquote>
<ul>
<li><p>方案二：读、写操作都采用<code>加锁</code>的方式。</p>
</li>
<li><p>小结对比发现：</p>
<ul>
<li>采用<code>MVCC</code>方式的话，<code>读-写</code>操作彼此并不冲突，<code>性能更高</code>。</li>
<li>采用<code>加锁</code>方式的话，<code>读-写</code>操作彼此需要<code>排队执行</code>，影响性能。</li>
</ul>
</li>
</ul>
<p>一般情况下我们当然愿意采用<code>MVCC</code>来解决<code>读-写</code>操作并发执行的问题，但是业务在某些特殊情况下，要求必须采用<code>加锁</code>的方式执行。</p>
<h4 id="3-锁的不同角度分类"><a href="#3-锁的不同角度分类" class="headerlink" title="3. 锁的不同角度分类"></a><strong>3.</strong> <strong>锁的不同角度分类</strong></h4><p><img src="https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202204050933339.png" alt="image-20220405093322184"></p>
<h5 id="3-1-从数据操作的类型划分：读锁、写锁"><a href="#3-1-从数据操作的类型划分：读锁、写锁" class="headerlink" title="3.1 从数据操作的类型划分：读锁、写锁"></a><strong>3.1</strong> <strong>从数据操作的类型划分：读锁、写锁</strong></h5><ul>
<li><code>读锁</code>：也称为<code>共享锁</code>、英文用<code>S</code>表示。针对同一份数据，多个事务的读操作可以同时进行而不会互相影响，相互不阻塞的。</li>
<li><code>写锁</code>：也称为<code>排他锁</code>、英文用<code>X</code>表示。当前写操作没有完成前，它会阻断其他写锁和读锁。这样就能确保在给定的时间里，只有一个事务能执行写入，并防止其他用户读取正在写入的同一资源。</li>
</ul>
<p><strong>需要注意的是对于</strong> <strong>InnoDB</strong> <strong>引擎来说，读锁和写锁可以加在表上，也可以加在行上。</strong></p>
<p><strong>1. 锁定读</strong></p>
<p>在采用<code>加锁</code>方式解决<code>脏读</code>、<code>不可重复读</code>、<code>幻读</code>这些问题时，读取一条记录时需要获取该记录的<code>S锁</code>，其实是不严谨的，有时候需要在读取记录时就获取记录的<code>X锁</code>，来禁止别的事务读写该记录，为此MySQL提出了两种比较特殊的<code>SELECT</code>语句格式：</p>
<ul>
<li>对读取的记录加<code>S锁</code>：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT ... LOCK IN SHARE MODE;</span><br><span class="line"># 或</span><br><span class="line">SELECT ... FOR SHARE; #(8.0新增语法)</span><br></pre></td></tr></table></figure>

<ul>
<li>对读取的记录加<code>X锁</code>：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT ... FOR UPDATE;</span><br></pre></td></tr></table></figure>

<p><strong>MySQL8.0新特性：</strong></p>
<p>在5.7及之前的版本，SELECT … FOR UPDATE，如果获取不到锁，会一直等待，直到<code>innodb_lock_wait_timeout</code>超时。在8.0版本中，SELECT … FOR UPDATE, SELECT … FOR SHARE 添加<code>NOWAIT</code>、<code>SKIP LOCKED</code>语法，跳过锁等待，或者跳过锁定。</p>
<ul>
<li>NOWAIT：如果查询的行已经加锁，会立即报错返回</li>
<li>SKIP LOCKED：如果查询的行已经加锁，只返回结果中不包含被锁定的行</li>
</ul>
<p><strong>2. 写操作</strong></p>
<ul>
<li><code>DELETE</code>：对一条记录做DELETE操作的过程其实是先在<code>B+</code>树中定位到这条记录的位置，然后获取这条记录的<code>X锁</code>，再执行<code>delete mark</code>操作。</li>
<li><code>UPDATE</code>：在对一条记录做UPDATE操作时分为三种情况：<ul>
<li>情况1：未修改该记录的键值，并且被更新的列占用的存储空间在修改前后未发生变化。则先在<code>B+</code>树中定位到这条记录的位置，然后再获取一下记录的<code>X锁</code>，最后在原纪录的位置进行修改操作。</li>
<li>情况2：未修改该记录的键值，并且至少有一个被更新的列占用的存储空间在修改前后发生变化。则先在<code>B+</code>树中定位到这条记录的位置，然后获取一下记录的<code>X锁</code>，将该记录彻底删除掉（就是把记录彻底移入垃圾链表），最后再插入一条新记录。新插入的记录由<code>INSERT</code>操作提供的<code>隐式锁</code>进行保护。</li>
<li>情况3：修改该记录的键值，则相当于在原纪录上做<code>DELECT</code>操作之后再来一次<code>INSERT</code>操作。</li>
</ul>
</li>
<li><code>INSERT</code>：一般情况下，新插入一条记录的操作并不加锁，通过一种称之为<code>隐式锁</code>的结构来保护这条新插入的记录在本事务提交前不被别的事务访问。</li>
</ul>
<h5 id="3-2-从数据操作的粒度划分：表级锁、页级锁、行锁"><a href="#3-2-从数据操作的粒度划分：表级锁、页级锁、行锁" class="headerlink" title="3.2 从数据操作的粒度划分：表级锁、页级锁、行锁"></a><strong>3.2</strong> <strong>从数据操作的粒度划分：表级锁、页级锁、行锁</strong></h5><p><strong>1.</strong> <strong>表锁（Table Lock）</strong> </p>
<p>该锁会锁定整张表，它是MySQL中最基本的锁策略，并<code>不依赖于存储引擎</code>，并且表锁是<code>开销最少</code>的策略。由于表级锁一次会将整个表锁定，所以可以很好的<code>避免死锁</code>的问题。当然，锁的粒度大所带来最大的负面影响就是出现锁资源争用的概率也会最高，导致<code>并发率大打折扣</code>。</p>
<p><strong>① 表级别的S锁、X锁</strong></p>
<p>在对某个表执行SELECT、INSERT、DELETE、UPDATE语句时，InnoDB存储引擎是不会为这个表添加表级别的<code>S锁</code>或者<code>X锁</code>的。在对某个表执行一些诸如<code>ALTER TABLE</code>、<code>DROP TABLE</code>这类的<code>DDL</code>语句时，其他事务对这个表并发执行诸如SELECT、INSERT、DELETE、UPDATE的语句会发生阻塞。同理，某个事务中对某个表执行SELECT、INSERT、DELETE、UPDATE语句时，在其他会话中对这个表执行<code>DDL</code>语句也会发生阻塞。这个过程其实是通过在<code>server层</code>使用一种称之为<code>元数据锁</code>（英文名：<code>Metadata Locks</code>，简称<code>MDL</code>）结构来实现的。</p>
<p>一般情况下，不会使用InnoDB存储引擎提供的表级别的<code>S锁</code>和<code>X锁</code>。只会在一些特殊情况下，比方说<code>崩溃恢复</code>过程中用到。比如，在系统变量<code>autocommit=0，innodb_table_locks = 1</code>时，<code>手动</code>获取InnoDB存储引擎提供的表t 的<code>S锁</code>或者<code>X锁</code>可以这么写：</p>
<ul>
<li><p><code>LOCK TABLES t READ</code>：InnoDB存储引擎会对表<code>t</code>加表级别的<code>S锁</code>。 </p>
</li>
<li><p><code>LOCK TABLES t WRITE</code>：InnoDB存储引擎会对表<code>t</code>加表级别的<code>X锁</code>。</p>
</li>
</ul>
<p>总结：MyISAM在执行查询语句（SELECT）前，会给涉及的所有表加读锁，在执行增删改操作前，会给涉及的表加写锁。<code>InnoDB</code>存储引擎是不会为这个表添加表级别的<code>读锁</code>或者<code>写锁</code>的。</p>
<p><strong>② 意向锁 （intention lock）</strong></p>
<p>InnoDB 支持<code>多粒度锁（multiple granularity locking）</code>，它允许<code>行级锁</code>与<code>表级锁</code>共存，而<strong>意向锁</strong>就是其中的一种<code>表锁</code>。</p>
<p>1、意向锁的存在是为了协调行锁和表锁的关系，支持多粒度（表锁与行锁）的锁并存。</p>
<p>2、意向锁是一种<code>不与行级锁冲突的表级锁</code>，这一点非常重要。</p>
<p>3、表明“某个事务正在某些行持有了锁或该事务准备去持有锁”</p>
<p>意向锁分为两种：</p>
<ul>
<li><strong>意向共享锁</strong>（intention shared lock, IS）：事务有意向对表中的某些行加<strong>共享锁</strong>（S锁）</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 事务要获取某些行的 S 锁，必须先获得表的 IS 锁。 </span><br><span class="line">SELECT column FROM table ... LOCK IN SHARE MODE;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>意向排他锁</strong>（intention exclusive lock, IX）：事务有意向对表中的某些行加<strong>排他锁</strong>（X锁）</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 事务要获取某些行的 X 锁，必须先获得表的 IX 锁。 </span><br><span class="line">SELECT column FROM table ... FOR UPDATE;</span><br></pre></td></tr></table></figure>

<p>即：意向锁是由存储引擎<code>自己维护的</code>，用户无法手动操作意向锁，在为数据行加共享 / 排他锁之前，InooDB 会先获取该数据行<code>所在数据表的对应意向锁</code>。</p>
<p><strong>1. 意向锁要解决的问题</strong></p>
<p>现在有两个事务，分别是T1和T2，其中T2试图在该表级别上应用共享或排它锁，如果没有意向锁存在，那么T2就需要去检查各个页或行是否存在锁；如果存在意向锁，那么此时就会受到由T1控制的<code>表级别意向锁的阻塞</code>。T2在锁定该表前不必检查各个页或行锁，而只需检查表上的意向锁。简单来说就是给更大一级级别的空间示意里面是否已经上过锁。</p>
<p>在数据表的场景中，<strong>如果我们给某一行数据加上了排它锁，数据库会自动给更大一级的空间，比如数据页或数据表加上意向锁，告诉其他人这个数据页或数据表已经有人上过排它锁了</strong>，这样当其他人想要获取数据表排它锁的时候，只需要了解是否有人已经获取了这个数据表的意向排它锁即可。</p>
<ul>
<li>如果事务想要获取数据表中某些记录的共享锁，就需要在数据表上<code>添加意向共享锁</code></li>
<li>如果事务想要获取数据表中某些记录的排它锁，就需要在数据表上<code>添加意向排他锁</code></li>
</ul>
<p>这时，意向锁会告诉其他事务已经有人锁定了表中的某些记录。</p>
<p><strong>③ 自增锁（AUTO-INC锁）</strong></p>
<p><strong>1. “Simple inserts”</strong> <strong>（简单插入）</strong></p>
<p>可以<code>预先确定要插入的行数</code>（当语句被初始处理时）的语句。包括没有嵌套子查询的单行和多行<code>INSERT...VALUES()</code>和<code>REPLACE</code>语句。</p>
<p><strong>2. “Bulk inserts”</strong> <strong>（批量插入）</strong></p>
<p><code>事先不知道要插入的行数</code>（和所需自动递增值的数量）的语句。比如<code>INSERT ... SELECT</code>，<code>REPLACE ... SELECT</code>和<code>LOAD DATA</code>语句，但不包括纯INSERT。 InnoDB在每处理一行，为AUTO_INCREMENT列分配一个新值。</p>
<p><strong>3. “Mixed-mode inserts”</strong> <strong>（混合模式插入）</strong></p>
<p>这些是“Simple inserts”语句但是指定部分新行的自动递增值。例如<code>INSERT INTO teacher (id,name) VALUES (1,&#39;a&#39;), (NULL,&#39;b&#39;), (5,&#39;c&#39;), (NULL,&#39;d&#39;);</code>只是指定了部分id的值。另一种类型的“混合模式插入”是<code>INSERT ... ON DUPLICATE KEY UPDATE</code>。 </p>
<p>对于上面数据插入的案例，MySQL采用了<code>自增锁</code>的方式来实现，<strong>AUTO-INT锁是当向使用含有AUTO_INCREMENT列的表中插入数据时需要获取的一种特殊的表级锁</strong>，在执行插入语句时就在表级别加一个AUTO-INT锁，然后为每条待插入记录的AUTO_INCREMENT修饰的列分配递增的值，在该语句执行结束后，再把AUTO-INT锁释放掉。<strong>一个事务在持有AUTO-INC锁的过程中，其他事务的插入语句都要被阻塞</strong>，可以保证一个语句中分配的递增值是连续的。也正因为此，其并发性显然并不高，<strong>当我们向一个有AUTO_INCREMENT关键字的主键插入值的时候，每条语句都要对这个表锁进行竞争</strong>，这样的并发潜力其实是很低下的，所以innodb通过<code>innodb_autoinc_lock_mode</code>的不同取值来提供不同的锁定机制，来显著提高SQL语句的可伸缩性和性能。</p>
<p>innodb_autoinc_lock_mode有三种取值，分别对应与不同锁定模式：</p>
<p><code>（1）innodb_autoinc_lock_mode = 0(“传统”锁定模式)</code></p>
<p>在此锁定模式下，所有类型的insert语句都会获得一个特殊的表级AUTO-INC锁，用于插入具有AUTO_INCREMENT列的表。这种模式其实就如我们上面的例子，即每当执行insert的时候，都会得到一个表级锁(AUTO-INC锁)，使得语句中生成的auto_increment为顺序，且在binlog中重放的时候，可以保证master与slave中数据的auto_increment是相同的。因为是表级锁，当在同一时间多个事务中执行insert的时候，对于AUTO-INC锁的争夺会<code>限制并发</code>能力。</p>
<p><code>（2）innodb_autoinc_lock_mode = 1(“连续”锁定模式)</code></p>
<p>在 MySQL 8.0 之前，连续锁定模式是<code>默认</code>的。</p>
<p>在这个模式下，“bulk inserts”仍然使用AUTO-INC表级锁，并保持到语句结束。这适用于所有INSERT … SELECT，REPLACE … SELECT和LOAD DATA语句。同一时刻只有一个语句可以持有AUTO-INC锁。</p>
<p>对于“Simple inserts”（要插入的行数事先已知），则通过在<code>mutex（轻量锁）</code>的控制下获得所需数量的自动递增值来避免表级AUTO-INC锁， 它只在分配过程的持续时间内保持，而不是直到语句完成。不使用表级AUTO-INC锁，除非AUTO-INC锁由另一个事务保持。如果另一个事务保持AUTO-INC锁，则“Simple inserts”等待AUTO-INC锁，如同它是一个“bulk inserts”。 </p>
<p><code>（3）innodb_autoinc_lock_mode = 2(“交错”锁定模式)</code></p>
<p>从 MySQL 8.0 开始，交错锁模式是<code>默认</code>设置。</p>
<p>在这种锁定模式下，所有类INSERT语句都不会使用表级AUTO-INC锁，并且可以同时执行多个语句。这是最快和最可拓展的锁定模式，但是当使用基于语句的复制或恢复方案时，<strong>从二进制日志重播SQL语句时，这是不安全的。</strong></p>
<p>在此锁定模式下，自动递增值<code>保证</code>在所有并发执行的所有类型的insert语句中是<code>唯一</code>且<code>单调递增</code>的。但是，由于多个语句可以同时生成数字（即，跨语句交叉编号），<strong>为任何给定语句插入的行生成的值可能不是连续的。</strong></p>
<p><strong>④ 元数据锁（MDL锁）</strong></p>
<p>MySQL5.5引入了meta data lock，简称MDL锁，属于表锁范畴。MDL 的作用是，保证读写的正确性。比如，如果一个查询正在遍历一个表中的数据，而执行期间另一个线程对这个<code>表结构做变更</code>，增加了一列，那么查询线程拿到的结果跟表结构对不上，肯定是不行的。</p>
<p>因此，<strong>当对一个表做增删改查操作的时候，加MDL读锁；当要对表做结构变更操作的时候，加MDL写锁。</strong></p>
<p><strong>2. InnoDB中的行锁</strong></p>
<p>行锁（Row Lock）也称为记录锁，顾名思义，就是锁住某一行（某条记录row）。需要注意的是，MySQL服务器层并没有实现行锁机制，<strong>行级锁只在存储引擎层实现。</strong></p>
<p><strong>优点：</strong>锁定力度小，发生<code>锁冲突概率低</code>，可以实现的<code>并发度高</code></p>
<p><strong>缺点：</strong>对于<code>锁的开销比较大</code>，加锁会比较慢，容易出现<code>死锁</code>情况</p>
<p>InnoDB与MyISAM的最大不同有两点：一是支持事务；二是采用了行级锁。</p>
<p><strong>① 记录锁（Record Locks）</strong></p>
<p>记录锁也就是仅仅把一条记录锁上，官方的类型名称为：<code>LOCK_REC_NOT_GAP</code>。</p>
<p>记录锁是有S锁和X锁之分的，称之为<code>S型记录锁</code>和<code>X型记录锁</code>。</p>
<ul>
<li>当一个事务获取了一条记录的S型记录锁后，其他事务也可以继续获取该记录的S型记录锁，但不可以继续获取X型记录锁；</li>
<li>当一个事务获取了一条记录的X型记录锁后，其他事务既不可以继续获取该记录的S型记录锁，也不可以继续获取X型记录锁。</li>
</ul>
<p><strong>② 间隙锁（Gap Locks）</strong></p>
<p><code>MySQL</code>在<code>REPEATABLE READ</code>隔离级别下是可以解决幻读问题的，解决方案有两种，可以使用<code>MVCC</code>方案解决，也可以采用<code>加锁</code>方案解决。但是在使用加锁方案解决时有个大问题，就是事务在第一次执行读取操作时，那些幻影记录尚不存在，我们无法给这些<code>幻影记录</code>加上<code>记录锁</code>。InnoDB提出了一种称之为<code>Gap Locks</code>的锁，官方的类型名称为：<code>LOCK_GAP</code>，我们可以简称为<code>gap锁</code>。</p>
<p><strong>gap锁的提出仅仅是为了防止插入幻影记录而提出的</strong>。虽然有<code>共享gap锁</code>和<code>独占gap锁</code>这样的说法，但是它们起到的作用是相同的。而且如果对一条记录加了gap锁（不论是共享gap锁还是独占gap锁），并不会限制其他事务对这条记录加记录锁或者继续加gap锁。</p>
<p><strong>③ 临键锁（Next-Key Locks）</strong></p>
<p>有时候我们既想<code>锁住某条记录</code>，又想<code>阻止</code>其他事务在该记录前边的<code>间隙插入新记录</code>，所以InnoDB就提出了一种称之为<code>Next-Key Locks</code>的锁，官方的类型名称为：<code>LOCK_ORDINARY</code>，我们也可以简称为<code>next-key锁</code>。Next-Key Locks是在存储引擎<code>innodb</code>、事务级别在<code>可重复读</code>的情况下使用的数据库锁，innodb默认的锁就是Next-Key locks。 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">begin; </span><br><span class="line">select * from student where id &lt;&#x3D;8 and id &gt; 3 for update;</span><br></pre></td></tr></table></figure>

<p><strong>④ 插入意向锁（Insert Intention Locks）</strong></p>
<p>我们说一个事务在<code>插入</code>一条记录时需要判断一下插入位置是不是被别的事务加了<code>gap锁</code>（<code>next-key锁</code>也包含<code>gap锁</code>），如果有的话，插入操作需要等待，直到拥有<code>gap锁</code>的那个事务提交。但是<strong>InnoDB规定事务在等待的时候也需要在内存中生成一个锁结构</strong>，表明有事务想在某个<code>间隙</code>中<code>插入</code>新记录，但是现在在等待。InnoDB就把这种类型的锁命名为<code>Insert Intention Locks</code>，官方的类型名称为：<code>LOCK_INSERT_INTENTION</code>，我们称为<code>插入意向锁</code>。插入意向锁是一种<code>Gap锁</code>，不是意向锁，在insert操作时产生。</p>
<p>插入意向锁是在插入一条记录行前，由<code>INSERT 操作产生的一种间隙锁</code>。</p>
<p>事实上<strong>插入意向锁并不会阻止别的事务继续获取该记录上任何类型的锁。</strong></p>
<p><strong>3.</strong> <strong>页锁</strong></p>
<p>页锁就是在<code>页的粒度</code>上进行锁定，锁定的数据资源比行锁要多，因为一个页中可以有多个行记录。当我们使用页锁的时候，会出现数据浪费的现象，但这样的浪费最多也就是一个页上的数据行。<strong>页锁的开销介于表锁和行锁之间，会出现死锁。锁定粒度介于表锁和行锁之间，并发度一般。</strong></p>
<p>每个层级的锁数量是有限制的，因为锁会占用内存空间，<code>锁空间的大小是有限的</code>。当某个层级的锁数量超过了这个层级的阈值时，就会进行<code>锁升级</code>。锁升级就是用更大粒度的锁替代多个更小粒度的锁，比如InnoDB 中行锁升级为表锁，这样做的好处是占用的锁空间降低了，但同时数据的并发度也下降了。</p>
<h5 id="3-3-从对待锁的态度划分-乐观锁、悲观锁"><a href="#3-3-从对待锁的态度划分-乐观锁、悲观锁" class="headerlink" title="3.3 从对待锁的态度划分:乐观锁、悲观锁"></a><strong>3.3</strong> <strong>从对待锁的态度划分:乐观锁、悲观锁</strong></h5><p>从对待锁的态度来看锁的话，可以将锁分成乐观锁和悲观锁，从名字中也可以看出这两种锁是两种看待<code>数据并发的思维方式</code>。需要注意的是，乐观锁和悲观锁并不是锁，而是锁的<code>设计思想</code>。</p>
<p><strong>1.</strong> <strong>悲观锁（Pessimistic Locking）</strong></p>
<p>悲观锁总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会<code>阻塞</code>直到它拿到锁（<strong>共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程</strong>）。比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁，当其他线程想要访问数据时，都需要阻塞挂起。Java中<code>synchronized</code>和<code>ReentrantLock</code>等独占锁就是悲观锁思想的实现。</p>
<p>注意：<strong>select … for update 语句执行过程中所有扫描的行都会被锁上，因此在MySQL中用悲观锁必须确定使用了索引，而不是全表扫描，否则将会把整个表锁住。</strong></p>
<p><strong>2.</strong> <strong>乐观锁（Optimistic Locking）</strong></p>
<p>乐观锁认为对同一数据的并发操作不会总发生，属于小概率事件，不用每次都对数据上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，也就是<strong>不采用数据库自身的锁机制，而是通过程序来实现</strong>。在程序上，我们可以采用<code>版本号机制</code>或者<code>CAS机制</code>实现。<strong>乐观锁适用于多读的应用类型，这样可以提高吞吐量</strong>。在Java中<code>java.util.concurrent.atomic</code>包下的原子变量类就是使用了乐观锁的一种实现方式：CAS实现的。</p>
<p><strong>1.</strong> <strong>乐观锁的版本号机制</strong></p>
<p>在表中设计一个<code>版本字段 version</code>，第一次读的时候，会获取 version 字段的取值。然后对数据进行更新或删除操作时，会执行<code>UPDATE ... SET version=version+1 WHERE version=version</code>。此时如果已经有事务对这条数据进行了更改，修改就不会成功。</p>
<p><strong>2.</strong> <strong>乐观锁的时间戳机制</strong></p>
<p>时间戳和版本号机制一样，也是在更新提交的时候，将当前数据的时间戳和更新之前取得的时间戳进行比较，如果两者一致则更新成功，否则就是版本冲突。</p>
<p>你能看到乐观锁就是程序员自己控制数据并发操作的权限，基本是通过给数据行增加一个戳（版本号或者时间戳），从而证明当前拿到的数据是否最新。</p>
<p><strong>3.</strong> <strong>两种锁的适用场景</strong></p>
<p>从这两种锁的设计思想中，我们总结一下乐观锁和悲观锁的适用场景：</p>
<ol>
<li><p><code>乐观锁</code>适合<code>读操作多</code>的场景，相对来说写的操作比较少。它的优点在于<code>程序实现</code>，<code>不存在死锁</code>问题，不过适用场景也会相对乐观，因为它阻止不了除了程序以外的数据库操作。</p>
</li>
<li><p><code>悲观锁</code>适合<code>写操作多</code>的场景，因为写的操作具有<code>排它性</code>。采用悲观锁的方式，可以在数据库层面阻止其他事务对该数据的操作权限，防止<code>读 - 写</code>和<code>写 - 写</code>的冲突。</p>
</li>
</ol>
<h5 id="3-4-按加锁的方式划分：显式锁、隐式锁"><a href="#3-4-按加锁的方式划分：显式锁、隐式锁" class="headerlink" title="3.4 按加锁的方式划分：显式锁、隐式锁"></a><strong>3.4</strong> <strong>按加锁的方式划分：显式锁、隐式锁</strong></h5><p><strong>1.</strong> <strong>隐式锁</strong></p>
<ul>
<li><p><strong>情景一：</strong>对于聚簇索引记录来说，有一个<code>trx_id</code>隐藏列，该隐藏列记录着最后改动该记录的<code>事务id</code>。那么如果在当前事务中新插入一条聚簇索引记录后，该记录的<code>trx_id</code>隐藏列代表的的就是当前事务的<code>事务id</code>，如果其他事务此时想对该记录添加<code>S锁</code>或者<code>X锁</code>时，首先会看一下该记录的<code>trx_id</code>隐藏列代表的事务是否是当前的活跃事务，如果是的话，那么就帮助当前事务创建一个<code>X锁</code>（也就是为当前事务创建一个锁结构，<code>is_waiting</code>属性是<code>false</code>），然后自己进入等待状态（也就是为自己也创建一个锁结构，<code>is_waiting</code>属性是<code>true</code>）。</p>
</li>
<li><p><strong>情景二：</strong>对于二级索引记录来说，本身并没有<code>trx_id</code>隐藏列，但是在二级索引页面的<code>Page Header</code>部分有一个<code>PAGE_MAX_TRX_ID</code>属性，该属性代表对该页面做改动的最大的<code>事务id</code>，如果<code>PAGE_MAX_TRX_ID</code>属性值小于当前最小的活跃<code>事务id</code>，那么说明对该页面做修改的事务都已经提交了，否则就需要在页面中定位到对应的二级索引记录，然后回表找到它对应的聚簇索引记录，然后再重复<code>情景一</code>的做法。</p>
</li>
</ul>
<p>即：一个事务对新插入的记录可以不显示的加锁（生成一个锁结构），但是由于<code>事务id</code>的存在，相当于加了一个<code>隐式锁</code>。别的事务在对这条记录加<code>S锁</code>或者<code>X锁</code>时，由于<code>隐式锁</code>的存在，会先帮助当前事务生成一个锁结构，然后自己再生成一个锁结构后进入等待状态。隐式锁是一种<code>延迟加锁</code>的机制，从而来减少加锁的数量。</p>
<p><strong>2.</strong> <strong>显式锁</strong></p>
<p>通过特定的语句进行加锁，我们一般称之为显示加锁。</p>
<h5 id="3-5-其它锁之：全局锁"><a href="#3-5-其它锁之：全局锁" class="headerlink" title="3.5 其它锁之：全局锁"></a><strong>3.5</strong> <strong>其它锁之：全局锁</strong></h5><p>全局锁就是对<code>整个数据库实例</code>加锁。当你需要让整个库处于<code>只读状态</code>的时候，可以使用这个命令，之后其他线程的以下语句会被阻塞：数据更新语句（数据的增删改）、数据定义语句（包括建表、修改表结构等）和更新类事务的提交语句。全局锁的典型使用<code>场景</code>是：做<code>全库逻辑备份</code>。</p>
<p>全局锁的命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Flush tables with read lock</span><br></pre></td></tr></table></figure>

<h5 id="3-6-其它锁之：死锁"><a href="#3-6-其它锁之：死锁" class="headerlink" title="3.6 其它锁之：死锁"></a><strong>3.6</strong> <strong>其它锁之：死锁</strong></h5><p>死锁是指两个或多个事务在同一资源上相互占用，并请求锁定对方占用的资源，从而导致恶性循环。</p>
<p><strong>1. 如何处理死锁</strong></p>
<p><strong>方式1：</strong>等待，直到超时（innodb_lock_wait_timeout=50s）</p>
<p>即当两个事务互相等待时，当一个事务等待时间超过设置的阈值时，就将其<code>回滚</code>，另外事务继续进行。</p>
<p><strong>方式2：</strong>使用死锁检测进行死锁处理</p>
<p>发起死锁检测，发现死锁后，主动回滚死锁链条中的某一个事务（将持有最少行级排他锁的事务进行回滚），让其他事务得以继续执行。</p>
<h4 id="4-锁的内存结构"><a href="#4-锁的内存结构" class="headerlink" title="4. 锁的内存结构"></a><strong>4.</strong> <strong>锁的内存结构</strong></h4><p><img src="https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202204051514736.png" alt="image-20220405151409557"></p>
<p>结构解析：</p>
<p><code>1. 锁所在的事务信息</code>：</p>
<p>不论是<code>表锁</code>还是<code>行锁</code>，都是在事务执行过程中生成的，哪个事务生成了这个 锁结构 ，这里就记录这个事务的信息。</p>
<p>此<code>锁所在的事务信息</code>在内存结构中只是一个指针，通过指针可以找到内存中关于该事务的更多信息，比方说事务id等。</p>
<p><code>2. 索引信息</code>：</p>
<p>对于<code>行锁</code>来说，需要记录一下加锁的记录是属于哪个索引的。这里也是一个指针。</p>
<p><code>3. 表锁／行锁信息</code>： </p>
<p><code>表锁结构</code>和<code>行锁结构</code>在这个位置的内容是不同的：</p>
<ul>
<li>表锁：记载着是对哪个表加的锁，还有其他的一些信息。</li>
<li>行锁：记载了三个重要的信息：<ul>
<li>Space ID ：记录所在表空间。</li>
<li>Page Number ：记录所在页号。</li>
<li>n_bits ：对于行锁来说，一条记录就对应着一个比特位，一个页面中包含很多记录，用不同的比特位来区分到底是哪一条记录加了锁。为此在行锁结构的末尾放置了一堆比特位，这个n_bits 属性代表使用了多少比特位。</li>
</ul>
</li>
</ul>
<blockquote>
<p>n_bits的值一般都比页面中记录条数多一些。主要是为了之后在页面中插入了新记录后也不至于重新分配锁结构</p>
</blockquote>
<p><code>4. type_mode</code>：</p>
<p>这是一个32位的数，被分成了<code>lock_mode</code>、<code>lock_type</code>和<code>rec_lock_type</code>三个部分，如图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202204051518659.png" alt="image-20220405151829547"></p>
<ul>
<li>锁的模式（<code>lock_mode</code>），占用低4位，可选的值如下：<ul>
<li><code>LOCK_IS</code>（十进制的<code>0</code>）：表示共享意向锁，也就是<code>IS锁</code>。 </li>
<li><code>LOCK_IX</code>（十进制的<code>1</code>）：表示独占意向锁，也就是<code>IX锁</code>。 </li>
<li><code>LOCK_S</code>（十进制的<code>2</code>）：表示共享锁，也就是<code>S锁</code>。 </li>
<li><code>LOCK_X</code>（十进制的<code>3</code>）：表示独占锁，也就是<code>X锁</code>。 </li>
<li><code>LOCK_AUTO_INC</code>（十进制的<code>4</code>）：表示<code>AUTO-INC锁</code>。 </li>
</ul>
</li>
</ul>
<p>在InnoDB存储引擎中，LOCK_IS，LOCK_IX，LOCK_AUTO_INC都算是表级锁的模式，LOCK_S和 LOCK_X既可以算是表级锁的模式，也可以是行级锁的模式。</p>
<ul>
<li>锁的类型（<code>lock_type</code>），占用第5～8位，不过现阶段只有第5位和第6位被使用：<ul>
<li><code>LOCK_TABLE</code>（十进制的<code>16</code>），也就是当第5个比特位置为1时，表示表级锁。</li>
<li><code>LOCK_REC</code>（十进制的<code>32</code>），也就是当第6个比特位置为1时，表示行级锁。</li>
</ul>
</li>
<li>行锁的具体类型（<code>rec_lock_type</code>），使用其余的位来表示。只有在 <code>lock_type</code>的值为<code>LOCK_REC</code>时，也就是只有在该锁为行级锁时，才会被细分为更多的类型：<ul>
<li><code>LOCK_ORDINARY</code>（十进制的<code>0</code>）：表示<code>next-key锁</code>。 </li>
<li><code>LOCK_GAP</code>（十进制的<code>512</code>）：也就是当第10个比特位置为1时，表示<code>gap锁</code>。 </li>
<li><code>LOCK_REC_NOT_GAP</code>（十进制的<code>1024</code>）：也就是当第11个比特位置为1时，表示正经<code>记录锁</code>。</li>
<li><code>LOCK_INSERT_INTENTION</code>（十进制的<code>2048</code>）：也就是当第12个比特位置为1时，表示插入意向锁。其他的类型：还有一些不常用的类型我们就不多说了。</li>
</ul>
</li>
<li><code>is_waiting</code>属性呢？基于内存空间的节省，所以把 is_waiting 属性放到了 type_mode 这个32位的数字中：<ul>
<li><code>LOCK_WAIT</code>（十进制的<code>256</code>） ：当第9个比特位置为<code>1</code>时，表示<code>is_waiting</code>为<code>true</code>，也就是当前事务尚未获取到锁，处在等待状态；当这个比特位为<code>0</code>时，表示<code>is_waiting</code>为<code>false</code>，也就是当前事务获取锁成功。</li>
</ul>
</li>
</ul>
<p><code>5. 其他信息</code>：</p>
<p>为了更好的管理系统运行过程中生成的各种锁结构而设计了各种哈希表和链表。</p>
<p><code>6. 一堆比特位</code>：</p>
<p>如果是<code>行锁结构</code>的话，在该结构末尾还放置了一堆比特位，比特位的数量是由上边提到的<code>n_bits</code>属性表示的。InnoDB数据页中的每条记录在<code>记录头信息</code>中都包含一个 heap_no 属性，伪记录<code>Infimum</code>的<code>heap_no</code>值为<code>0</code>，<code>Supremum</code>的<code>heap_no</code>值为<code>1</code>，之后每插入一条记录，<code>heap_no</code>值就增1。<code>锁结构</code>最后的一堆比特位就对应着一个页面中的记录，一个比特位映射一个<code>heap_no</code>，即一个比特位映射到页内的一条记录。</p>
<h4 id="5-锁监控"><a href="#5-锁监控" class="headerlink" title="5. 锁监控"></a><strong>5.</strong> <strong>锁监控</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; show status like &#39;innodb_row_lock%&#39;;</span><br></pre></td></tr></table></figure>

<ul>
<li>Innodb_row_lock_current_waits：当前正在等待锁定的数量；</li>
<li><code>Innodb_row_lock_time</code>：从系统启动到现在锁定总时间长度；（等待总时长）</li>
<li><code>Innodb_row_lock_time_avg</code>：每次等待所花平均时间；（等待平均时长）</li>
<li>Innodb_row_lock_time_max：从系统启动到现在等待最常的一次所花的时间；</li>
<li><code>Innodb_row_lock_waits</code>：系统启动后到现在总共等待的次数；（等待总次数）</li>
</ul>
<p><strong>其他监控方法：</strong></p>
<p>MySQL把事务和锁的信息记录在了<code>information_schema</code>库中，涉及到的三张表分别是<code>INNODB_TRX</code>、<code>INNODB_LOCKS</code>和<code>INNODB_LOCK_WAITS</code>。 </p>
<p><code>MySQL5.7及之前</code>，可以通过information_schema.INNODB_LOCKS查看事务的锁情况，但只能看到阻塞事务的锁；如果事务并未被阻塞，则在该表中看不到该事务的锁情况。</p>
<p>MySQL8.0删除了information_schema.INNODB_LOCKS，添加了<code>performance_schema.data_locks</code>，可以通过performance_schema.data_locks查看事务的锁情况，和MySQL5.7及之前不同，performance_schema.data_locks不但可以看到阻塞该事务的锁，还可以看到该事务所持有的锁。</p>
<p>同时，information_schema.INNODB_LOCK_WAITS也被<code>performance_schema.data_lock_waits</code>所代替。</p>
<h3 id="第16章-多版本并发控制"><a href="#第16章-多版本并发控制" class="headerlink" title="第16章 多版本并发控制"></a>第16章 多版本并发控制</h3><h4 id="1-什么是MVCC"><a href="#1-什么是MVCC" class="headerlink" title="1. 什么是MVCC"></a><strong>1.</strong> <strong>什么是MVCC</strong></h4><p>MVCC （Multiversion Concurrency Control），多版本并发控制。顾名思义，MVCC 是通过数据行的多个版本管理来实现数据库的<code>并发控制</code>。这项技术使得在InnoDB的事务隔离级别下执行<code>一致性读</code>操作有了保证。换言之，就是为了查询一些正在被另一个事务更新的行，并且可以看到它们被更新之前的值，这样在做查询的时候就不用等待另一个事务释放锁。</p>
<h4 id="2-快照读与当前读"><a href="#2-快照读与当前读" class="headerlink" title="2. 快照读与当前读"></a><strong>2.</strong> <strong>快照读与当前读</strong></h4><p>MVCC在MySQL InnoDB中的实现主要是为了提高数据库并发性能，用更好的方式去处理<code>读-写冲突</code>，做到即使有读写冲突时，也能做到<code>不加锁</code>，<code>非阻塞并发读</code>，而这个读指的就是<code>快照读</code>, 而非<code>当前读</code>。当前读实际上是一种加锁的操作，是悲观锁的实现。而MVCC本质是采用乐观锁思想的一种方式。</p>
<h5 id="2-1-快照读"><a href="#2-1-快照读" class="headerlink" title="2.1 快照读"></a><strong>2.1</strong> <strong>快照读</strong></h5><p>快照读又叫一致性读，读取的是快照数据。<strong>不加锁的简单的</strong> <strong>SELECT</strong> <strong>都属于快照读</strong>，即不加锁的非阻塞读。</p>
<p>之所以出现快照读的情况，是基于提高并发性能的考虑，快照读的实现是基于MVCC，它在很多情况下，避免了加锁操作，降低了开销。</p>
<p>既然是基于多版本，那么快照读可能读到的并不一定是数据的最新版本，而有可能是之前的历史版本。</p>
<p>快照读的前提是隔离级别不是串行级别，串行级别下的快照读会退化成当前读。</p>
<h5 id="2-2-当前读"><a href="#2-2-当前读" class="headerlink" title="2.2 当前读"></a><strong>2.2</strong> <strong>当前读</strong></h5><p>当前读读取的是记录的最新版本（最新数据，而不是历史版本的数据），读取时还要保证其他并发事务不能修改当前记录，会对读取的记录进行加锁。加锁的 SELECT，或者对数据进行增删改都会进行当前读。</p>
<h4 id="3-复习"><a href="#3-复习" class="headerlink" title="3. 复习"></a><strong>3.</strong> <strong>复习</strong></h4><h5 id="3-1-再谈隔离级别"><a href="#3-1-再谈隔离级别" class="headerlink" title="3.1 再谈隔离级别"></a><strong>3.1</strong> <strong>再谈隔离级别</strong></h5><p>我们知道事务有 4 个隔离级别，可能存在三种并发问题：</p>
<p><img src="https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202204051536648.png" alt="image-20220405153617536"></p>
<p>另图：</p>
<p><img src="https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202204051536125.png" alt="image-20220405153632021"></p>
<h5 id="3-2-隐藏字段、Undo-Log版本链"><a href="#3-2-隐藏字段、Undo-Log版本链" class="headerlink" title="3.2 隐藏字段、Undo Log版本链"></a><strong>3.2</strong> <strong>隐藏字段、Undo Log版本链</strong></h5><p>回顾一下undo日志的版本链，对于使用<code>InnoDB</code>存储引擎的表来说，它的聚簇索引记录中都包含两个必要的隐藏列。</p>
<ul>
<li><code>trx_id</code>：每次一个事务对某条聚簇索引记录进行改动时，都会把该事务的<code>事务id</code>赋值给trx_id 隐藏列。</li>
<li><code>roll_pointer</code>：每次对某条聚簇索引记录进行改动时，都会把旧的版本写入到 undo日志 中，然后这个隐藏列就相当于一个指针，可以通过它来找到该记录修改前的信息。</li>
</ul>
<h4 id="4-MVCC实现原理之ReadView"><a href="#4-MVCC实现原理之ReadView" class="headerlink" title="4. MVCC实现原理之ReadView"></a><strong>4. MVCC实现原理之ReadView</strong></h4><p>MVCC 的实现依赖于：<strong>隐藏字段、Undo Log、Read View</strong>。</p>
<h5 id="4-1-什么是ReadView"><a href="#4-1-什么是ReadView" class="headerlink" title="4.1 什么是ReadView"></a><strong>4.1</strong> <strong>什么是ReadView</strong></h5><p>ReadView就是事务在使用MVCC机制进行快照读操作时产生的读视图。当事务启动时，会生成数据库系统当前的一个快照，InnoDB为每个事务构造了一个数组，用来记录并维护系统当前<code>活跃事务</code>的ID（“活跃”指的就是，启动了但还没提交）。</p>
<h5 id="4-2-设计思路"><a href="#4-2-设计思路" class="headerlink" title="4.2 设计思路"></a><strong>4.2</strong> <strong>设计思路</strong></h5><p>使用<code>READ UNCOMMITTED</code>隔离级别的事务，由于可以读到未提交事务修改过的记录，所以直接读取记录的最新版本就好了。</p>
<p>使用<code>SERIALIZABLE</code>隔离级别的事务，InnoDB规定使用加锁的方式来访问记录。</p>
<p>使用<code>READ COMMITTED</code>和<code>REPEATABLE READ</code>隔离级别的事务，都必须保证读到<code>已经提交了的</code>事务修改过的记录。假如另一个事务已经修改了记录但是尚未提交，是不能直接读取最新版本的记录的，核心问题就是需要判断一下版本链中的哪个版本是当前事务可见的，这是ReadView要解决的主要问题。</p>
<p>这个ReadView中主要包含4个比较重要的内容，分别如下：</p>
<ol>
<li><code>creator_trx_id</code>，创建这个 Read View 的事务 ID。</li>
</ol>
<blockquote>
<p>说明：只有在对表中的记录做改动时（执行INSERT、DELETE、UPDATE这些语句时）才会为事务分配事务id，否则在一个只读事务中的事务id值都默认为0。 </p>
</blockquote>
<ol start="2">
<li><p><code>trx_ids</code>，表示在生成ReadView时当前系统中活跃的读写事务的<code>事务id列表</code>。 </p>
</li>
<li><p><code>up_limit_id</code>，活跃的事务中最小的事务 ID。 </p>
</li>
<li><p><code>low_limit_id</code>，表示生成ReadView时系统中应该分配给下一个事务的<code>id</code>值。low_limit_id 是系统最大的事务id值，这里要注意是系统中的事务id，需要区别于正在活跃的事务ID。</p>
</li>
</ol>
<blockquote>
<p>注意：low_limit_id并不是trx_ids中的最大值，事务id是递增分配的。比如，现在有id为1， 2，3这三个事务，之后id为3的事务提交了。那么一个新的读事务在生成ReadView时，trx_ids就包括1和2，up_limit_id的值就是1，low_limit_id的值就是4。</p>
</blockquote>
<h5 id="4-3-ReadView的规则"><a href="#4-3-ReadView的规则" class="headerlink" title="4.3 ReadView的规则"></a><strong>4.3 ReadView的规则</strong></h5><p>有了这个ReadView，这样在访问某条记录时，只需要按照下边的步骤判断记录的某个版本是否可见。</p>
<ul>
<li>如果被访问版本的trx_id属性值与ReadView中的<code>creator_trx_id</code>值相同，意味着当前事务在访问它自己修改过的记录，所以该版本可以被当前事务访问。</li>
<li>如果被访问版本的trx_id属性值小于ReadView中的<code>up_limit_id</code>值，表明生成该版本的事务在当前事务生成ReadView前已经提交，所以该版本可以被当前事务访问。</li>
<li>如果被访问版本的trx_id属性值大于或等于ReadView中的<code>low_limit_id</code>值，表明生成该版本的事务在当前事务生成ReadView后才开启，所以该版本不可以被当前事务访问。</li>
<li>如果被访问版本的trx_id属性值在ReadView的<code>up_limit_id</code>和<code>low_limit_id</code>之间，那就需要判断一下trx_id属性值是不是在 trx_ids 列表中。<ul>
<li>如果在，说明创建ReadView时生成该版本的事务还是活跃的，该版本不可以被访问。</li>
<li>如果不在，说明创建ReadView时生成该版本的事务已经被提交，该版本可以被访问。</li>
</ul>
</li>
</ul>
<h5 id="4-4-MVCC整体操作流程"><a href="#4-4-MVCC整体操作流程" class="headerlink" title="4.4 MVCC整体操作流程"></a><strong>4.4 MVCC整体操作流程</strong></h5><p>了解了这些概念之后，我们来看下当查询一条记录的时候，系统如何通过MVCC找到它：</p>
<ol>
<li><p>首先获取事务自己的版本号，也就是事务 ID； </p>
</li>
<li><p>获取 ReadView； </p>
</li>
<li><p>查询得到的数据，然后与 ReadView 中的事务版本号进行比较；</p>
</li>
<li><p>如果不符合 ReadView 规则，就需要从 Undo Log 中获取历史快照；</p>
</li>
<li><p>最后返回符合规则的数据。</p>
</li>
</ol>
<p>在隔离级别为读已提交（Read Committed）时，一个事务中的每一次 SELECT 查询都会重新获取一次Read View。</p>
<p>如表所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202204051549618.png" alt="image-20220405154948505"></p>
<blockquote>
<p>注意，此时同样的查询语句都会重新获取一次 Read View，这时如果 Read View 不同，就可能产生不可重复读或者幻读的情况。</p>
</blockquote>
<p>当隔离级别为可重复读的时候，就避免了不可重复读，这是因为一个事务只在第一次 SELECT 的时候会获取一次 Read View，而后面所有的 SELECT 都会复用这个 Read View，如下表所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202204051550072.png" alt="image-20220405155041964"></p>
<h4 id="5-举例说明"><a href="#5-举例说明" class="headerlink" title="5. 举例说明"></a><strong>5.</strong> <strong>举例说明</strong></h4><h5 id="5-1-READ-COMMITTED隔离级别下"><a href="#5-1-READ-COMMITTED隔离级别下" class="headerlink" title="5.1 READ COMMITTED隔离级别下"></a><strong>5.1 READ COMMITTED隔离级别下</strong></h5><p><strong>READ COMMITTED</strong> <strong>：每次读取数据前都生成一个ReadView</strong>。</p>
<h5 id="5-2-REPEATABLE-READ隔离级别下"><a href="#5-2-REPEATABLE-READ隔离级别下" class="headerlink" title="5.2 REPEATABLE READ隔离级别下"></a><strong>5.2 REPEATABLE READ隔离级别下</strong></h5><p>使用<code>REPEATABLE READ</code>隔离级别的事务来说，只会在第一次执行查询语句时生成一个 ReadView ，之后的查询就不会重复生成了。</p>
<h5 id="5-3-如何解决幻读"><a href="#5-3-如何解决幻读" class="headerlink" title="5.3 如何解决幻读"></a><strong>5.3</strong> <strong>如何解决幻读</strong></h5><p>假设现在表 student 中只有一条数据，数据内容中，主键 id=1，隐藏的 trx_id=10，它的 undo log 如下图所示。</p>
<p><img src="https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202204051556631.png" alt="image-20220405155640520"></p>
<p>假设现在有事务 A 和事务 B 并发执行，<code>事务 A</code>的事务 id 为<code>20</code>，<code>事务 B</code>的事务 id 为<code>30</code>。</p>
<p>步骤1：事务 A 开始第一次查询数据，查询的 SQL 语句如下。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select * from student where id &gt;&#x3D; 1;</span><br></pre></td></tr></table></figure>

<p>在开始查询之前，MySQL 会为事务 A 产生一个 ReadView，此时 ReadView 的内容如下：<code>trx_ids= [20,30]</code>，<code>up_limit_id=20</code>，<code>low_limit_id=31</code>，<code>creator_trx_id=20</code>。</p>
<p>由于此时表 student 中只有一条数据，且符合 where id&gt;=1 条件，因此会查询出来。然后根据 ReadView机制，发现该行数据的trx_id=10，小于事务 A 的 ReadView 里 up_limit_id，这表示这条数据是事务 A 开启之前，其他事务就已经提交了的数据，因此事务 A 可以读取到。</p>
<p>结论：事务 A 的第一次查询，能读取到一条数据，id=1。</p>
<p>步骤2：接着事务 B(trx_id=30)，往表 student 中新插入两条数据，并提交事务。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">insert into student(id,name) values(2,&#39;李四&#39;); </span><br><span class="line">insert into student(id,name) values(3,&#39;王五&#39;);</span><br></pre></td></tr></table></figure>

<p>此时表student 中就有三条数据了，对应的 undo 如下图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202204051559345.png" alt="image-20220405155909223"></p>
<p>步骤3：接着事务 A 开启第二次查询，根据可重复读隔离级别的规则，此时事务 A 并不会再重新生成ReadView。此时表 student 中的 3 条数据都满足 where id&gt;=1 的条件，因此会先查出来。然后根据ReadView 机制，判断每条数据是不是都可以被事务 A 看到。</p>
<p>1）首先 id=1 的这条数据，前面已经说过了，可以被事务 A 看到。</p>
<p>2）然后是 id=2 的数据，它的 trx_id=30，此时事务 A 发现，这个值处于 up_limit_id 和 low_limit_id 之间，因此还需要再判断 30 是否处于 trx_ids 数组内。由于事务 A 的 trx_ids=[20,30]，因此在数组内，这表示 id=2 的这条数据是与事务 A 在同一时刻启动的其他事务提交的，所以这条数据不能让事务 A 看到。</p>
<p>3）同理，id=3 的这条数据，trx_id 也为 30，因此也不能被事务 A 看见。</p>
<p><img src="https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202204051559867.png" alt="image-20220405155941753"></p>
<p>结论：最终事务 A 的第二次查询，只能查询出 id=1 的这条数据。这和事务 A 的第一次查询的结果是一样的，因此没有出现幻读现象，所以说在 MySQL 的可重复读隔离级别下，不存在幻读问题。</p>
<h4 id="6-总结"><a href="#6-总结" class="headerlink" title="6. 总结"></a><strong>6.</strong> <strong>总结</strong></h4><p>这里介绍了<code>MVCC</code>在<code>READ COMMITTD</code>、<code>REPEATABLE READ</code>这两种隔离级别的事务在执行快照读操作时访问记录的版本链的过程。这样使不同事务的<code>读-写</code>、<code>写-读</code>操作并发执行，从而提升系统性能。</p>
<p>核心点在于 ReadView 的原理，<code>READ COMMITTD</code>、<code>REPEATABLE READ</code>这两个隔离级别的一个很大不同就是生成ReadView的时机不同：</p>
<ul>
<li><code>READ COMMITTD</code>在每一次进行普通SELECT操作前都会生成一个ReadView </li>
<li><code>REPEATABLE READ</code>只在第一次进行普通SELECT操作前生成一个ReadView，之后的查询操作都重复使用这个ReadView就好了。</li>
</ul>
<h3 id="第17章-其它数据库日志"><a href="#第17章-其它数据库日志" class="headerlink" title="第17章 其它数据库日志"></a>第17章 其它数据库日志</h3><h4 id="1-MySQL支持的日志"><a href="#1-MySQL支持的日志" class="headerlink" title="1. MySQL支持的日志"></a><strong>1. MySQL支持的日志</strong></h4><h5 id="1-1-日志类型"><a href="#1-1-日志类型" class="headerlink" title="1.1 日志类型"></a><strong>1.1</strong> <strong>日志类型</strong></h5><p>MySQL有不同类型的日志文件，用来存储不同类型的日志，分为<code>二进制日志</code>、<code>错误日志</code>、<code>通用查询日志</code>和<code>慢查询日志</code>，这也是常用的4种。MySQL 8又新增两种支持的日志：<code>中继日志</code>和<code>数据定义语句日志</code>。使用这些日志文件，可以查看MySQL内部发生的事情。</p>
<ul>
<li><p><strong>慢查询日志：</strong>记录所有执行时间超过long_query_time的所有查询，方便我们对查询进行优化。</p>
</li>
<li><p><strong>通用查询日志：</strong>记录所有连接的起始时间和终止时间，以及连接发送给数据库服务器的所有指令，对我们复原操作的实际场景、发现问题，甚至是对数据库操作的审计都有很大的帮助。</p>
</li>
<li><p><strong>错误日志：</strong>记录MySQL服务的启动、运行或停止MySQL服务时出现的问题，方便我们了解服务器的状态，从而对服务器进行维护。</p>
</li>
<li><p><strong>二进制日志：</strong>记录所有更改数据的语句，可以用于主从服务器之间的数据同步，以及服务器遇到故障时数据的无损失恢复。</p>
</li>
<li><p><strong>中继日志：</strong>用于主从服务器架构中，从服务器用来存放主服务器二进制日志内容的一个中间文件。从服务器通过读取中继日志的内容，来同步主服务器上的操作。</p>
</li>
<li><p><strong>数据定义语句日志：</strong>记录数据定义语句执行的元数据操作。</p>
</li>
</ul>
<p>除二进制日志外，其他日志都是<code>文本文件</code>。默认情况下，所有日志创建于<code>MySQL数据目录</code>中。</p>
<h5 id="1-2-日志的弊端"><a href="#1-2-日志的弊端" class="headerlink" title="1.2 日志的弊端"></a><strong>1.2</strong> <strong>日志的弊端</strong></h5><ul>
<li><p>日志功能会<code>降低MySQL数据库的性能</code>。</p>
</li>
<li><p>日志会<code>占用大量的磁盘空间</code>。</p>
</li>
</ul>
<h4 id="2-通用查询日志-general-query-log"><a href="#2-通用查询日志-general-query-log" class="headerlink" title="2. 通用查询日志(general query log)"></a><strong>2.</strong> <strong>通用查询日志(general query log)</strong></h4><p>通用查询日志用来<code>记录用户的所有操作</code>，包括启动和关闭MySQL服务、所有用户的连接开始时间和截止时间、发给 MySQL 数据库服务器的所有 SQL 指令等。当我们的数据发生异常时，<strong>查看通用查询日志，还原操作时的具体场景</strong>，可以帮助我们准确定位问题。</p>
<h5 id="2-1-查看当前状态"><a href="#2-1-查看当前状态" class="headerlink" title="2.1 查看当前状态"></a><strong>2.1</strong> <strong>查看当前状态</strong></h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; SHOW VARIABLES LIKE &#39;%general%&#39;;</span><br></pre></td></tr></table></figure>

<h5 id="2-2-启动日志"><a href="#2-2-启动日志" class="headerlink" title="2.2 启动日志"></a><strong>2.2</strong> <strong>启动日志</strong></h5><p><strong>方式1：永久性方式</strong></p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="section">[mysqld]</span> </span><br><span class="line"><span class="attr">general_log</span>=<span class="literal">ON</span> </span><br><span class="line"><span class="attr">general_log_file</span>=[path[filename]] <span class="comment">#日志文件所在目录路径，filename为日志文件名</span></span><br></pre></td></tr></table></figure>

<p><strong>方式2：临时性方式</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SET GLOBAL general_log&#x3D;on; # 开启通用查询日志</span><br><span class="line">SET GLOBAL general_log_file&#x3D;’path&#x2F;filename’; # 设置日志文件保存位置</span><br><span class="line">SET GLOBAL general_log&#x3D;off; # 关闭通用查询日志</span><br><span class="line">SHOW VARIABLES LIKE &#39;general_log%&#39;; # 查看设置后情况</span><br></pre></td></tr></table></figure>

<h5 id="2-3-停止日志"><a href="#2-3-停止日志" class="headerlink" title="2.3 停止日志"></a><strong>2.3</strong> <strong>停止日志</strong></h5><p><strong>方式1：永久性方式</strong></p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="section">[mysqld]</span> </span><br><span class="line"><span class="attr">general_log</span>=<span class="literal">OFF</span></span><br></pre></td></tr></table></figure>

<p><strong>方式2：临时性方式</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SET GLOBAL general_log&#x3D;off;</span><br><span class="line">SHOW VARIABLES LIKE &#39;general_log%&#39;;</span><br></pre></td></tr></table></figure>

<h4 id="3-错误日志-error-log"><a href="#3-错误日志-error-log" class="headerlink" title="3.错误日志(error log)"></a><strong>3.错误日志(error log)</strong></h4><h5 id="3-1-启动日志"><a href="#3-1-启动日志" class="headerlink" title="3.1 启动日志"></a><strong>3.1</strong> <strong>启动日志</strong></h5><p>在MySQL数据库中，错误日志功能是<code>默认开启</code>的。而且，错误日志<code>无法被禁止</code>。</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="section">[mysqld]</span> </span><br><span class="line"><span class="attr">log-error</span>=[path/[filename]] <span class="comment">#path为日志文件所在的目录路径，filename为日志文件名</span></span><br></pre></td></tr></table></figure>

<h5 id="3-2-查看日志"><a href="#3-2-查看日志" class="headerlink" title="3.2 查看日志"></a><strong>3.2</strong> <strong>查看日志</strong></h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; SHOW VARIABLES LIKE &#39;log_err%&#39;;</span><br></pre></td></tr></table></figure>

<h5 id="3-3-删除-刷新日志"><a href="#3-3-删除-刷新日志" class="headerlink" title="3.3 删除\刷新日志"></a><strong>3.3</strong> <strong>删除\刷新日志</strong></h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">install -omysql -gmysql -m0644 /dev/null /var/log/mysqld.log</span><br><span class="line">mysqladmin -uroot -p flush-logs</span><br></pre></td></tr></table></figure>

<h4 id="4-二进制日志-bin-log"><a href="#4-二进制日志-bin-log" class="headerlink" title="4. 二进制日志(bin log)"></a><strong>4.</strong> <strong>二进制日志(bin log)</strong></h4><h5 id="4-1-查看默认情况"><a href="#4-1-查看默认情况" class="headerlink" title="4.1 查看默认情况"></a><strong>4.1</strong> <strong>查看默认情况</strong></h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; show variables like &#39;%log_bin%&#39;;</span><br></pre></td></tr></table></figure>

<h5 id="4-2-日志参数设置"><a href="#4-2-日志参数设置" class="headerlink" title="4.2 日志参数设置"></a><strong>4.2</strong> <strong>日志参数设置</strong></h5><p><strong>方式1：永久性方式</strong></p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="section">[mysqld]</span> </span><br><span class="line"><span class="comment">#启用二进制日志 </span></span><br><span class="line"><span class="attr">log-bin</span>=atguigu-bin </span><br><span class="line"><span class="attr">binlog_expire_logs_seconds</span>=<span class="number">600</span> max_binlog_size=<span class="number">100</span>M</span><br></pre></td></tr></table></figure>

<p><strong>设置带文件夹的bin-log日志存放目录</strong></p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="section">[mysqld]</span> </span><br><span class="line"><span class="attr">log-bin</span>=<span class="string">&quot;/var/lib/mysql/binlog/atguigu-bin&quot;</span></span><br></pre></td></tr></table></figure>

<p>注意：新建的文件夹需要使用mysql用户，使用下面的命令即可。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">chown -R -v mysql:mysql binlog</span><br></pre></td></tr></table></figure>

<p><strong>方式2：临时性方式</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># global 级别 </span><br><span class="line">mysql&gt; set global sql_log_bin&#x3D;0; </span><br><span class="line">ERROR 1228 (HY000): Variable &#39;sql_log_bin&#39; is a SESSION variable and can&#96;t be used with SET GLOBAL </span><br><span class="line"></span><br><span class="line"># session级别 </span><br><span class="line">mysql&gt; SET sql_log_bin&#x3D;0; </span><br><span class="line">Query OK, 0 rows affected (0.01 秒)</span><br></pre></td></tr></table></figure>

<h5 id="4-3-查看日志"><a href="#4-3-查看日志" class="headerlink" title="4.3 查看日志"></a><strong>4.3</strong> <strong>查看日志</strong></h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysqlbinlog -v &quot;&#x2F;var&#x2F;lib&#x2F;mysql&#x2F;binlog&#x2F;atguigu-bin.000002&quot;</span><br><span class="line"># 不显示binlog格式的语句</span><br><span class="line">mysqlbinlog -v --base64-output&#x3D;DECODE-ROWS &quot;&#x2F;var&#x2F;lib&#x2F;mysql&#x2F;binlog&#x2F;atguigu-bin.000002&quot;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 可查看参数帮助 </span><br><span class="line">mysqlbinlog --no-defaults --help </span><br><span class="line"></span><br><span class="line"># 查看最后100行 </span><br><span class="line">mysqlbinlog --no-defaults --base64-output&#x3D;decode-rows -vv atguigu-bin.000002 |tail -100 </span><br><span class="line"></span><br><span class="line"># 根据position查找 </span><br><span class="line">mysqlbinlog --no-defaults --base64-output&#x3D;decode-rows -vv atguigu-bin.000002 |grep -A20 &#39;4939002&#39;</span><br></pre></td></tr></table></figure>

<p>上面这种办法读取出binlog日志的全文内容比较多，不容易分辨查看到pos点信息，下面介绍一种更为方便的查询命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; show binlog events [IN &#39;log_name&#39;] [FROM pos] [LIMIT [offset,] row_count];</span><br></pre></td></tr></table></figure>

<ul>
<li><code>IN &#39;log_name&#39;</code>：指定要查询的binlog文件名（不指定就是第一个binlog文件）　</li>
<li><code>FROM pos</code>：指定从哪个pos起始点开始查起（不指定就是从整个文件首个pos点开始算）</li>
<li><code>LIMIT [offset]</code>：偏移量(不指定就是0) </li>
<li><code>row_count</code>:查询总条数（不指定就是所有行）</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; show binlog events in &#39;atguigu-bin.000002&#39;;</span><br></pre></td></tr></table></figure>

<h5 id="4-4-使用日志恢复数据"><a href="#4-4-使用日志恢复数据" class="headerlink" title="4.4 使用日志恢复数据"></a><strong>4.4</strong> <strong>使用日志恢复数据</strong></h5><p>mysqlbinlog恢复数据的语法如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mysqlbinlog [option] filename|mysql –uuser -ppass;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>filename</code>：是日志文件名。</li>
<li><code>option</code>：可选项，比较重要的两对option参数是–start-date、–stop-date 和 –start-position、– stop-position。 <ul>
<li><code>--start-date 和 --stop-date</code>：可以指定恢复数据库的起始时间点和结束时间点。</li>
<li><code>--start-position和--stop-position</code>：可以指定恢复数据的开始位置和结束位置。</li>
</ul>
</li>
</ul>
<blockquote>
<p>注意：使用mysqlbinlog命令进行恢复操作时，必须是编号小的先恢复，例如atguigu-bin.000001必须在atguigu-bin.000002之前恢复。</p>
</blockquote>
<h5 id="4-5-删除二进制日志"><a href="#4-5-删除二进制日志" class="headerlink" title="4.5 删除二进制日志"></a><strong>4.5</strong> <strong>删除二进制日志</strong></h5><p><strong>1. PURGE MASTER LOGS：删除指定日志文件</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PURGE &#123;MASTER | BINARY&#125; LOGS TO ‘指定日志文件名’ </span><br><span class="line">PURGE &#123;MASTER | BINARY&#125; LOGS BEFORE ‘指定日期’</span><br></pre></td></tr></table></figure>

<h4 id="5-再谈二进制日志-binlog"><a href="#5-再谈二进制日志-binlog" class="headerlink" title="5. 再谈二进制日志(binlog)"></a><strong>5.</strong> <strong>再谈二进制日志(binlog)</strong></h4><h5 id="5-1-写入机制"><a href="#5-1-写入机制" class="headerlink" title="5.1 写入机制"></a><strong>5.1</strong> <strong>写入机制</strong></h5><p>binlog的写入时机也非常简单，事务执行过程中，先把日志写到<code>binlog cache</code>，事务提交的时候，再把binlog cache写到binlog文件中。因为一个事务的binlog不能被拆开，无论这个事务多大，也要确保一次性写入，所以系统会给每个线程分配一个块内存作为binlog cache。</p>
<p><img src="https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202204051630535.png" alt="image-20220405163025361"></p>
<p>write和fsync的时机，可以由参数<code>sync_binlog</code>控制，默认是 <code>0</code>。为0的时候，表示每次提交事务都只write，由系统自行判断什么时候执行fsync。虽然性能得到提升，但是机器宕机，page cache里面的binglog 会丢失。如下图：</p>
<p><img src="https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202204051631346.png" alt="image-20220405163125180"></p>
<p>为了安全起见，可以设置为<code>1</code>，表示每次提交事务都会执行fsync，就如同<strong>redo log</strong> <strong>刷盘流程</strong>一样。最后还有一种折中方式，可以设置为N(N&gt;1)，表示每次提交事务都write，但累积N个事务后才fsync。</p>
<p><img src="https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202204051632526.png" alt="image-20220405163205364"></p>
<p>在出现IO瓶颈的场景里，将sync_binlog设置成一个比较大的值，可以提升性能。同样的，如果机器宕机，会丢失最近N个事务的binlog日志。</p>
<h5 id="5-2-binlog与redolog对比"><a href="#5-2-binlog与redolog对比" class="headerlink" title="5.2 binlog与redolog对比"></a><strong>5.2 binlog与redolog对比</strong></h5><ul>
<li>redo log 它是<code>物理日志</code>，记录内容是“在某个数据页上做了什么修改”，属于 InnoDB 存储引擎层产生的。</li>
<li>而 binlog 是<code>逻辑日志</code>，记录内容是语句的原始逻辑，类似于“给 ID=2 这一行的 c 字段加 1”，属于MySQL Server 层。</li>
<li>虽然它们都属于持久化的保证，但是侧重点不同。<ul>
<li>redo log 让InnoDB存储引擎拥有了崩溃恢复能力。</li>
<li>binlog保证了MySQL集群架构的数据一致性</li>
</ul>
</li>
</ul>
<h5 id="5-3-两阶段提交"><a href="#5-3-两阶段提交" class="headerlink" title="5.3 两阶段提交"></a><strong>5.3</strong> <strong>两阶段提交</strong></h5><p>在执行更新语句过程，会记录redo log与binlog两块日志，以基本的事务为单位，redo log在事务执行过程中可以不断写入，而binlog只有在提交事务时才写入，所以redo log与binlog的<code>写入时机</code>不一样。</p>
<p>为了解决两份日志之间的逻辑一致问题，InnoDB存储引擎使用<strong>两阶段提交</strong>方案。</p>
<p><img src="https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202204051637390.png" alt="image-20220405163716222"></p>
<p>使用<strong>两阶段提交</strong>后，写入binlog时发生异常也不会有影响</p>
<p><img src="https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202204051639192.png" alt="image-20220405163902977"></p>
<p>另一个场景，redo log设置commit阶段发生异常，那会不会回滚事务呢？</p>
<p><img src="https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202204051639403.png" alt="image-20220405163927129"></p>
<p>并不会回滚事务，它会执行上图框住的逻辑，虽然redo log是处于prepare阶段，但是能通过事务id找到对应的binlog日志，所以MySQL认为是完整的，就会提交事务恢复数据。</p>
<h4 id="6-中继日志-relay-log"><a href="#6-中继日志-relay-log" class="headerlink" title="6. 中继日志(relay log)"></a><strong>6.</strong> <strong>中继日志(relay log)</strong></h4><h5 id="6-1-介绍"><a href="#6-1-介绍" class="headerlink" title="6.1 介绍"></a><strong>6.1</strong> <strong>介绍</strong></h5><p><strong>中继日志只在主从服务器架构的从服务器上存在</strong>。从服务器为了与主服务器保持一致，要从主服务器读取二进制日志的内容，并且把读取到的信息写入<code>本地的日志文件</code>中，这个从服务器本地的日志文件就叫<code>中继日志</code>。然后，从服务器读取中继日志，并根据中继日志的内容对从服务器的数据进行更新，完成主从服务器的<code>数据同步</code>。</p>
<h5 id="6-2-恢复的典型错误"><a href="#6-2-恢复的典型错误" class="headerlink" title="6.2 恢复的典型错误"></a><strong>6.2</strong> <strong>恢复的典型错误</strong></h5><p>如果从服务器宕机，有的时候为了系统恢复，要重装操作系统，这样就可能会导致你的<code>服务器名称</code>与之前<code>不同</code>。而中继日志里是<code>包含从服务器名</code>的。在这种情况下，就可能导致你恢复从服务器的时候，无法从宕机前的中继日志里读取数据，以为是日志文件损坏了，其实是名称不对了。</p>
<p>解决的方法也很简单，把从服务器的名称改回之前的名称。</p>
<h3 id="第18章-主从复制"><a href="#第18章-主从复制" class="headerlink" title="第18章 主从复制"></a>第18章 主从复制</h3><h4 id="1-主从复制概述"><a href="#1-主从复制概述" class="headerlink" title="1. 主从复制概述"></a><strong>1.</strong> <strong>主从复制概述</strong></h4><h5 id="1-1-如何提升数据库并发能力"><a href="#1-1-如何提升数据库并发能力" class="headerlink" title="1.1 如何提升数据库并发能力"></a><strong>1.1</strong> <strong>如何提升数据库并发能力</strong></h5><p>一般应用对数据库而言都是“<code>读多写少</code>”，也就说对数据库读取数据的压力比较大，有一个思路就是采用数据库集群的方案，做<code>主从架构</code>、进行<code>读写分离</code>，这样同样可以提升数据库的并发处理能力。但并不是所有的应用都需要对数据库进行主从架构的设置，毕竟设置架构本身是有成本的。</p>
<p>如果我们的目的在于提升数据库高并发访问的效率，那么首先考虑的是如何<code>优化SQL和索引</code>，这种方式简单有效；其次才是采用<code>缓存的策略</code>，比如使用 Redis将热点数据保存在内存数据库中，提升读取的效率；最后才是对数据库采用<code>主从架构</code>，进行读写分离。</p>
<h5 id="1-2-主从复制的作用"><a href="#1-2-主从复制的作用" class="headerlink" title="1.2 主从复制的作用"></a><strong>1.2</strong> <strong>主从复制的作用</strong></h5><p><strong>第1个作用：读写分离。</strong></p>
<p><strong>第2个作用就是数据备份。</strong></p>
<p><strong>第3个作用是具有高可用性。</strong></p>
<h4 id="2-主从复制的原理"><a href="#2-主从复制的原理" class="headerlink" title="2. 主从复制的原理"></a><strong>2.</strong> <strong>主从复制的原理</strong></h4><h5 id="2-1-原理剖析"><a href="#2-1-原理剖析" class="headerlink" title="2.1 原理剖析"></a><strong>2.1</strong> <strong>原理剖析</strong></h5><p><strong>三个线程</strong></p>
<p>实际上主从同步的原理就是基于 binlog 进行数据同步的。在主从复制过程中，会基于<code>3 个线程</code>来操作，一个主库线程，两个从库线程。</p>
<p><img src="https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202204051646097.png" alt="image-20220405164559961"></p>
<p><code>二进制日志转储线程</code>（Binlog dump thread）是一个主库线程。当从库线程连接的时候， 主库可以将二进制日志发送给从库，当主库读取事件（Event）的时候，会在 Binlog 上<code>加锁</code>，读取完成之后，再将锁释放掉。</p>
<p><code>从库 I/O 线程</code>会连接到主库，向主库发送请求更新 Binlog。这时从库的 I/O 线程就可以读取到主库的二进制日志转储线程发送的 Binlog 更新部分，并且拷贝到本地的中继日志 （Relay log）。</p>
<p><code>从库 SQL 线程</code>会读取从库中的中继日志，并且执行日志中的事件，将从库中的数据与主库保持同步。</p>
<p><img src="https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202204051647759.png" alt="image-20220405164718627"></p>
<p><strong>复制三步骤</strong></p>
<p>步骤1：<code>Master</code>将写操作记录到二进制日志（<code>binlog</code>）。</p>
<p>步骤2：<code>Slave</code>将<code>Master</code>的binary log events拷贝到它的中继日志（<code>relay log</code>）；</p>
<p>步骤3：<code>Slave</code>重做中继日志中的事件，将改变应用到自己的数据库中。 MySQL复制是异步的且串行化的，而且重启后从<code>接入点</code>开始复制。</p>
<p><strong>复制的问题</strong></p>
<p>复制的最大问题：<code>延时</code></p>
<h5 id="2-2-复制的基本原则"><a href="#2-2-复制的基本原则" class="headerlink" title="2.2 复制的基本原则"></a><strong>2.2</strong> <strong>复制的基本原则</strong></h5><ul>
<li><p>每个<code>Slave</code>只有一个<code>Master</code></p>
</li>
<li><p>每个<code>Slave</code>只能有一个唯一的服务器ID</p>
</li>
<li><p>每个<code>Master</code>可以有多个<code>Slave</code></p>
</li>
</ul>
<h4 id="3-同步数据一致性问题"><a href="#3-同步数据一致性问题" class="headerlink" title="3. 同步数据一致性问题"></a><strong>3.</strong> <strong>同步数据一致性问题</strong></h4><p><strong>主从同步的要求：</strong></p>
<ul>
<li><p>读库和写库的数据一致(最终一致)；</p>
</li>
<li><p>写数据必须写到写库；</p>
</li>
<li><p>读数据必须到读库(不一定)；</p>
</li>
</ul>
<h5 id="3-1-理解主从延迟问题"><a href="#3-1-理解主从延迟问题" class="headerlink" title="3.1 理解主从延迟问题"></a><strong>3.1</strong> <strong>理解主从延迟问题</strong></h5><p>进行主从同步的内容是二进制日志，它是一个文件，在进行<code>网络传输</code>的过程中就一定会<code>存在主从延迟</code>（比如 500ms），这样就可能造成用户在从库上读取的数据不是最新的数据，也就是主从同步中的<code>数据不一致性</code>问题。</p>
<h5 id="3-2-主从延迟问题原因"><a href="#3-2-主从延迟问题原因" class="headerlink" title="3.2 主从延迟问题原因"></a><strong>3.2</strong> <strong>主从延迟问题原因</strong></h5><p>在网络正常的时候，日志从主库传给从库所需的时间是很短的，即T2-T1的值是非常小的。即，网络正常情况下，主备延迟的主要来源是备库接收完binlog和执行完这个事务之间的时间差。</p>
<p><strong>主备延迟最直接的表现是，从库消费中继日志（relay log）的速度，比主库生产binlog的速度要慢。</strong>造成原因：</p>
<p>1、从库的机器性能比主库要差</p>
<p>2、从库的压力大</p>
<p>3、大事务的执行</p>
<h5 id="3-3-如何减少主从延迟"><a href="#3-3-如何减少主从延迟" class="headerlink" title="3.3 如何减少主从延迟"></a><strong>3.3</strong> <strong>如何减少主从延迟</strong></h5><p>若想要减少主从延迟的时间，可以采取下面的办法：</p>
<ol>
<li><p>降低多线程大事务并发的概率，优化业务逻辑</p>
</li>
<li><p>优化SQL，避免慢SQL，<code>减少批量操作</code>，建议写脚本以update-sleep这样的形式完成。</p>
</li>
<li><p><code>提高从库机器的配置</code>，减少主库写binlog和从库读binlog的效率差。</p>
</li>
<li><p>尽量采用<code>短的链路</code>，也就是主库和从库服务器的距离尽量要短，提升端口带宽，减少binlog传输的网络延时。</p>
</li>
<li><p>实时性要求的业务读强制走主库，从库只做灾备，备份。</p>
</li>
</ol>
<h5 id="3-4-如何解决一致性问题"><a href="#3-4-如何解决一致性问题" class="headerlink" title="3.4 如何解决一致性问题"></a><strong>3.4</strong> <strong>如何解决一致性问题</strong></h5><p>读写分离情况下，解决主从同步中数据不一致的问题， 就是解决主从之间 数据复制方式 的问题，如果按照数据一致性 从弱到强 来进行划分，有以下 3 种复制方式。</p>
<p><strong>方法</strong> <strong>1：异步复制</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202204051654133.png" alt="image-20220405165455998"></p>
<p><strong>方法</strong> <strong>2：半同步复制</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202204051655175.png" alt="image-20220405165513025"></p>
<p><strong>方法</strong> <strong>3：组复制</strong></p>
<p>首先我们将多个节点共同组成一个复制组，在<code>执行读写（RW）事务</code>的时候，需要通过一致性协议层（Consensus 层）的同意，也就是读写事务想要进行提交，必须要经过组里“大多数人”（对应 Node 节点）的同意，大多数指的是同意的节点数量需要大于 （N/2+1），这样才可以进行提交，而不是原发起方一个说了算。而针对<code>只读（RO）事务</code>则不需要经过组内同意，直接 COMMIT 即可。</p>
<p><img src="https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202204051656560.png" alt="image-20220405165650425"></p>
<h3 id="第19章-数据库备份与恢复"><a href="#第19章-数据库备份与恢复" class="headerlink" title="第19章 数据库备份与恢复"></a>第19章 数据库备份与恢复</h3><h4 id="1-物理备份与逻辑备份"><a href="#1-物理备份与逻辑备份" class="headerlink" title="1. 物理备份与逻辑备份"></a><strong>1.</strong> <strong>物理备份与逻辑备份</strong></h4><p><strong>物理备份</strong>：备份数据文件，转储数据库物理文件到某一目录。物理备份恢复速度比较快，但占用空间比较大，MySQL中可以用<code>xtrabackup</code>工具来进行物理备份。</p>
<p><strong>逻辑备份</strong>：对数据库对象利用工具进行导出工作，汇总入备份文件内。逻辑备份恢复速度慢，但占用空间小，更灵活。MySQL 中常用的逻辑备份工具为<code>mysqldump</code>。逻辑备份就是<code>备份sql语句</code>，在恢复的时候执行备份的sql语句实现数据库数据的重现。</p>
<h4 id="2-mysqldump实现逻辑备份"><a href="#2-mysqldump实现逻辑备份" class="headerlink" title="2. mysqldump实现逻辑备份"></a><strong>2. mysqldump实现逻辑备份</strong></h4><h5 id="2-1-备份一个数据库"><a href="#2-1-备份一个数据库" class="headerlink" title="2.1 备份一个数据库"></a><strong>2.1</strong> <strong>备份一个数据库</strong></h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mysqldump –u 用户名称 –h 主机名称 –p密码 待备份的数据库名称[tbname, [tbname...]]&gt; 备份文件名 称.sql</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mysqldump -uroot -p atguigu&gt;atguigu.sql #备份文件存储在当前目录下</span><br><span class="line">mysqldump -uroot -p atguigudb1 &gt; /var/lib/mysql/atguigu.sql</span><br></pre></td></tr></table></figure>

<h5 id="2-2-备份全部数据库"><a href="#2-2-备份全部数据库" class="headerlink" title="2.2 备份全部数据库"></a><strong>2.2</strong> <strong>备份全部数据库</strong></h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mysqldump -uroot -pxxxxxx --all-databases &gt; all_database.sql </span><br><span class="line">mysqldump -uroot -pxxxxxx -A &gt; all_database.sql</span><br></pre></td></tr></table></figure>

<h5 id="2-3-备份部分数据库"><a href="#2-3-备份部分数据库" class="headerlink" title="2.3 备份部分数据库"></a><strong>2.3</strong> <strong>备份部分数据库</strong></h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mysqldump –u user –h host –p --databases [数据库的名称1 [数据库的名称2...]] &gt; 备份文件名 称.sql</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mysqldump -uroot -p --databases atguigu atguigu12 &gt;two_database.sql</span><br><span class="line">mysqldump -uroot -p -B atguigu atguigu12 &gt; two_database.sql</span><br></pre></td></tr></table></figure>

<h5 id="2-4-备份部分表"><a href="#2-4-备份部分表" class="headerlink" title="2.4 备份部分表"></a><strong>2.4</strong> <strong>备份部分表</strong></h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mysqldump –u user –h host –p 数据库的名称 [表名1 [表名2...]] &gt; 备份文件名称.sql</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mysqldump -uroot -p atguigu book&gt; book.sql</span><br><span class="line"><span class="meta">#</span><span class="bash">备份多张表</span> </span><br><span class="line">mysqldump -uroot -p atguigu book account &gt; 2_tables_bak.sql</span><br></pre></td></tr></table></figure>

<h5 id="2-5-备份单表的部分数据"><a href="#2-5-备份单表的部分数据" class="headerlink" title="2.5 备份单表的部分数据"></a><strong>2.5</strong> <strong>备份单表的部分数据</strong></h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mysqldump -uroot -p atguigu student --where=&quot;id &lt; 10 &quot; &gt; student_part_id10_low_bak.sql</span><br></pre></td></tr></table></figure>

<h5 id="2-6-排除某些表的备份"><a href="#2-6-排除某些表的备份" class="headerlink" title="2.6 排除某些表的备份"></a><strong>2.6</strong> <strong>排除某些表的备份</strong></h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mysqldump -uroot -p atguigu --ignore-table=atguigu.student &gt; no_stu_bak.sql</span><br></pre></td></tr></table></figure>

<h5 id="2-7-只备份结构或只备份数据"><a href="#2-7-只备份结构或只备份数据" class="headerlink" title="2.7 只备份结构或只备份数据"></a><strong>2.7</strong> <strong>只备份结构或只备份数据</strong></h5><ul>
<li>只备份结构</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mysqldump -uroot -p atguigu --no-data &gt; atguigu_no_data_bak.sql</span><br></pre></td></tr></table></figure>

<ul>
<li>只备份数据</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mysqldump -uroot -p atguigu --no-create-info &gt; atguigu_no_create_info_bak.sql</span><br></pre></td></tr></table></figure>

<h5 id="2-8-备份中包含存储过程、函数、事件"><a href="#2-8-备份中包含存储过程、函数、事件" class="headerlink" title="2.8 备份中包含存储过程、函数、事件"></a><strong>2.8</strong> <strong>备份中包含存储过程、函数、事件</strong></h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mysqldump -uroot -p -R -E --databases atguigu &gt; fun_atguigu_bak.sql</span><br></pre></td></tr></table></figure>

<h4 id="3-mysql命令恢复数据"><a href="#3-mysql命令恢复数据" class="headerlink" title="3. mysql命令恢复数据"></a><strong>3. mysql命令恢复数据</strong></h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mysql –u root –p [dbname] &lt; backup.sql</span><br></pre></td></tr></table></figure>

<h5 id="3-1-单库备份中恢复单库"><a href="#3-1-单库备份中恢复单库" class="headerlink" title="3.1 单库备份中恢复单库"></a><strong>3.1</strong> <strong>单库备份中恢复单库</strong></h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">备份文件中包含了创建数据库的语句</span></span><br><span class="line">mysql -uroot -p &lt; atguigu.sql</span><br><span class="line"><span class="meta">#</span><span class="bash">备份文件中不包含了创建数据库的语句</span></span><br><span class="line">mysql -uroot -p atguigu4&lt; atguigu.sql</span><br></pre></td></tr></table></figure>

<h5 id="3-2-全量备份恢复"><a href="#3-2-全量备份恢复" class="headerlink" title="3.2 全量备份恢复"></a><strong>3.2</strong> <strong>全量备份恢复</strong></h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mysql –u root –p &lt; all.sql</span><br></pre></td></tr></table></figure>

<h5 id="3-3-从全量备份中恢复单库"><a href="#3-3-从全量备份中恢复单库" class="headerlink" title="3.3 从全量备份中恢复单库"></a><strong>3.3</strong> <strong>从全量备份中恢复单库</strong></h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sed -n &#x27;/^-- Current Database: `atguigu`/,/^-- Current Database: `/p&#x27; all_database.sql &gt; atguigu.sql </span><br><span class="line"><span class="meta">#</span><span class="bash">分离完成后我们再导入atguigu.sql即可恢复单个库</span></span><br></pre></td></tr></table></figure>

<h5 id="3-4-从单库备份中恢复单表"><a href="#3-4-从单库备份中恢复单表" class="headerlink" title="3.4 从单库备份中恢复单表"></a><strong>3.4</strong> <strong>从单库备份中恢复单表</strong></h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat atguigu.sql | sed -e &#x27;/./&#123;H;$!d;&#125;&#x27; -e &#x27;x;/CREATE TABLE `class`/!d;q&#x27; &gt; class_structure.sql </span><br><span class="line">cat atguigu.sql | grep --ignore-case &#x27;insert into `class`&#x27; &gt; class_data.sql </span><br><span class="line"><span class="meta">#</span><span class="bash">用shell语法分离出创建表的语句及插入数据的语句后 再依次导出即可完成恢复</span> </span><br><span class="line"></span><br><span class="line">use atguigu; </span><br><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> <span class="built_in">source</span> class_structure.sql;</span> </span><br><span class="line">Query OK, 0 rows affected, 1 warning (0.00 sec) </span><br><span class="line"></span><br><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> <span class="built_in">source</span> class_data.sql;</span> </span><br><span class="line">Query OK, 1 row affected (0.01 sec)</span><br></pre></td></tr></table></figure>

<h4 id="4-表的导出与导入"><a href="#4-表的导出与导入" class="headerlink" title="4. 表的导出与导入"></a><strong>4.</strong> <strong>表的导出与导入</strong></h4><h5 id="4-1-表的导出"><a href="#4-1-表的导出" class="headerlink" title="4.1 表的导出"></a><strong>4.1</strong> <strong>表的导出</strong></h5><p><strong>1.</strong> <strong>使用SELECT…INTO OUTFILE导出文本文件</strong> </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SHOW GLOBAL VARIABLES LIKE &#39;%secure%&#39;;</span><br><span class="line">SELECT * FROM account INTO OUTFILE &quot;&#x2F;var&#x2F;lib&#x2F;mysql-files&#x2F;account.txt&quot;;</span><br></pre></td></tr></table></figure>

<p><strong>2.</strong> <strong>使用mysqldump命令导出文本文件</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mysqldump -uroot -p -T &quot;/var/lib/mysql-files/&quot; atguigu account</span><br><span class="line"><span class="meta">#</span><span class="bash"> 或</span></span><br><span class="line">mysqldump -uroot -p -T &quot;/var/lib/mysql-files/&quot; atguigu account --fields-terminated- by=&#x27;,&#x27; --fields-optionally-enclosed-by=&#x27;\&quot;&#x27;</span><br></pre></td></tr></table></figure>

<p><strong>3.</strong> <strong>使用mysql命令导出文本文件</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mysql -uroot -p --execute=&quot;SELECT * FROM account;&quot; atguigu&gt; &quot;/var/lib/mysql-files/account.txt&quot;</span><br></pre></td></tr></table></figure>

<h5 id="4-2-表的导入"><a href="#4-2-表的导入" class="headerlink" title="4.2 表的导入"></a><strong>4.2</strong> <strong>表的导入</strong></h5><p><strong>1.</strong> <strong>使用LOAD DATA INFILE方式导入文本文件</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">LOAD DATA INFILE &#39;&#x2F;var&#x2F;lib&#x2F;mysql-files&#x2F;account_0.txt&#39; INTO TABLE atguigu.account;</span><br><span class="line"># 或</span><br><span class="line">LOAD DATA INFILE &#39;&#x2F;var&#x2F;lib&#x2F;mysql-files&#x2F;account_1.txt&#39; INTO TABLE atguigu.account FIELDS TERMINATED BY &#39;,&#39; ENCLOSED BY &#39;\&quot;&#39;;</span><br></pre></td></tr></table></figure>

<p><strong>2.</strong> <strong>使用mysqlimport方式导入文本文件</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mysqlimport -uroot -p atguigu &#x27;/var/lib/mysql-files/account.txt&#x27; --fields-terminated- by=&#x27;,&#x27; --fields-optionally-enclosed-by=&#x27;\&quot;&#x27;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
</search>
